{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPyth.sol\";\nimport \"./PythErrors.sol\";\n\nabstract contract AbstractPyth is IPyth {\n    /// @notice Returns the price feed with given id.\n    /// @dev Reverts if the price does not exist.\n    /// @param id The Pyth Price Feed ID of which to fetch the PriceFeed.\n    function queryPriceFeed(\n        bytes32 id\n    ) public view virtual returns (PythStructs.PriceFeed memory priceFeed);\n\n    /// @notice Returns true if a price feed with the given id exists.\n    /// @param id The Pyth Price Feed ID of which to check its existence.\n    function priceFeedExists(\n        bytes32 id\n    ) public view virtual returns (bool exists);\n\n    function getValidTimePeriod()\n        public\n        view\n        virtual\n        override\n        returns (uint validTimePeriod);\n\n    function getPrice(\n        bytes32 id\n    ) external view virtual override returns (PythStructs.Price memory price) {\n        return getPriceNoOlderThan(id, getValidTimePeriod());\n    }\n\n    function getEmaPrice(\n        bytes32 id\n    ) external view virtual override returns (PythStructs.Price memory price) {\n        return getEmaPriceNoOlderThan(id, getValidTimePeriod());\n    }\n\n    function getPriceUnsafe(\n        bytes32 id\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        PythStructs.PriceFeed memory priceFeed = queryPriceFeed(id);\n        return priceFeed.price;\n    }\n\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        price = getPriceUnsafe(id);\n\n        if (diff(block.timestamp, price.publishTime) > age)\n            revert PythErrors.StalePrice();\n\n        return price;\n    }\n\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        PythStructs.PriceFeed memory priceFeed = queryPriceFeed(id);\n        return priceFeed.emaPrice;\n    }\n\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        price = getEmaPriceUnsafe(id);\n\n        if (diff(block.timestamp, price.publishTime) > age)\n            revert PythErrors.StalePrice();\n\n        return price;\n    }\n\n    function diff(uint x, uint y) internal pure returns (uint) {\n        if (x > y) {\n            return x - y;\n        } else {\n            return y - x;\n        }\n    }\n\n    // Access modifier is overridden to public to be able to call it locally.\n    function updatePriceFeeds(\n        bytes[] calldata updateData\n    ) public payable virtual override;\n\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable virtual override {\n        if (priceIds.length != publishTimes.length)\n            revert PythErrors.InvalidArgument();\n\n        for (uint i = 0; i < priceIds.length; i++) {\n            if (\n                !priceFeedExists(priceIds[i]) ||\n                queryPriceFeed(priceIds[i]).price.publishTime < publishTimes[i]\n            ) {\n                updatePriceFeeds(updateData);\n                return;\n            }\n        }\n\n        revert PythErrors.NoFreshUpdate();\n    }\n\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    )\n        external\n        payable\n        virtual\n        override\n        returns (PythStructs.PriceFeed[] memory priceFeeds);\n\n    function parsePriceFeedUpdatesUnique(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    )\n        external\n        payable\n        virtual\n        override\n        returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\n\n    /// @notice Returns the price and confidence interval.\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\n    /// @dev Reverts if the EMA price is not available.\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\n    /// this method will return the first update. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesUnique(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/MockPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./AbstractPyth.sol\";\nimport \"./PythStructs.sol\";\nimport \"./PythErrors.sol\";\n\ncontract MockPyth is AbstractPyth {\n    mapping(bytes32 => PythStructs.PriceFeed) priceFeeds;\n\n    uint singleUpdateFeeInWei;\n    uint validTimePeriod;\n\n    constructor(uint _validTimePeriod, uint _singleUpdateFeeInWei) {\n        singleUpdateFeeInWei = _singleUpdateFeeInWei;\n        validTimePeriod = _validTimePeriod;\n    }\n\n    function queryPriceFeed(\n        bytes32 id\n    ) public view override returns (PythStructs.PriceFeed memory priceFeed) {\n        if (priceFeeds[id].id == 0) revert PythErrors.PriceFeedNotFound();\n        return priceFeeds[id];\n    }\n\n    function priceFeedExists(bytes32 id) public view override returns (bool) {\n        return (priceFeeds[id].id != 0);\n    }\n\n    function getValidTimePeriod() public view override returns (uint) {\n        return validTimePeriod;\n    }\n\n    // Takes an array of encoded price feeds and stores them.\n    // You can create this data either by calling createPriceFeedUpdateData or\n    // by using web3.js or ethers abi utilities.\n    function updatePriceFeeds(\n        bytes[] calldata updateData\n    ) public payable override {\n        uint requiredFee = getUpdateFee(updateData);\n        if (msg.value < requiredFee) revert PythErrors.InsufficientFee();\n\n        for (uint i = 0; i < updateData.length; i++) {\n            PythStructs.PriceFeed memory priceFeed = abi.decode(\n                updateData[i],\n                (PythStructs.PriceFeed)\n            );\n\n            uint lastPublishTime = priceFeeds[priceFeed.id].price.publishTime;\n\n            if (lastPublishTime < priceFeed.price.publishTime) {\n                // Price information is more recent than the existing price information.\n                priceFeeds[priceFeed.id] = priceFeed;\n                emit PriceFeedUpdate(\n                    priceFeed.id,\n                    uint64(priceFeed.price.publishTime),\n                    priceFeed.price.price,\n                    priceFeed.price.conf\n                );\n            }\n        }\n    }\n\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) public view override returns (uint feeAmount) {\n        return singleUpdateFeeInWei * updateData.length;\n    }\n\n    function parsePriceFeedUpdatesInternal(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime,\n        bool unique\n    ) internal returns (PythStructs.PriceFeed[] memory feeds) {\n        uint requiredFee = getUpdateFee(updateData);\n        if (msg.value < requiredFee) revert PythErrors.InsufficientFee();\n\n        feeds = new PythStructs.PriceFeed[](priceIds.length);\n\n        for (uint i = 0; i < priceIds.length; i++) {\n            for (uint j = 0; j < updateData.length; j++) {\n                uint64 prevPublishTime;\n                (feeds[i], prevPublishTime) = abi.decode(\n                    updateData[j],\n                    (PythStructs.PriceFeed, uint64)\n                );\n\n                uint publishTime = feeds[i].price.publishTime;\n                if (priceFeeds[feeds[i].id].price.publishTime < publishTime) {\n                    priceFeeds[feeds[i].id] = feeds[i];\n                    emit PriceFeedUpdate(\n                        feeds[i].id,\n                        uint64(publishTime),\n                        feeds[i].price.price,\n                        feeds[i].price.conf\n                    );\n                }\n\n                if (feeds[i].id == priceIds[i]) {\n                    if (\n                        minPublishTime <= publishTime &&\n                        publishTime <= maxPublishTime &&\n                        (!unique || prevPublishTime < minPublishTime)\n                    ) {\n                        break;\n                    } else {\n                        feeds[i].id = 0;\n                    }\n                }\n            }\n\n            if (feeds[i].id != priceIds[i])\n                revert PythErrors.PriceFeedNotFoundWithinRange();\n        }\n    }\n\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable override returns (PythStructs.PriceFeed[] memory feeds) {\n        return\n            parsePriceFeedUpdatesInternal(\n                updateData,\n                priceIds,\n                minPublishTime,\n                maxPublishTime,\n                false\n            );\n    }\n\n    function parsePriceFeedUpdatesUnique(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable override returns (PythStructs.PriceFeed[] memory feeds) {\n        return\n            parsePriceFeedUpdatesInternal(\n                updateData,\n                priceIds,\n                minPublishTime,\n                maxPublishTime,\n                true\n            );\n    }\n\n    function createPriceFeedUpdateData(\n        bytes32 id,\n        int64 price,\n        uint64 conf,\n        int32 expo,\n        int64 emaPrice,\n        uint64 emaConf,\n        uint64 publishTime,\n        uint64 prevPublishTime\n    ) public pure returns (bytes memory priceFeedData) {\n        PythStructs.PriceFeed memory priceFeed;\n\n        priceFeed.id = id;\n\n        priceFeed.price.price = price;\n        priceFeed.price.conf = conf;\n        priceFeed.price.expo = expo;\n        priceFeed.price.publishTime = publishTime;\n\n        priceFeed.emaPrice.price = emaPrice;\n        priceFeed.emaPrice.conf = emaConf;\n        priceFeed.emaPrice.expo = expo;\n        priceFeed.emaPrice.publishTime = publishTime;\n\n        priceFeedData = abi.encode(priceFeed, prevPublishTime);\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythErrors.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nlibrary PythErrors {\n    // Function arguments are invalid (e.g., the arguments lengths mismatch)\n    // Signature: 0xa9cb9e0d\n    error InvalidArgument();\n    // Update data is coming from an invalid data source.\n    // Signature: 0xe60dce71\n    error InvalidUpdateDataSource();\n    // Update data is invalid (e.g., deserialization error)\n    // Signature: 0xe69ffece\n    error InvalidUpdateData();\n    // Insufficient fee is paid to the method.\n    // Signature: 0x025dbdd4\n    error InsufficientFee();\n    // There is no fresh update, whereas expected fresh updates.\n    // Signature: 0xde2c57fa\n    error NoFreshUpdate();\n    // There is no price feed found within the given range or it does not exists.\n    // Signature: 0x45805f5d\n    error PriceFeedNotFoundWithinRange();\n    // Price feed not found or it is not pushed on-chain yet.\n    // Signature: 0x14aebe68\n    error PriceFeedNotFound();\n    // Requested price is stale.\n    // Signature: 0x19abf40e\n    error StalePrice();\n    // Given message is not a valid Wormhole VAA.\n    // Signature: 0x2acbe915\n    error InvalidWormholeVaa();\n    // Governance message is invalid (e.g., deserialization error).\n    // Signature: 0x97363b35\n    error InvalidGovernanceMessage();\n    // Governance message is not for this contract.\n    // Signature: 0x63daeb77\n    error InvalidGovernanceTarget();\n    // Governance message is coming from an invalid data source.\n    // Signature: 0x360f2d87\n    error InvalidGovernanceDataSource();\n    // Governance message is old.\n    // Signature: 0x88d1b847\n    error OldGovernanceMessage();\n    // The wormhole address to set in SetWormholeAddress governance is invalid.\n    // Signature: 0x13d3ed82\n    error InvalidWormholeAddressToSet();\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n}\n"
    },
    "contracts/AdminContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { UUPSUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { OwnableUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport { ConfigurableAddresses } from \"./Dependencies/ConfigurableAddresses.sol\";\nimport { DECIMAL_PRECISION as _DECIMAL_PRECISION } from \"./Dependencies/TrenMath.sol\";\n\nimport { IAdminContract } from \"./Interfaces/IAdminContract.sol\";\nimport { IStabilityPool } from \"./Interfaces/IStabilityPool.sol\";\nimport { ITrenBoxStorage } from \"./Interfaces/ITrenBoxStorage.sol\";\n\n/**\n * @title AdminContract\n * @notice Contains all the functions to create a new collateral or modify its parameters.\n * It is called by other contracts to check if a collateral is valid and what are their parameters.\n */\ncontract AdminContract is\n    IAdminContract,\n    UUPSUpgradeable,\n    OwnableUpgradeable,\n    ConfigurableAddresses\n{\n    // Constants\n    // --------------------------------------------------------------------------------------------------------\n\n    /// @notice The contract name.\n    string public constant NAME = \"AdminContract\";\n\n    /// @notice The scaled number which means 100 percent, 1e18 == 100%.\n    uint256 public constant _100pct = 1 ether;\n\n    /// @notice The default borrowing fee, 0.5%.\n    uint256 public constant BORROWING_FEE_DEFAULT = 0.005 ether;\n\n    /// @notice The default critical collateral ratio, 150%.\n    uint256 public constant CCR_DEFAULT = 1.5 ether;\n\n    /// @notice The default minimum collateral ratio, 110%.\n    uint256 public constant MCR_DEFAULT = 1.1 ether;\n\n    /// @notice The default minimum amount of debt token to mint.\n    uint256 public constant MIN_NET_DEBT_DEFAULT = 2000 ether;\n\n    /// @notice The default mint cap, 1 million trenUSD.\n    uint256 public constant MINT_CAP_DEFAULT = 1_000_000 ether;\n\n    /// @notice The default liquidation fee, dividing by 200 yields 0.5%.\n    uint256 public constant PERCENT_DIVISOR_DEFAULT = 200;\n\n    /// @notice The default floor of redemption fee, 0.5%.\n    uint256 public constant REDEMPTION_FEE_FLOOR_DEFAULT = 0.005 ether;\n\n    /// @notice The default block timestamp for redemption.\n    uint256 public constant REDEMPTION_BLOCK_TIMESTAMP_DEFAULT = type(uint256).max;\n\n    // State\n    // ------------------------------------------------------------------------------------------------------------\n\n    /**\n     * @dev The mapping from collateral asset to its parameters.\n     * Cannot be public as struct has too many variables for the stack.\n     * Create special view structs/getters instead.\n     */\n    mapping(address collateral => CollateralParams params) internal collateralParams;\n\n    /// @notice The storage struct variable to store flash loan parameters.\n    FlashLoanParams public flashLoanParams;\n\n    /// @notice list of all collateral types in collateralParams (active and deprecated).\n    address[] public validCollateral;\n\n    /// @notice Checks if all initial collaterals have been configured or not.\n    bool public isSetupInitialized;\n\n    /// @notice If true, collected fees go to stakers; if false, to the treasury.\n    bool public routeToTRENStaking = false;\n\n    // Modifiers\n    // --------------------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Require that the collateral exists in the controller. If it is not the 0th index, and\n     * the index is still 0 then it does not exist in the mapping.\n     * no require here for valid collateral 0 index because that means it exists.\n     */\n    modifier exists(address _collateral) {\n        _exists(_collateral);\n        _;\n    }\n\n    /// @dev Modifier to check that the caller is timelock contract.\n    modifier onlyTimelock() {\n        if (isSetupInitialized) {\n            if (msg.sender != timelockAddress) {\n                revert AdminContract__OnlyTimelock();\n            }\n        } else {\n            if (msg.sender != owner()) {\n                revert AdminContract__OnlyOwner();\n            }\n        }\n        _;\n    }\n\n    /// @dev Modifier to check that the specific collateral is active and the input value is valid.\n    modifier safeCheck(\n        string memory parameter,\n        address _collateral,\n        uint256 enteredValue,\n        uint256 min,\n        uint256 max\n    ) {\n        if (!collateralParams[_collateral].active) {\n            revert AdminContract__CollateralNotConfigured();\n        }\n\n        if (enteredValue < min || enteredValue > max) {\n            revert SafeCheckError(parameter, enteredValue, min, max);\n        }\n        _;\n    }\n\n    // Initializers\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Runs all the setup logic only once.\n     * @param initialOwner The address of initial owner.\n     */\n    function initialize(address initialOwner) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n    }\n\n    /**\n     * @dev The deployment script will call this function when all initial collaterals\n     * have been configured; after this is set to true,\n     * all subsequent config/setters will need to go through the timelocks.\n     */\n    function setSetupIsInitialized() external onlyTimelock {\n        isSetupInitialized = true;\n    }\n\n    // External Functions\n    // -----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IAdminContract\n    function addNewCollateral(\n        address _collateral,\n        uint256 _debtTokenGasCompensation\n    )\n        external\n        override\n        onlyTimelock\n    {\n        if (collateralParams[_collateral].mcr != 0) {\n            revert AdminContract__CollateralExists();\n        }\n\n        // require(_decimals == DEFAULT_DECIMALS, \"collaterals must have the default decimals\");\n        validCollateral.push(_collateral);\n        collateralParams[_collateral] = CollateralParams({\n            index: validCollateral.length - 1,\n            active: false,\n            borrowingFee: BORROWING_FEE_DEFAULT,\n            ccr: CCR_DEFAULT,\n            mcr: MCR_DEFAULT,\n            debtTokenGasCompensation: _debtTokenGasCompensation,\n            minNetDebt: MIN_NET_DEBT_DEFAULT,\n            mintCap: MINT_CAP_DEFAULT,\n            percentDivisor: PERCENT_DIVISOR_DEFAULT,\n            redemptionFeeFloor: REDEMPTION_FEE_FLOOR_DEFAULT,\n            redemptionBlockTimestamp: REDEMPTION_BLOCK_TIMESTAMP_DEFAULT\n        });\n\n        emit CollateralAdded(_collateral);\n\n        IStabilityPool(stabilityPool).addCollateralType(_collateral);\n    }\n\n    /// @inheritdoc IAdminContract\n    function setCollateralParameters(\n        address _collateral,\n        uint256 _borrowingFee,\n        uint256 _ccr,\n        uint256 _mcr,\n        uint256 _minNetDebt,\n        uint256 _mintCap,\n        uint256 _percentDivisor,\n        uint256 _redemptionFeeFloor\n    )\n        external\n        override\n        onlyTimelock\n    {\n        collateralParams[_collateral].active = true;\n        setBorrowingFee(_collateral, _borrowingFee);\n        setCCR(_collateral, _ccr);\n        setMCR(_collateral, _mcr);\n        setMinNetDebt(_collateral, _minNetDebt);\n        setMintCap(_collateral, _mintCap);\n        setPercentDivisor(_collateral, _percentDivisor);\n        setRedemptionFeeFloor(_collateral, _redemptionFeeFloor);\n    }\n\n    /// @inheritdoc IAdminContract\n    function setIsActive(address _collateral, bool _active) external onlyTimelock {\n        CollateralParams storage collParams = collateralParams[_collateral];\n        collParams.active = _active;\n    }\n\n    /// @inheritdoc IAdminContract\n    function setBorrowingFee(\n        address _collateral,\n        uint256 _borrowingFee\n    )\n        public\n        override\n        onlyTimelock\n        safeCheck(\"Borrowing Fee\", _collateral, _borrowingFee, 0, 0.1 ether) // 0% - 10%\n    {\n        CollateralParams storage collParams = collateralParams[_collateral];\n        uint256 oldBorrowing = collParams.borrowingFee;\n        collParams.borrowingFee = _borrowingFee;\n        emit BorrowingFeeChanged(oldBorrowing, _borrowingFee);\n    }\n\n    /// @inheritdoc IAdminContract\n    function setCCR(\n        address _collateral,\n        uint256 _newCCR\n    )\n        public\n        override\n        onlyTimelock\n        safeCheck(\"CCR\", _collateral, _newCCR, 1 ether, 10 ether) // 100% - 1,000%\n    {\n        CollateralParams storage collParams = collateralParams[_collateral];\n        uint256 oldCCR = collParams.ccr;\n        collParams.ccr = _newCCR;\n        emit CCRChanged(oldCCR, _newCCR);\n    }\n\n    /// @inheritdoc IAdminContract\n    function setMCR(\n        address _collateral,\n        uint256 _newMCR\n    )\n        public\n        override\n        onlyTimelock\n        safeCheck(\"MCR\", _collateral, _newMCR, 1.01 ether, 10 ether) // 101% - 1,000%\n    {\n        CollateralParams storage collParams = collateralParams[_collateral];\n        uint256 oldMCR = collParams.mcr;\n        collParams.mcr = _newMCR;\n        emit MCRChanged(oldMCR, _newMCR);\n    }\n\n    /// @inheritdoc IAdminContract\n    function setMinNetDebt(\n        address _collateral,\n        uint256 _minNetDebt\n    )\n        public\n        override\n        onlyTimelock\n        safeCheck(\"Min Net Debt\", _collateral, _minNetDebt, 0, 2000 ether)\n    {\n        CollateralParams storage collParams = collateralParams[_collateral];\n        uint256 oldMinNet = collParams.minNetDebt;\n        collParams.minNetDebt = _minNetDebt;\n        emit MinNetDebtChanged(oldMinNet, _minNetDebt);\n    }\n\n    /// @inheritdoc IAdminContract\n    function setMintCap(address _collateral, uint256 _mintCap) public override onlyTimelock {\n        CollateralParams storage collParams = collateralParams[_collateral];\n        uint256 oldMintCap = collParams.mintCap;\n        collParams.mintCap = _mintCap;\n        emit MintCapChanged(oldMintCap, _mintCap);\n    }\n\n    /// @inheritdoc IAdminContract\n    function setPercentDivisor(\n        address _collateral,\n        uint256 _percentDivisor\n    )\n        public\n        override\n        onlyTimelock\n        safeCheck(\"Percent Divisor\", _collateral, _percentDivisor, 2, 200)\n    {\n        CollateralParams storage collParams = collateralParams[_collateral];\n        uint256 oldPercent = collParams.percentDivisor;\n        collParams.percentDivisor = _percentDivisor;\n        emit PercentDivisorChanged(oldPercent, _percentDivisor);\n    }\n\n    /// @inheritdoc IAdminContract\n    function setRedemptionFeeFloor(\n        address _collateral,\n        uint256 _redemptionFeeFloor\n    )\n        public\n        override\n        onlyTimelock\n        safeCheck(\"Redemption Fee Floor\", _collateral, _redemptionFeeFloor, 0.001 ether, 0.1 ether)\n    {\n        CollateralParams storage collParams = collateralParams[_collateral];\n        uint256 oldRedemptionFeeFloor = collParams.redemptionFeeFloor;\n        collParams.redemptionFeeFloor = _redemptionFeeFloor;\n        emit RedemptionFeeFloorChanged(oldRedemptionFeeFloor, _redemptionFeeFloor);\n    }\n\n    /// @inheritdoc IAdminContract\n    function setRedemptionBlockTimestamp(\n        address _collateral,\n        uint256 _blockTimestamp\n    )\n        external\n        override\n        onlyTimelock\n    {\n        collateralParams[_collateral].redemptionBlockTimestamp = _blockTimestamp;\n        emit RedemptionBlockTimestampChanged(_collateral, _blockTimestamp);\n    }\n\n    /// @inheritdoc IAdminContract\n    function setFeeForFlashLoan(uint256 _flashLoanFee) external onlyTimelock {\n        uint256 oldFlashLoanFee = flashLoanParams.flashLoanFee;\n        flashLoanParams.flashLoanFee = _flashLoanFee;\n\n        emit FlashLoanFeeChanged(oldFlashLoanFee, _flashLoanFee);\n    }\n\n    /// @inheritdoc IAdminContract\n    function setMinDebtForFlashLoan(uint256 _flashLoanMinDebt) external onlyTimelock {\n        uint256 oldFlashLoanMinDebt = flashLoanParams.flashLoanMinDebt;\n        flashLoanParams.flashLoanMinDebt = _flashLoanMinDebt;\n\n        emit FlashLoanMinDebtChanged(oldFlashLoanMinDebt, _flashLoanMinDebt);\n    }\n\n    /// @inheritdoc IAdminContract\n    function setMaxDebtForFlashLoan(uint256 _flashLoanMaxDebt) external onlyTimelock {\n        uint256 oldFlashLoanMaxDebt = flashLoanParams.flashLoanMaxDebt;\n        flashLoanParams.flashLoanMaxDebt = _flashLoanMaxDebt;\n\n        emit FlashLoanMaxDebtChanged(oldFlashLoanMaxDebt, _flashLoanMaxDebt);\n    }\n\n    /// @inheritdoc IAdminContract\n    function switchRouteToTRENStaking() external onlyTimelock {\n        if (routeToTRENStaking) {\n            routeToTRENStaking = false;\n        } else {\n            routeToTRENStaking = true;\n        }\n    }\n\n    // View functions\n    // ---------------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IAdminContract\n    function DECIMAL_PRECISION() external pure returns (uint256) {\n        return _DECIMAL_PRECISION;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getValidCollateral() external view override returns (address[] memory) {\n        return validCollateral;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getIsActive(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (bool)\n    {\n        return collateralParams[_collateral].active;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getIndex(address _collateral)\n        external\n        view\n        override\n        exists(_collateral)\n        returns (uint256)\n    {\n        return (collateralParams[_collateral].index);\n    }\n\n    /// @inheritdoc IAdminContract\n    function getIndices(address[] memory _colls) external view returns (uint256[] memory indices) {\n        uint256 len = _colls.length;\n        indices = new uint256[](len);\n\n        for (uint256 i; i < len;) {\n            _exists(_colls[i]);\n            indices[i] = collateralParams[_colls[i]].index;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IAdminContract\n    function getMcr(address _collateral) external view override returns (uint256) {\n        return collateralParams[_collateral].mcr;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getCcr(address _collateral) external view override returns (uint256) {\n        return collateralParams[_collateral].ccr;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getDebtTokenGasCompensation(address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return collateralParams[_collateral].debtTokenGasCompensation;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getMinNetDebt(address _collateral) external view override returns (uint256) {\n        return collateralParams[_collateral].minNetDebt;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getPercentDivisor(address _collateral) external view override returns (uint256) {\n        return collateralParams[_collateral].percentDivisor;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getBorrowingFee(address _collateral) external view override returns (uint256) {\n        return collateralParams[_collateral].borrowingFee;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getRedemptionFeeFloor(address _collateral) external view override returns (uint256) {\n        return collateralParams[_collateral].redemptionFeeFloor;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getRedemptionBlockTimestamp(address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return collateralParams[_collateral].redemptionBlockTimestamp;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getMintCap(address _collateral) external view override returns (uint256) {\n        return collateralParams[_collateral].mintCap;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getTotalAssetDebt(address _asset) external view override returns (uint256) {\n        return ITrenBoxStorage(trenBoxStorage).getTotalDebtBalance(_asset);\n    }\n\n    /// @inheritdoc IAdminContract\n    function getFlashLoanFee() external view override returns (uint256) {\n        return flashLoanParams.flashLoanFee;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getFlashLoanMinNetDebt() external view override returns (uint256) {\n        return flashLoanParams.flashLoanMinDebt;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getFlashLoanMaxNetDebt() external view override returns (uint256) {\n        return flashLoanParams.flashLoanMaxDebt;\n    }\n\n    /// @inheritdoc IAdminContract\n    function getRouteToTRENStaking() external view override returns (bool) {\n        return routeToTRENStaking;\n    }\n\n    // Internal Functions\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Checks if the specific collateral asset exists or not.\n     * @param _collateral The address of collateral asset.\n     */\n    function _exists(address _collateral) private view {\n        if (collateralParams[_collateral].mcr == 0) {\n            revert AdminContract__CollateralDoesNotExist();\n        }\n    }\n\n    function authorizeUpgrade(address newImplementation) external {\n        _authorizeUpgrade(newImplementation);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner { }\n}\n"
    },
    "contracts/BorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { UUPSUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuardUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport { TrenMath } from \"./Dependencies/TrenMath.sol\";\nimport { TrenBase } from \"./Dependencies/TrenBase.sol\";\nimport { SafetyTransfer } from \"./Dependencies/SafetyTransfer.sol\";\n\nimport { IPriceFeed } from \"./Interfaces/IPriceFeed.sol\";\nimport { ISortedTrenBoxes } from \"./Interfaces/ISortedTrenBoxes.sol\";\nimport { IAdminContract } from \"./Interfaces/IAdminContract.sol\";\nimport { ITrenBoxManager } from \"./Interfaces/ITrenBoxManager.sol\";\nimport { IBorrowerOperations } from \"./Interfaces/IBorrowerOperations.sol\";\nimport { IDebtToken } from \"./Interfaces/IDebtToken.sol\";\nimport { IFeeCollector } from \"./Interfaces/IFeeCollector.sol\";\nimport { ITrenBoxStorage } from \"./Interfaces/ITrenBoxStorage.sol\";\n\n/**\n * @title BorrowerOperations contract\n * @notice Contains the basic operations by which borrowers interact with their TrenBoxes:\n * TrenBox creation, collateral top-up / withdrawal, debt token issuance and repayment.\n */\ncontract BorrowerOperations is\n    TrenBase,\n    ReentrancyGuardUpgradeable,\n    UUPSUpgradeable,\n    IBorrowerOperations\n{\n    using SafeERC20 for IERC20;\n\n    /// @notice The contract name.\n    string public constant NAME = \"BorrowerOperations\";\n\n    // --- Initializer ---\n\n    /**\n     * @dev Runs all the setup logic only once.\n     * @param initialOwner The address of initial owner.\n     */\n    function initialize(address initialOwner) public initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n    }\n\n    // --- External/Public Functions ---\n\n    /// @inheritdoc IBorrowerOperations\n    function openTrenBox(\n        address _asset,\n        uint256 _assetAmount,\n        uint256 _debtTokenAmount,\n        address _upperHint,\n        address _lowerHint\n    )\n        external\n        override\n        nonReentrant\n    {\n        if (!IAdminContract(adminContract).getIsActive(_asset)) {\n            revert BorrowerOperations__NotActiveColl();\n        }\n\n        OpenTrenBox memory vars;\n        vars.asset = _asset;\n\n        vars.price = IPriceFeed(priceFeed).fetchPrice(vars.asset);\n        bool isRecoveryMode = _checkRecoveryMode(vars.asset, vars.price);\n\n        uint256 status = ITrenBoxManager(trenBoxManager).getTrenBoxStatus(vars.asset, msg.sender);\n        if (status == 1) {\n            revert BorrowerOperations__TrenBoxIsActive();\n        }\n\n        vars.netDebt = _debtTokenAmount;\n\n        if (!isRecoveryMode) {\n            vars.debtTokenFee = _triggerBorrowingFee(vars.asset, _debtTokenAmount);\n            vars.netDebt = vars.netDebt + vars.debtTokenFee;\n        }\n        _requireAtLeastMinNetDebt(vars.asset, vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested debt token amount + borrowing fee\n        // + gas comp.\n        uint256 gasCompensation =\n            IAdminContract(adminContract).getDebtTokenGasCompensation(vars.asset);\n        vars.compositeDebt = vars.netDebt + gasCompensation;\n        if (vars.compositeDebt == 0) {\n            revert BorrowerOperations__CompositeDebtZero();\n        }\n\n        vars.ICR = TrenMath._computeCR(_assetAmount, vars.compositeDebt, vars.price);\n        vars.NICR = TrenMath._computeNominalCR(_assetAmount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.asset, vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.asset, vars.ICR);\n            uint256 newTCR = _getNewTCRFromTrenBoxChange(\n                vars.asset, _assetAmount, true, vars.compositeDebt, true, vars.price\n            ); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(vars.asset, newTCR);\n        }\n\n        // Set the trenBox struct's properties\n        ITrenBoxManager(trenBoxManager).setTrenBoxStatus(vars.asset, msg.sender, 1);\n\n        uint256 collateralAmountAfterIncrease = ITrenBoxManager(trenBoxManager).increaseTrenBoxColl(\n            vars.asset, msg.sender, _assetAmount\n        );\n        uint256 debtAmount_ = ITrenBoxManager(trenBoxManager).increaseTrenBoxDebt(\n            vars.asset, msg.sender, vars.compositeDebt\n        );\n\n        ITrenBoxManager(trenBoxManager).updateTrenBoxRewardSnapshots(vars.asset, msg.sender);\n        vars.stake =\n            ITrenBoxManager(trenBoxManager).updateStakeAndTotalStakes(vars.asset, msg.sender);\n\n        ISortedTrenBoxes(sortedTrenBoxes).insert(\n            vars.asset, msg.sender, vars.NICR, _upperHint, _lowerHint\n        );\n        vars.arrayIndex =\n            ITrenBoxManager(trenBoxManager).addTrenBoxOwnerToArray(vars.asset, msg.sender);\n        emit TrenBoxCreated(vars.asset, msg.sender, vars.arrayIndex);\n\n        // Moves the collateral to the trenBox storage pool\n        _trenBoxStorageAddColl(vars.asset, _assetAmount);\n        // Mints the debtToken amount to the borrower\n        _withdrawDebtTokens(vars.asset, msg.sender, _debtTokenAmount, vars.netDebt);\n\n        // Move the debtToken gas compensation to the TrenBoxStorage\n        if (gasCompensation != 0) {\n            _withdrawDebtTokens(vars.asset, trenBoxStorage, gasCompensation, gasCompensation);\n        }\n\n        emit TrenBoxUpdated(\n            vars.asset,\n            msg.sender,\n            debtAmount_,\n            collateralAmountAfterIncrease,\n            vars.stake,\n            BorrowerOperation.openTrenBox\n        );\n        emit BorrowingFeePaid(vars.asset, msg.sender, vars.debtTokenFee);\n    }\n\n    /// @inheritdoc IBorrowerOperations\n    function addColl(\n        address _asset,\n        uint256 _assetSent,\n        address _upperHint,\n        address _lowerHint\n    )\n        external\n        override\n        nonReentrant\n    {\n        _adjustTrenBox(_asset, _assetSent, msg.sender, 0, 0, false, _upperHint, _lowerHint);\n    }\n\n    /// @inheritdoc IBorrowerOperations\n    function withdrawColl(\n        address _asset,\n        uint256 _collWithdrawal,\n        address _upperHint,\n        address _lowerHint\n    )\n        external\n        override\n        nonReentrant\n    {\n        _adjustTrenBox(_asset, 0, msg.sender, _collWithdrawal, 0, false, _upperHint, _lowerHint);\n    }\n\n    /// @inheritdoc IBorrowerOperations\n    function withdrawDebtTokens(\n        address _asset,\n        uint256 _debtTokenAmount,\n        address _upperHint,\n        address _lowerHint\n    )\n        external\n        override\n        nonReentrant\n    {\n        _adjustTrenBox(_asset, 0, msg.sender, 0, _debtTokenAmount, true, _upperHint, _lowerHint);\n    }\n\n    /// @inheritdoc IBorrowerOperations\n    function repayDebtTokens(\n        address _asset,\n        uint256 _debtTokenAmount,\n        address _upperHint,\n        address _lowerHint\n    )\n        external\n        override\n        nonReentrant\n    {\n        if (\n            _debtTokenAmount\n                == _getNetDebt(\n                    _asset, ITrenBoxManager(trenBoxManager).getTrenBoxDebt(_asset, msg.sender)\n                )\n        ) {\n            _closeTrenBox(_asset);\n        } else {\n            _adjustTrenBox(\n                _asset, 0, msg.sender, 0, _debtTokenAmount, false, _upperHint, _lowerHint\n            );\n        }\n    }\n\n    /// @inheritdoc IBorrowerOperations\n    function adjustTrenBox(\n        address _asset,\n        uint256 _assetSent,\n        uint256 _collWithdrawal,\n        uint256 _debtTokenChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    )\n        external\n        override\n        nonReentrant\n    {\n        _adjustTrenBox(\n            _asset,\n            _assetSent,\n            msg.sender,\n            _collWithdrawal,\n            _debtTokenChange,\n            _isDebtIncrease,\n            _upperHint,\n            _lowerHint\n        );\n    }\n\n    /// @inheritdoc IBorrowerOperations\n    function claimCollateral(address _asset) external override {\n        ITrenBoxStorage(trenBoxStorage).claimCollateral(_asset, msg.sender);\n    }\n\n    /// @inheritdoc IBorrowerOperations\n    function getCompositeDebt(\n        address _asset,\n        uint256 _debt\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _getCompositeDebt(_asset, _debt);\n    }\n\n    /**\n     * @dev Alongside a debt change, this function can perform either a collateral top-up or\n     * a collateral withdrawal.\n     * @param _asset The address of collateral asset.\n     * @param _assetSent The amount of collateral asset to send.\n     * @param _borrower The borrower address.\n     * @param _collWithdrawal The amount of collateral asset to withdraw.\n     * @param _debtTokenChange The amount of debt token to withdraw or repay.\n     * @param _isDebtIncrease The flag to indicate if current operation is withdrawal or repayment.\n     * @param _upperHint Id of previous node for the new insert position.\n     * @param _lowerHint Id of next node for the new insert position.\n     */\n    function _adjustTrenBox(\n        address _asset,\n        uint256 _assetSent,\n        address _borrower,\n        uint256 _collWithdrawal,\n        uint256 _debtTokenChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    )\n        internal\n    {\n        AdjustTrenBox memory vars;\n        vars.asset = _asset;\n        vars.price = IPriceFeed(priceFeed).fetchPrice(vars.asset);\n        bool isRecoveryMode = _checkRecoveryMode(vars.asset, vars.price);\n\n        if (_isDebtIncrease) {\n            if (_debtTokenChange == 0) {\n                revert BorrowerOperations__ZeroDebtChange();\n            }\n        }\n        _requireSingularCollChange(_collWithdrawal, _assetSent);\n        _requireNonZeroAdjustment(_collWithdrawal, _debtTokenChange, _assetSent);\n        _requireTrenBoxIsActive(vars.asset, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trenBox, or a pure asset\n        // transfer from the Stability Pool to a trenBox\n        assert(\n            msg.sender == _borrower\n                || (stabilityPool == msg.sender && _assetSent != 0 && _debtTokenChange == 0)\n        );\n\n        ITrenBoxManager(trenBoxManager).applyPendingRewards(vars.asset, _borrower);\n\n        // Get the collChange based on whether or not asset was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(_assetSent, _collWithdrawal);\n\n        vars.netDebtChange = _debtTokenChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger\n        // a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) {\n            vars.debtTokenFee = _triggerBorrowingFee(vars.asset, _debtTokenChange);\n            // The raw debt change includes the fee\n            vars.netDebtChange = vars.netDebtChange + vars.debtTokenFee;\n        }\n\n        vars.debt = ITrenBoxManager(trenBoxManager).getTrenBoxDebt(vars.asset, _borrower);\n        vars.coll = ITrenBoxManager(trenBoxManager).getTrenBoxColl(vars.asset, _borrower);\n\n        // Get the trenBox's old ICR before the adjustment, and what its new ICR will be after the\n        // adjustment\n        vars.oldICR = TrenMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTrenBoxChange(\n            vars.coll,\n            vars.debt,\n            vars.collChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease,\n            vars.price\n        );\n        if (_collWithdrawal > vars.coll) {\n            revert BorrowerOperations__InsufficientCollateral();\n        }\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            vars.asset, isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars\n        );\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller\n        // has enough debt tokens\n        if (!_isDebtIncrease && _debtTokenChange != 0) {\n            _requireSufficientDebtTokenBalance(_borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTrenBoxFromAdjustment(\n            vars.asset,\n            _borrower,\n            vars.collChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease\n        );\n        vars.stake =\n            ITrenBoxManager(trenBoxManager).updateStakeAndTotalStakes(vars.asset, _borrower);\n\n        // Re-insert trenBox in to the sorted list\n        uint256 newNICR = _getNewNominalICRFromTrenBoxChange(\n            vars.coll,\n            vars.debt,\n            vars.collChange,\n            vars.isCollIncrease,\n            vars.netDebtChange,\n            _isDebtIncrease\n        );\n        ISortedTrenBoxes(sortedTrenBoxes).reInsert(\n            vars.asset, _borrower, newNICR, _upperHint, _lowerHint\n        );\n\n        emit TrenBoxUpdated(\n            vars.asset,\n            _borrower,\n            vars.newDebt,\n            vars.newColl,\n            vars.stake,\n            BorrowerOperation.adjustTrenBox\n        );\n        emit BorrowingFeePaid(vars.asset, msg.sender, vars.debtTokenFee);\n\n        // Use the unmodified _debtTokenChange here, as we don't send the fee to the user\n        _moveTokensFromAdjustment(\n            vars.asset,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _debtTokenChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    /**\n     * @dev Allows borrowers to repay all debt, withdraw all their collateral,\n     * and close their trenBoxes.\n     * @param _asset The address of collateral asset.\n     */\n    function _closeTrenBox(address _asset) internal {\n        _requireTrenBoxIsActive(_asset, msg.sender);\n        uint256 price = IPriceFeed(priceFeed).fetchPrice(_asset);\n        _requireNotInRecoveryMode(_asset, price);\n\n        ITrenBoxManager(trenBoxManager).applyPendingRewards(_asset, msg.sender);\n\n        uint256 coll = ITrenBoxManager(trenBoxManager).getTrenBoxColl(_asset, msg.sender);\n        uint256 debt = ITrenBoxManager(trenBoxManager).getTrenBoxDebt(_asset, msg.sender);\n\n        uint256 gasCompensation = IAdminContract(adminContract).getDebtTokenGasCompensation(_asset);\n        uint256 refund = IFeeCollector(feeCollector).simulateRefund(msg.sender, _asset, 1 ether);\n        uint256 netDebt = debt - gasCompensation - refund;\n\n        _requireSufficientDebtTokenBalance(msg.sender, netDebt);\n\n        uint256 newTCR = _getNewTCRFromTrenBoxChange(_asset, coll, false, debt, false, price);\n        _requireNewTCRisAboveCCR(_asset, newTCR);\n\n        ITrenBoxManager(trenBoxManager).removeStake(_asset, msg.sender);\n        ITrenBoxManager(trenBoxManager).closeTrenBox(_asset, msg.sender);\n\n        emit TrenBoxUpdated(_asset, msg.sender, 0, 0, 0, BorrowerOperation.closeTrenBox);\n\n        // Burn the repaid debt tokens from the user's balance and the gas compensation from\n        // TrenBoxStorage\n        _repayDebtTokens(_asset, msg.sender, netDebt, refund);\n        if (gasCompensation != 0) {\n            _repayDebtTokens(_asset, trenBoxStorage, gasCompensation, 0);\n        }\n\n        // Signal to the fee collector that debt has been paid in full\n        IFeeCollector(feeCollector).closeDebt(msg.sender, _asset);\n\n        // Send the collateral back to the user\n        ITrenBoxStorage(trenBoxStorage).sendCollateral(_asset, msg.sender, coll);\n    }\n\n    /**\n     * @dev Charges borrowing fee on the loan amount.\n     * @param _asset The address of collateral asset.\n     * @param _debtTokenAmount The loan amount.\n     */\n    function _triggerBorrowingFee(\n        address _asset,\n        uint256 _debtTokenAmount\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 debtTokenFee =\n            ITrenBoxManager(trenBoxManager).getBorrowingFee(_asset, _debtTokenAmount);\n        IDebtToken(debtToken).mint(_asset, feeCollector, debtTokenFee);\n        IFeeCollector(feeCollector).increaseDebt(msg.sender, _asset, debtTokenFee);\n        return debtTokenFee;\n    }\n\n    /**\n     * @dev Gets collateral change with flag to indicate if it's a top-up or withdrawal.\n     * @param _collReceived The amount of top-up collateral.\n     * @param _requestedCollWithdrawal The amount of collateral withdrawal.\n     */\n    function _getCollChange(\n        uint256 _collReceived,\n        uint256 _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns (uint256 collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    /**\n     * @dev Updates trenBox's collateral and debt balances based on whether they increase\n     * or decrease.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The address of borrower.\n     * @param _collChange The amount of collateral change.\n     * @param _isCollIncrease The flag to indicate if it's a collateral top-up or withdrawal.\n     * @param _debtChange The amount of debt change.\n     * @param _isDebtIncrease The flag to indicate if it's a debt withdrawal or repayment.\n     */\n    function _updateTrenBoxFromAdjustment(\n        address _asset,\n        address _borrower,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint256, uint256)\n    {\n        uint256 newColl = (_isCollIncrease)\n            ? ITrenBoxManager(trenBoxManager).increaseTrenBoxColl(_asset, _borrower, _collChange)\n            : ITrenBoxManager(trenBoxManager).decreaseTrenBoxColl(_asset, _borrower, _collChange);\n        uint256 newDebt = (_isDebtIncrease)\n            ? ITrenBoxManager(trenBoxManager).increaseTrenBoxDebt(_asset, _borrower, _debtChange)\n            : ITrenBoxManager(trenBoxManager).decreaseTrenBoxDebt(_asset, _borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    /**\n     * @dev Triggers actual collateral asset or debt token transfer from a trenBox adjustment.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The address of borrower.\n     * @param _collChange The amount of collateral change.\n     * @param _isCollIncrease The flag to indicate if it's a collateral top-up or withdrawal.\n     * @param _debtTokenChange The amount of debt token change.\n     * @param _isDebtIncrease The flag to indicate if it's a debt withdrawal or repayment.\n     * @param _netDebtChange The amount of raw debt change including fee.\n     */\n    function _moveTokensFromAdjustment(\n        address _asset,\n        address _borrower,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtTokenChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawDebtTokens(_asset, _borrower, _debtTokenChange, _netDebtChange);\n        } else {\n            _repayDebtTokens(_asset, _borrower, _debtTokenChange, 0);\n        }\n        if (_isCollIncrease) {\n            _trenBoxStorageAddColl(_asset, _collChange);\n        } else {\n            ITrenBoxStorage(trenBoxStorage).sendCollateral(_asset, _borrower, _collChange);\n        }\n    }\n\n    /**\n     * @dev Sends specific collateral amount to TrenBoxStorage and increases its recorded\n     * asset balance.\n     * @param _asset The address of collateral asset.\n     * @param _amount The amount of collateral asset.\n     */\n    function _trenBoxStorageAddColl(address _asset, uint256 _amount) internal {\n        ITrenBoxStorage(trenBoxStorage).increaseActiveCollateral(_asset, _amount);\n        IERC20(_asset).safeTransferFrom(\n            msg.sender, trenBoxStorage, SafetyTransfer.decimalsCorrection(_asset, _amount)\n        );\n    }\n\n    /**\n     * @dev Issues the specific amount of debt tokens and increases the total active debt\n     * (_netDebtIncrease potentially includes a debtTokenFee).\n     * @param _asset The address of collateral asset.\n     * @param _account The address of trenBox owner.\n     * @param _debtTokenAmount The amount of total debt change.\n     * @param _netDebtIncrease The amount of net debt change.\n     */\n    function _withdrawDebtTokens(\n        address _asset,\n        address _account,\n        uint256 _debtTokenAmount,\n        uint256 _netDebtIncrease\n    )\n        internal\n    {\n        uint256 newTotalAssetDebt =\n            ITrenBoxStorage(trenBoxStorage).getTotalDebtBalance(_asset) + _netDebtIncrease;\n        if (newTotalAssetDebt > IAdminContract(adminContract).getMintCap(_asset)) {\n            revert BorrowerOperations__ExceedMintCap();\n        }\n        ITrenBoxStorage(trenBoxStorage).increaseActiveDebt(_asset, _netDebtIncrease);\n        IDebtToken(debtToken).mint(_asset, _account, _debtTokenAmount);\n    }\n\n    /**\n     * @dev Burns the specific amount of debt tokens and decreases the total active debt.\n     * @param _asset The address of collateral asset.\n     * @param _account The address of trenBox owner.\n     * @param _debtTokenAmount The amount of total debt change.\n     * @param _refund The refund amount of debt tokens.\n     */\n    function _repayDebtTokens(\n        address _asset,\n        address _account,\n        uint256 _debtTokenAmount,\n        uint256 _refund\n    )\n        internal\n    {\n        /// @dev the borrowing fee partial refund is accounted for when decreasing the debt, as it\n        /// was included when trenBox was opened\n        ITrenBoxStorage(trenBoxStorage).decreaseActiveDebt(_asset, _debtTokenAmount + _refund);\n        /// @dev the borrowing fee partial refund is not burned here, as it has already been burned\n        /// by the FeeCollector\n        IDebtToken(debtToken).burn(_account, _debtTokenAmount);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    /**\n     * @dev Requires singular collateral change.\n     * @param _collWithdrawal The amount of collateral withdrawal.\n     * @param _amountSent The amount of a top-up collateral.\n     */\n    function _requireSingularCollChange(\n        uint256 _collWithdrawal,\n        uint256 _amountSent\n    )\n        internal\n        pure\n    {\n        if (_collWithdrawal != 0 && _amountSent != 0) {\n            revert BorrowerOperations__NotSingularChange();\n        }\n    }\n\n    /**\n     * @dev Requires non-zero adjustment in either collateral or debt balance.\n     * @param _collWithdrawal The amount of collateral withdrawal.\n     * @param _debtTokenChange The amount of total debt change.\n     * @param _assetSent The amount of a top-up collateral.\n     */\n    function _requireNonZeroAdjustment(\n        uint256 _collWithdrawal,\n        uint256 _debtTokenChange,\n        uint256 _assetSent\n    )\n        internal\n        pure\n    {\n        if (_collWithdrawal == 0 && _debtTokenChange == 0 && _assetSent == 0) {\n            revert BorrowerOperations__ZeroAdjustment();\n        }\n    }\n\n    /**\n     * @dev Requires that a trenBox is active.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The address of borrower.\n     */\n    function _requireTrenBoxIsActive(address _asset, address _borrower) internal view {\n        uint256 status = ITrenBoxManager(trenBoxManager).getTrenBoxStatus(_asset, _borrower);\n        if (status != 1) {\n            revert BorrowerOperations__TrenBoxNotExistOrClosed();\n        }\n    }\n\n    /**\n     * @dev Requires that the current operation is not in Recovery Mode.\n     * @param _asset The address of collateral asset.\n     * @param _price The price of collateral asset.\n     */\n    function _requireNotInRecoveryMode(address _asset, uint256 _price) internal view {\n        if (_checkRecoveryMode(_asset, _price)) {\n            revert BorrowerOperations__OperationInRecoveryMode();\n        }\n    }\n\n    /**\n     * @dev Requires no collateral withdrawal in Recovery Mode.\n     * @param _collWithdrawal The amount of collateral withdrawal.\n     */\n    function _requireNoCollWithdrawal(uint256 _collWithdrawal) internal pure {\n        if (_collWithdrawal != 0) {\n            revert BorrowerOperations__CollWithdrawalInRecoveryMode();\n        }\n    }\n\n    /**\n     * @dev Requires valid adjustment in respective modes.\n     * @param _asset The address of collateral asset.\n     * @param _isRecoveryMode The flag to indicate if current mode is Recovery Mode or not.\n     * @param _collWithdrawal The amount of collateral withdrawal.\n     * @param _isDebtIncrease The flag to indicate if current operation is withdrawal or repayment.\n     * @param _vars The struct variable to store adjustment parameters.\n     */\n    function _requireValidAdjustmentInCurrentMode(\n        address _asset,\n        bool _isRecoveryMode,\n        uint256 _collWithdrawal,\n        bool _isDebtIncrease,\n        AdjustTrenBox memory _vars\n    )\n        internal\n        view\n    {\n        /*\n         * In Recovery Mode, only allow:\n         *\n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n        * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and\n        improves the ICR (and by extension improves the TCR).\n         *\n         * In Normal Mode, ensure:\n         *\n         * - The new ICR is above MCR\n         * - The adjustment won't pull the TCR below CCR\n         */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_asset, _vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(_asset, _vars.newICR);\n            _vars.newTCR = _getNewTCRFromTrenBoxChange(\n                _asset,\n                _vars.collChange,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease,\n                _vars.price\n            );\n            _requireNewTCRisAboveCCR(_asset, _vars.newTCR);\n        }\n    }\n\n    /**\n     * @dev Requires an individual collateral ratio is above minimum collateral ratio.\n     * @param _asset The address of collateral asset.\n     * @param _newICR The new individual collateral ratio.\n     */\n    function _requireICRisAboveMCR(address _asset, uint256 _newICR) internal view {\n        if (_newICR < IAdminContract(adminContract).getMcr(_asset)) {\n            revert BorrowerOperations__TrenBoxICRBelowMCR();\n        }\n    }\n\n    /**\n     * @dev Requires an individual collateral ratio is above critical collateral ratio.\n     * @param _asset The address of collateral asset.\n     * @param _newICR The new individual collateral ratio.\n     */\n    function _requireICRisAboveCCR(address _asset, uint256 _newICR) internal view {\n        if (_newICR < IAdminContract(adminContract).getCcr(_asset)) {\n            revert BorrowerOperations__TrenBoxICRBelowCCR();\n        }\n    }\n\n    /**\n     * @dev Requires new individual collateral ratio is above old ratio.\n     * @param _newICR The new individual collateral ratio.\n     * @param _oldICR The old individual collateral ratio.\n     */\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        if (_newICR < _oldICR) {\n            revert BorrowerOperations__TrenBoxNewICRBelowOldICR();\n        }\n    }\n\n    /**\n     * @dev Requires new total collateral ratio is above critical collateral ratio.\n     * @param _asset The address of collateral asset.\n     * @param _newTCR The new total collateral ratio.\n     */\n    function _requireNewTCRisAboveCCR(address _asset, uint256 _newTCR) internal view {\n        if (_newTCR < IAdminContract(adminContract).getCcr(_asset)) {\n            revert BorrowerOperations__TrenBoxNewTCRBelowCCR();\n        }\n    }\n\n    /**\n     * @dev Requires that the net debt change is above minimum debt amount.\n     * @param _asset The address of collateral asset.\n     * @param _netDebt The amount of net debt change.\n     */\n    function _requireAtLeastMinNetDebt(address _asset, uint256 _netDebt) internal view {\n        if (_netDebt < IAdminContract(adminContract).getMinNetDebt(_asset)) {\n            revert BorrowerOperations__TrenBoxNetDebtLessThanMin();\n        }\n    }\n\n    /**\n     * @dev Requires sufficient debt balance on repayment.\n     * @param _borrower The borrower address.\n     * @param _debtRepayment The repayment amount.\n     */\n    function _requireSufficientDebtTokenBalance(\n        address _borrower,\n        uint256 _debtRepayment\n    )\n        internal\n        view\n    {\n        if (IDebtToken(debtToken).balanceOf(_borrower) < _debtRepayment) {\n            revert BorrowerOperations__InsufficientDebtBalance();\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    /**\n     * @dev Computes the new nominal collateral ratio, considering the change in collateral\n     * and debt balances. Assumes 0 pending rewards.\n     * @param _coll The collateral balance.\n     * @param _debt The debt balance.\n     * @param _collChange The amount of collateral change.\n     * @param _isCollIncrease The flag to indicate whether the collateral balance increases or not.\n     * @param _debtChange The amount of debt change.\n     * @param _isDebtIncrease The flag to indicate if it's a debt withdrawal or repayment.\n     */\n    function _getNewNominalICRFromTrenBoxChange(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        (uint256 newColl, uint256 newDebt) = _getNewTrenBoxAmounts(\n            _coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease\n        );\n\n        uint256 newNICR = TrenMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    /**\n     * @dev Computes the new individual collateral ratio, considering the change in collateral and\n     * debt balances. Assumes 0 pending rewards.\n     * @param _coll The collateral balance.\n     * @param _debt The debt balance.\n     * @param _collChange The amount of collateral change.\n     * @param _isCollIncrease The flag to indicate whether the collateral balance increases or not.\n     * @param _debtChange The amount of debt change.\n     * @param _isDebtIncrease The flag to indicate if it's a debt withdrawal or repayment.\n     * @param _price The price of collateral asset.\n     */\n    function _getNewICRFromTrenBoxChange(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        uint256 _price\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        (uint256 newColl, uint256 newDebt) = _getNewTrenBoxAmounts(\n            _coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease\n        );\n\n        uint256 newICR = TrenMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    /**\n     * @dev Computes new collateral and debt balances based on their changes.\n     * @param _coll The collateral balance.\n     * @param _debt The debt balance.\n     * @param _collChange The amount of collateral change.\n     * @param _isCollIncrease The flag to indicate whether the collateral balance increases or not.\n     * @param _debtChange The amount of debt change.\n     * @param _isDebtIncrease The flag to indicate if it's a debt withdrawal or repayment.\n     */\n    function _getNewTrenBoxAmounts(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint256, uint256)\n    {\n        uint256 newColl = _coll;\n        uint256 newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll + _collChange : _coll - _collChange;\n        newDebt = _isDebtIncrease ? _debt + _debtChange : _debt - _debtChange;\n\n        return (newColl, newDebt);\n    }\n\n    /**\n     * @dev Computes new total collateral ratio based on collateral and debt changes.\n     * @param _asset The address of collateral asset.\n     * @param _collChange The amount of collateral change.\n     * @param _isCollIncrease The flag to indicate whether the collateral balance increases or not.\n     * @param _debtChange The amount of debt change.\n     * @param _isDebtIncrease The flag to indicate if it's a debt withdrawal or repayment.\n     * @param _price The price of collateral asset.\n     */\n    function _getNewTCRFromTrenBoxChange(\n        address _asset,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        uint256 _price\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalColl = getEntireSystemColl(_asset);\n        uint256 totalDebt = getEntireSystemDebt(_asset);\n\n        totalColl = _isCollIncrease ? totalColl + _collChange : totalColl - _collChange;\n        totalDebt = _isDebtIncrease ? totalDebt + _debtChange : totalDebt - _debtChange;\n\n        uint256 newTCR = TrenMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function authorizeUpgrade(address newImplementation) public {\n        _authorizeUpgrade(newImplementation);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner { }\n}\n"
    },
    "contracts/DebtToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\nimport { IDebtToken } from \"./Interfaces/IDebtToken.sol\";\n\n/**\n * @title DebtToken contract\n * @notice The stablecoin token contract which mints, burns and transfers TrenUSD tokens.\n */\ncontract DebtToken is IDebtToken, ERC20Permit, Ownable {\n    /// @notice The debt token name.\n    string public constant NAME = \"TREN Debt Token\";\n\n    /// @notice The debt token symbol.\n    string public constant SYMBOL = \"trenUSD\";\n\n    /// @notice The address of BorrowerOperations\n    address public borrowerOperationsAddress;\n\n    /// @notice The address of StabilityPool\n    address public stabilityPoolAddress;\n\n    /// @notice The address of TrenBoxManager\n    address public trenBoxManagerAddress;\n\n    /// @notice The mapping from collateral asset address to mintable status\n    mapping(address collateral => bool isStopped) public emergencyStopMintingCollateral;\n\n    /// @notice The mapping from contract address to its whitelisted status\n    mapping(address whitelistedContract => bool isWhitelisted) public whitelistedContracts;\n\n    // ======================= Modifiers ======================= //\n\n    modifier onlyWhitelistedContract() {\n        if (!whitelistedContracts[msg.sender]) {\n            revert DebtToken__NotWhitelistedContract(msg.sender);\n        }\n        _;\n    }\n\n    modifier shouldTransferToValidRecipent(address _recipient) {\n        if (_recipient == address(0)) {\n            revert DebtToken__CannotTransferTokensToZeroAddress();\n        } else if (_recipient == address(this)) {\n            revert DebtToken__CannotTransferTokensToTokenContract();\n        }\n        _;\n    }\n\n    modifier onlyBorrowerOperations() {\n        if (msg.sender != borrowerOperationsAddress) {\n            revert DebtToken__CallerIsNotBorrowerOperations(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyStabilityPool() {\n        if (msg.sender != stabilityPoolAddress) {\n            revert DebtToken__CallerIsNotStabilityPool(msg.sender);\n        }\n        _;\n    }\n\n    constructor(address initialOwner) ERC20(NAME, SYMBOL) ERC20Permit(NAME) Ownable(initialOwner) { }\n\n    /**\n     * @notice Stops minting debt tokens against specific collateral asset in emergency case.\n     * @param _asset The address of collateral asset.\n     * @param _status The indicator whether minting is possible or not.\n     */\n    function emergencyStopMinting(address _asset, bool _status) external onlyOwner {\n        emergencyStopMintingCollateral[_asset] = _status;\n\n        emit EmergencyStopMintingCollateral(_asset, _status);\n    }\n\n    /**\n     * @notice Sets addresses of BorrowerOperations, StabilityPool, and TrenBoxManager.\n     * @param _borrowerOperationsAddress The address of BorrowerOperations contract.\n     * @param _stabilityPoolAddress The address of StabilityPool contract.\n     * @param _trenBoxManagerAddress The  address of TrenBoxManager contract.\n     */\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _stabilityPoolAddress,\n        address _trenBoxManagerAddress\n    )\n        external\n        onlyOwner\n    {\n        if (\n            _borrowerOperationsAddress == address(0) || _stabilityPoolAddress == address(0)\n                || _trenBoxManagerAddress == address(0)\n        ) {\n            revert DebtToken__InvalidAddressToConnect();\n        }\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        stabilityPoolAddress = _stabilityPoolAddress;\n        trenBoxManagerAddress = _trenBoxManagerAddress;\n\n        emit ProtocolContractsAddressesSet(\n            _borrowerOperationsAddress, _stabilityPoolAddress, _trenBoxManagerAddress\n        );\n    }\n\n    /**\n     * @notice Adds a contract to whitelist, called by only owner.\n     * @param _address The address of contract to add.\n     */\n    function addWhitelist(address _address) external onlyOwner {\n        whitelistedContracts[_address] = true;\n\n        emit WhitelistChanged(_address, true);\n    }\n\n    /**\n     * @notice Removes a contract from whitelist, called by only owner.\n     * @param _address The address of contract to remove.\n     */\n    function removeWhitelist(address _address) external onlyOwner {\n        whitelistedContracts[_address] = false;\n\n        emit WhitelistChanged(_address, false);\n    }\n\n    /// @inheritdoc IDebtToken\n    function mintFromWhitelistedContract(uint256 _amount)\n        external\n        override\n        onlyWhitelistedContract\n    {\n        _mint(msg.sender, _amount);\n    }\n\n    /// @inheritdoc IDebtToken\n    function burnFromWhitelistedContract(uint256 _amount)\n        external\n        override\n        onlyWhitelistedContract\n    {\n        _burn(msg.sender, _amount);\n    }\n\n    /// @inheritdoc IDebtToken\n    function mint(\n        address _asset,\n        address _account,\n        uint256 _amount\n    )\n        external\n        override\n        onlyBorrowerOperations\n    {\n        if (emergencyStopMintingCollateral[_asset]) {\n            revert DebtToken__MintBlockedForCollateral(_asset);\n        }\n\n        _mint(_account, _amount);\n    }\n\n    /// @inheritdoc IDebtToken\n    function burn(address _account, uint256 _amount) external override {\n        if (\n            msg.sender != borrowerOperationsAddress && msg.sender != trenBoxManagerAddress\n                && msg.sender != stabilityPoolAddress\n        ) {\n            revert DebtToken__CannotBurnTokens();\n        }\n        _burn(_account, _amount);\n    }\n\n    /// @inheritdoc IDebtToken\n    function sendToPool(\n        address _sender,\n        address _poolAddress,\n        uint256 _amount\n    )\n        external\n        override\n        onlyStabilityPool\n    {\n        _transfer(_sender, _poolAddress, _amount);\n    }\n\n    /// @inheritdoc IDebtToken\n    function returnFromPool(\n        address _poolAddress,\n        address _receiver,\n        uint256 _amount\n    )\n        external\n        override\n    {\n        if (msg.sender != stabilityPoolAddress && msg.sender != trenBoxManagerAddress) {\n            revert DebtToken__CannotReturnFromPool();\n        }\n        _transfer(_poolAddress, _receiver, _amount);\n    }\n\n    /**\n     * @notice Transfers debt tokens from caller to another account.\n     * @param _recipient The address of account to receive debt tokens.\n     * @param _amount The amount to transfer debt tokens.\n     */\n    function transfer(\n        address _recipient,\n        uint256 _amount\n    )\n        public\n        override(IERC20, ERC20)\n        shouldTransferToValidRecipent(_recipient)\n        returns (bool)\n    {\n        return super.transfer(_recipient, _amount);\n    }\n\n    /**\n     * @notice Transfers debt tokens from specified sender to another account.\n     * @param _sender The address of account that sends debt tokens.\n     * @param _recipient The address of account to receive debt tokens.\n     * @param _amount The amount to transfer debt tokens.\n     */\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    )\n        public\n        override(IERC20, ERC20)\n        shouldTransferToValidRecipent(_recipient)\n        returns (bool)\n    {\n        return super.transferFrom(_sender, _recipient, _amount);\n    }\n}\n"
    },
    "contracts/Dependencies/ConfigurableAddresses.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { OwnableUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nabstract contract ConfigurableAddresses is OwnableUpgradeable {\n    address public adminContract;\n    address public borrowerOperations;\n    address public communityIssuance;\n    address public debtToken;\n    address public feeCollector;\n    address public flashLoanAddress;\n    address public trenStaking;\n    address public priceFeed;\n    address public sortedTrenBoxes;\n    address public stabilityPool;\n    address public timelockAddress;\n    address public treasuryAddress;\n    address public trenBoxManager;\n    address public trenBoxManagerOperations;\n    address public trenBoxStorage;\n\n    bool public isAddressSetupInitialized;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[33] private __gap; // Goerli uses 47; Arbitrum uses 33\n\n    error ConfigurableAddresses__SetupIsInitialized();\n    error ConfigurableAddresses__ZeroAddresses(uint256 position, address address_);\n    error ConfigurableAddresses__CommunityIssuanceZeroAddress();\n    error ConfigurableAddresses__TRENStakingZeroAddress();\n    error ConfigurableAddresses__LengthMismatch();\n\n    // Dependency setters\n    // -----------------------------------------------------------------------------------------------\n\n    function setAddresses(address[] calldata _addresses) external onlyOwner {\n        if (isAddressSetupInitialized) {\n            revert ConfigurableAddresses__SetupIsInitialized();\n        }\n        if (_addresses.length != 13) {\n            revert ConfigurableAddresses__LengthMismatch();\n        }\n\n        for (uint256 i = 0; i < 13;) {\n            if (_addresses[i] == address(0)) {\n                revert ConfigurableAddresses__ZeroAddresses(i, _addresses[i]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        adminContract = _addresses[0];\n        borrowerOperations = _addresses[1];\n        debtToken = _addresses[2];\n        feeCollector = _addresses[3];\n        flashLoanAddress = _addresses[4];\n        priceFeed = _addresses[5];\n        sortedTrenBoxes = _addresses[6];\n        stabilityPool = _addresses[7];\n        timelockAddress = _addresses[8];\n        treasuryAddress = _addresses[9];\n        trenBoxManager = _addresses[10];\n        trenBoxManagerOperations = _addresses[11];\n        trenBoxStorage = _addresses[12];\n\n        isAddressSetupInitialized = true;\n    }\n\n    function setCommunityIssuance(address _communityIssuance) public onlyOwner {\n        if (_communityIssuance == address(0)) {\n            revert ConfigurableAddresses__CommunityIssuanceZeroAddress();\n        }\n        communityIssuance = _communityIssuance;\n    }\n\n    function setTRENStaking(address _trenStaking) public onlyOwner {\n        if (_trenStaking == address(0)) {\n            revert ConfigurableAddresses__TRENStakingZeroAddress();\n        }\n        trenStaking = _trenStaking;\n    }\n}\n"
    },
    "contracts/Dependencies/SafetyTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { IERC20Decimals } from \"../Interfaces/IERC20Decimals.sol\";\n\nlibrary SafetyTransfer {\n    /// @dev Error emitted when the specific token is ETH or zero address.\n    error EthUnsupportedError();\n    /// @dev Error emitted when the amount for decimal correction is invalid.\n    error InvalidAmountError();\n\n    /**\n     * @dev Converts the amount in ether (1e18) to the specific token decimal.\n     * @param _token The token address to get the decimal of.\n     * @param _amount The amount for decimal correction.\n     */\n    function decimalsCorrection(address _token, uint256 _amount) internal view returns (uint256) {\n        if (_token == address(0)) {\n            revert EthUnsupportedError();\n        }\n        if (_amount == 0) {\n            return 0;\n        }\n        uint8 decimals = IERC20Decimals(_token).decimals();\n        if (decimals < 18) {\n            uint256 divisor = 10 ** (18 - decimals);\n            if (_amount % divisor != 0) {\n                revert InvalidAmountError();\n            }\n            return _amount / divisor;\n        } else if (decimals > 18) {\n            uint256 multiplier = 10 ** (decimals - 18);\n            return _amount * multiplier;\n        }\n        return _amount;\n    }\n}\n"
    },
    "contracts/Dependencies/TrenBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { OwnableUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport { ConfigurableAddresses } from \"./ConfigurableAddresses.sol\";\nimport { TrenMath } from \"./TrenMath.sol\";\nimport { TrenMath } from \"./TrenMath.sol\";\n\nimport { IAdminContract } from \"../Interfaces/IAdminContract.sol\";\nimport { ITrenBoxStorage } from \"../Interfaces/ITrenBoxStorage.sol\";\n\n/**\n * @title TrenBase\n * @notice Base contract for TrenBoxManager, BorrowerOperations and StabilityPool.\n * It contains global system constants and common functions.\n */\nabstract contract TrenBase is OwnableUpgradeable, ConfigurableAddresses {\n    /**\n     * @dev Struct for storing arrays of collateral assets and their amounts.\n     * @param tokens The address array of collateral assets.\n     * @param amounts The amount array of collateral assets.\n     */\n    struct Colls {\n        address[] tokens;\n        uint256[] amounts;\n    }\n\n    /// @dev Error emitted when the fee percentage exceeds max value.\n    error TrenBase__FeeExceededMax(uint256 feePercentage, uint256 maxFeePercentage);\n\n    /**\n     * @notice Returns the entire collateral amount of a specific asset.\n     * @param _asset The address of collateral asset.\n     */\n    function getEntireSystemColl(address _asset) public view returns (uint256 entireSystemColl) {\n        return ITrenBoxStorage(trenBoxStorage).getTotalCollateralBalance(_asset);\n    }\n\n    /**\n     * @notice Returns the entire debt amount of a specific asset.\n     * @param _asset The address of collateral asset.\n     */\n    function getEntireSystemDebt(address _asset) public view returns (uint256 entireSystemDebt) {\n        return ITrenBoxStorage(trenBoxStorage).getTotalDebtBalance(_asset);\n    }\n\n    // --- Gas compensation functions ---\n\n    /**\n     * @dev Returns the composite debt (drawn debt + gas compensation) of a TrenBox, for\n     * the purpose of ICR calculation.\n     * @param _asset The address of collateral asset.\n     * @param _debt The amount of debt tokens to draw.\n     */\n    function _getCompositeDebt(address _asset, uint256 _debt) internal view returns (uint256) {\n        return _debt + IAdminContract(adminContract).getDebtTokenGasCompensation(_asset);\n    }\n\n    /**\n     * @dev Returns the net debt excluded gas compensation.\n     * @param _asset The address of collateral asset.\n     * @param _debt The total debt issued.\n     */\n    function _getNetDebt(address _asset, uint256 _debt) internal view returns (uint256) {\n        return _debt - IAdminContract(adminContract).getDebtTokenGasCompensation(_asset);\n    }\n\n    /**\n     * @dev Returns the amount of collateral to be drawn from a TrenBox's collateral and sent as\n     * gas compensation.\n     * @param _asset The address of collateral asset.\n     * @param _entireColl The entire collateral amount.\n     */\n    function _getCollGasCompensation(\n        address _asset,\n        uint256 _entireColl\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return _entireColl / IAdminContract(adminContract).getPercentDivisor(_asset);\n    }\n\n    /**\n     * @dev Returns the total collateral ratio for a specific asset.\n     * @param _asset The address of collateral asset.\n     * @param _price The price collateral asset.\n     */\n    function _getTCR(address _asset, uint256 _price) internal view returns (uint256 TCR) {\n        uint256 entireSystemColl = getEntireSystemColl(_asset);\n        uint256 entireSystemDebt = getEntireSystemDebt(_asset);\n        TCR = TrenMath._computeCR(entireSystemColl, entireSystemDebt, _price);\n    }\n\n    /**\n     * @dev Checks if the current mode is Recovery Mode.\n     * @param _asset The address of collateral asset.\n     * @param _price The price collateral asset.\n     */\n    function _checkRecoveryMode(address _asset, uint256 _price) internal view returns (bool) {\n        uint256 TCR = _getTCR(_asset, _price);\n        return TCR < IAdminContract(adminContract).getCcr(_asset);\n    }\n\n    /**\n     * @dev Requires that the redemption fee percentage is less than max percentage.\n     * @param _fee The redemption fee amount.\n     * @param _amount The collateral amount to draw.\n     * @param _maxFeePercentage The max fee percentage.\n     */\n    function _requireUserAcceptsFee(\n        uint256 _fee,\n        uint256 _amount,\n        uint256 _maxFeePercentage\n    )\n        internal\n        view\n    {\n        uint256 feePercentage = (_fee * IAdminContract(adminContract).DECIMAL_PRECISION()) / _amount;\n        if (feePercentage > _maxFeePercentage) {\n            revert TrenBase__FeeExceededMax(feePercentage, _maxFeePercentage);\n        }\n    }\n}\n"
    },
    "contracts/Dependencies/TrenMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nuint256 constant DECIMAL_PRECISION = 1 ether;\n\nlibrary TrenMath {\n    uint256 internal constant EXPONENT_CAP = 525_600_000;\n\n    /**\n     * @dev The precision for Nominal ICR (independent of price).\n     * Rationale for the value:\n     *\n     * - Making it “too high” could lead to overflows.\n     * - Making it “too low” could lead to an ICR equal to zero, due to truncation from Solidity\n     * floor division.\n     *\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39\n     * ETH, and will only truncate to 0 if the denominator is at least 1e20 times greater than\n     * the numerator.\n     */\n    uint256 internal constant NICR_PRECISION = 1e20;\n\n    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a < _b) ? _a : _b;\n    }\n\n    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a >= _b) ? _a : _b;\n    }\n\n    /**\n     * @dev Multiply two decimal numbers and use normal rounding rules:\n     * -round product up if 19'th mantissa digit >= 5\n     * -round product down if 19'th mantissa digit < 5\n     *\n     * Used only inside the exponentiation, _decPow().\n     */\n    function decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {\n        uint256 prod_xy = x * y;\n\n        decProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;\n    }\n\n    /**\n     * @dev Exponentiation function for 18-digit decimal base, and integer exponent n.\n     *\n     * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\n     *\n     * Called by two functions that represent time in units of minutes:\n     * 1) TrenBoxManager._calcDecayedBaseRate\n     * 2) CommunityIssuance._getCumulativeIssuanceFraction\n     *\n     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n     * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n     *\n     * If a period of > 1000 years is ever used as an exponent in either of the above functions,\n     * the result will be negligibly different from just passing the cap, since:\n     *\n     * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n     * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years,\n     * will be negligible.\n     */\n    function _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint256) {\n        if (_minutes > EXPONENT_CAP) {\n            _minutes = EXPONENT_CAP;\n        } // cap to avoid overflow\n\n        if (_minutes == 0) {\n            return DECIMAL_PRECISION;\n        }\n\n        uint256 y = DECIMAL_PRECISION;\n        uint256 x = _base;\n        uint256 n = _minutes;\n\n        // Exponentiation-by-squaring\n        while (n > 1) {\n            if (n % 2 == 0) {\n                x = decMul(x, x);\n                n = n / 2;\n            } else {\n                // if (n % 2 != 0)\n                y = decMul(x, y);\n                x = decMul(x, x);\n                n = (n - 1) / 2;\n            }\n        }\n\n        return decMul(x, y);\n    }\n\n    function _getAbsoluteDifference(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a >= _b) ? _a - _b : _b - _a;\n    }\n\n    function _computeNominalCR(uint256 _coll, uint256 _debt) internal pure returns (uint256) {\n        if (_debt != 0) {\n            return (_coll * NICR_PRECISION) / _debt;\n        }\n        // Return the maximal value for uint256 if the TrenBox has a debt of 0. Represents\n        // \"infinite\"\n        // CR.\n        else {\n            // if (_debt == 0)\n            return type(uint256).max;\n        }\n    }\n\n    function _computeCR(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _price\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_debt != 0) {\n            uint256 newCollRatio = (_coll * _price) / _debt;\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the TrenBox has a debt of 0. Represents\n        // \"infinite\"\n        // CR.\n        else {\n            // if (_debt == 0)\n            return type(uint256).max;\n        }\n    }\n}\n"
    },
    "contracts/FeeCollector.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { OwnableUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { UUPSUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport { ConfigurableAddresses } from \"./Dependencies/ConfigurableAddresses.sol\";\n\nimport { IDebtToken } from \"./Interfaces/IDebtToken.sol\";\nimport { IFeeCollector } from \"./Interfaces/IFeeCollector.sol\";\nimport { ITRENStaking } from \"./Interfaces/ITRENStaking.sol\";\nimport { IAdminContract } from \"./Interfaces/IAdminContract.sol\";\n\n/**\n * @title FeeCollector contract\n * @notice Handles the borrowing fee; controls the decaying refund and maintains\n * its record that includes the refund balance.\n */\ncontract FeeCollector is\n    IFeeCollector,\n    UUPSUpgradeable,\n    OwnableUpgradeable,\n    ConfigurableAddresses\n{\n    using SafeERC20 for IERC20;\n\n    /// @notice The contract name.\n    string public constant NAME = \"FeeCollector\";\n\n    /// @notice The duration which the minimum fee is applied.\n    uint256 public constant MIN_FEE_DAYS = 7;\n\n    /// @notice The minimum fee fraction, divided by 26 (1/26).\n    uint256 public constant MIN_FEE_FRACTION = 0.038461538 * 1 ether;\n\n    /// @notice The duration which the fee refund is expired.\n    /// ~ 6 months minus one week (MIN_FEE_DAYS)\n    uint256 public constant FEE_EXPIRATION_SECONDS = 175 * 1 days;\n\n    /// @notice The mapping from borrower address to the nested mapping from\n    /// collateral asset address to fee record struct\n    mapping(address borrower => mapping(address asset => FeeRecord feeParams)) public feeRecords;\n\n    // Modifiers\n    // --------------------------------------------------------------------------------------------------------\n\n    modifier onlyBorrowerOperations() {\n        if (msg.sender != borrowerOperations) {\n            revert FeeCollector__BorrowerOperationsOnly(msg.sender, borrowerOperations);\n        }\n        _;\n    }\n\n    modifier onlyTrenBoxManager() {\n        if (msg.sender != trenBoxManager) {\n            revert FeeCollector__TrenBoxManagerOnly(msg.sender, trenBoxManager);\n        }\n        _;\n    }\n\n    modifier onlyBorrowerOperationsOrTrenBoxManager() {\n        if (msg.sender != borrowerOperations && msg.sender != trenBoxManager) {\n            revert FeeCollector__BorrowerOperationsOrTrenBoxManagerOnly(\n                msg.sender, borrowerOperations, trenBoxManager\n            );\n        }\n        _;\n    }\n\n    // Initializer\n    // ------------------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Runs all the setup logic only once.\n     * @param initialOwner The address of initial owner.\n     */\n    function initialize(address initialOwner) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n    }\n\n    // ================= Public/External functions ================ //\n\n    /// @inheritdoc IFeeCollector\n    function increaseDebt(\n        address _borrower,\n        address _asset,\n        uint256 _feeAmount\n    )\n        external\n        override\n        onlyBorrowerOperations\n    {\n        uint256 minFeeAmount = (MIN_FEE_FRACTION * _feeAmount) / 1 ether;\n        uint256 refundableFeeAmount = _feeAmount - minFeeAmount;\n        uint256 feeToCollect = _createOrUpdateFeeRecord(_borrower, _asset, refundableFeeAmount);\n        _collectFee(_borrower, _asset, minFeeAmount + feeToCollect);\n    }\n\n    /// @inheritdoc IFeeCollector\n    function decreaseDebt(\n        address _borrower,\n        address _asset,\n        uint256 _paybackFraction\n    )\n        external\n        override\n        onlyBorrowerOperationsOrTrenBoxManager\n    {\n        _decreaseDebt(_borrower, _asset, _paybackFraction);\n    }\n\n    /// @inheritdoc IFeeCollector\n    function closeDebt(\n        address _borrower,\n        address _asset\n    )\n        external\n        override\n        onlyBorrowerOperationsOrTrenBoxManager\n    {\n        _decreaseDebt(_borrower, _asset, 1 ether);\n    }\n\n    /// @inheritdoc IFeeCollector\n    function simulateRefund(\n        address _borrower,\n        address _asset,\n        uint256 _paybackFraction\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (_paybackFraction > 1 ether) {\n            revert FeeCollector__PaybackFractionHigherThanOne();\n        }\n        if (_paybackFraction == 0) {\n            revert FeeCollector__ZeroPaybackFraction();\n        }\n\n        FeeRecord storage record = feeRecords[_borrower][_asset];\n        if (record.amount == 0 || record.to < block.timestamp) {\n            return 0;\n        }\n        uint256 expiredAmount = _calcExpiredAmount(record.from, record.to, record.amount);\n        if (_paybackFraction == 1e18) {\n            // full payback\n            return record.amount - expiredAmount;\n        } else {\n            // calc refund amount proportional to the payment\n            return ((record.amount - expiredAmount) * _paybackFraction) / 1 ether;\n        }\n    }\n\n    /// @inheritdoc IFeeCollector\n    function liquidateDebt(\n        address _borrower,\n        address _asset\n    )\n        external\n        override\n        onlyTrenBoxManager\n    {\n        FeeRecord memory mRecord = feeRecords[_borrower][_asset];\n        if (mRecord.amount != 0) {\n            _closeExpiredOrLiquidatedFeeRecord(_borrower, _asset, mRecord.amount);\n        }\n    }\n\n    /// @inheritdoc IFeeCollector\n    function collectFees(\n        address[] calldata _borrowers,\n        address[] calldata _assets\n    )\n        external\n        override\n    {\n        uint256 borrowersLength = _borrowers.length;\n        if (borrowersLength != _assets.length || borrowersLength == 0) {\n            revert FeeCollector__ArrayMismatch();\n        }\n        uint256 NOW = block.timestamp;\n        for (uint256 i = 0; i < borrowersLength;) {\n            address borrower = _borrowers[i];\n            address asset = _assets[i];\n            FeeRecord storage sRecord = feeRecords[borrower][asset];\n            uint256 expiredAmount = _calcExpiredAmount(sRecord.from, sRecord.to, sRecord.amount);\n            if (expiredAmount > 0) {\n                uint256 updatedAmount = sRecord.amount - expiredAmount;\n                sRecord.amount = updatedAmount;\n                sRecord.from = NOW;\n                _collectFee(borrower, asset, expiredAmount);\n                emit FeeRecordUpdated(borrower, asset, NOW, sRecord.to, updatedAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IFeeCollector\n    function handleRedemptionFee(address _asset, uint256 _amount) external onlyTrenBoxManager {\n        if (IAdminContract(adminContract).getRouteToTRENStaking()) {\n            ITRENStaking(trenStaking).increaseFeeAsset(_asset, _amount);\n        }\n        emit RedemptionFeeCollected(_asset, _amount);\n    }\n\n    function authorizeUpgrade(address newImplementation) public {\n        _authorizeUpgrade(newImplementation);\n    }\n\n    // ================== View functions ================ //\n\n    /// @inheritdoc IFeeCollector\n    function getProtocolRevenueDestination() public view override returns (address) {\n        return IAdminContract(adminContract).getRouteToTRENStaking() ? trenStaking : treasuryAddress;\n    }\n\n    // ================= Internal functions ================ //\n\n    /**\n     * @dev Decreases debt when a TrenBox is adjusted or closed, and the borrower\n     * has paid back or decreased his loan.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     * @param _paybackFraction The amount that the borrower pays back.\n     */\n    function _decreaseDebt(address _borrower, address _asset, uint256 _paybackFraction) internal {\n        uint256 NOW = block.timestamp;\n\n        if (_paybackFraction > 1 ether) {\n            revert FeeCollector__PaybackFractionHigherThanOne();\n        }\n        if (_paybackFraction == 0) {\n            revert FeeCollector__ZeroPaybackFraction();\n        }\n\n        FeeRecord storage sRecord = feeRecords[_borrower][_asset];\n        if (sRecord.amount == 0) {\n            return;\n        }\n        if (sRecord.to <= NOW) {\n            _closeExpiredOrLiquidatedFeeRecord(_borrower, _asset, sRecord.amount);\n        } else {\n            // collect expired refund\n            uint256 expiredAmount = _calcExpiredAmount(sRecord.from, sRecord.to, sRecord.amount);\n            _collectFee(_borrower, _asset, expiredAmount);\n            if (_paybackFraction == 1e18) {\n                // on a full payback, there's no refund; refund amount is discounted from final\n                // payment\n                uint256 refundAmount = sRecord.amount - expiredAmount;\n                IDebtToken(debtToken).burnFromWhitelistedContract(refundAmount);\n                sRecord.amount = 0;\n                emit FeeRecordUpdated(_borrower, _asset, NOW, 0, 0);\n            } else {\n                // refund amount proportional to the payment\n                uint256 refundAmount =\n                    ((sRecord.amount - expiredAmount) * _paybackFraction) / 1 ether;\n                _refundFee(_borrower, _asset, refundAmount);\n                uint256 updatedAmount = sRecord.amount - expiredAmount - refundAmount;\n                sRecord.amount = updatedAmount;\n                sRecord.from = NOW;\n                emit FeeRecordUpdated(_borrower, _asset, NOW, sRecord.to, updatedAmount);\n            }\n        }\n    }\n\n    /**\n     * @dev Creates or updates fee record parameters for a specific collateral asset.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     * @param _feeAmount The fee amount to collect.\n     */\n    function _createOrUpdateFeeRecord(\n        address _borrower,\n        address _asset,\n        uint256 _feeAmount\n    )\n        internal\n        returns (uint256 feeToCollect)\n    {\n        FeeRecord storage sRecord = feeRecords[_borrower][_asset];\n        if (sRecord.amount == 0) {\n            _createFeeRecord(_borrower, _asset, _feeAmount, sRecord);\n        } else {\n            if (sRecord.to <= block.timestamp) {\n                feeToCollect = sRecord.amount;\n                _createFeeRecord(_borrower, _asset, _feeAmount, sRecord);\n            } else {\n                feeToCollect = _updateFeeRecord(_borrower, _asset, _feeAmount, sRecord);\n            }\n        }\n    }\n\n    /**\n     * @dev Creates new fee record for a specific collateral asset.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     * @param _feeAmount The fee amount to add.\n     * @param _sRecord The storage to store new fee record.\n     */\n    function _createFeeRecord(\n        address _borrower,\n        address _asset,\n        uint256 _feeAmount,\n        FeeRecord storage _sRecord\n    )\n        internal\n    {\n        uint256 from = block.timestamp + MIN_FEE_DAYS * 1 days;\n        uint256 to = from + FEE_EXPIRATION_SECONDS;\n        _sRecord.amount = _feeAmount;\n        _sRecord.from = from;\n        _sRecord.to = to;\n        emit FeeRecordUpdated(_borrower, _asset, from, to, _feeAmount);\n    }\n\n    /**\n     * @dev Updates the existing fee record for a specific collateral asset.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     * @param _addedAmount The fee amount to update.\n     * @param _sRecord The storage to store updated fee record.\n     */\n    function _updateFeeRecord(\n        address _borrower,\n        address _asset,\n        uint256 _addedAmount,\n        FeeRecord storage _sRecord\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 NOW = block.timestamp;\n        if (NOW < _sRecord.from) {\n            // loan is still in its first week (MIN_FEE_DAYS)\n            NOW = _sRecord.from;\n        }\n        uint256 expiredAmount = _calcExpiredAmount(_sRecord.from, _sRecord.to, _sRecord.amount);\n        uint256 remainingAmount = _sRecord.amount - expiredAmount;\n        uint256 remainingTime = _sRecord.to - NOW;\n        uint256 updatedAmount = remainingAmount + _addedAmount;\n        uint256 updatedTo = NOW + _calcNewDuration(remainingAmount, remainingTime, _addedAmount);\n        _sRecord.amount = updatedAmount;\n        _sRecord.from = NOW;\n        _sRecord.to = updatedTo;\n        emit FeeRecordUpdated(_borrower, _asset, NOW, updatedTo, updatedAmount);\n        return expiredAmount;\n    }\n\n    /**\n     * @dev Closes the expired or liquidated fee record for a specific collateral asset.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     * @param _amount The stored fee amount.\n     */\n    function _closeExpiredOrLiquidatedFeeRecord(\n        address _borrower,\n        address _asset,\n        uint256 _amount\n    )\n        internal\n    {\n        _collectFee(_borrower, _asset, _amount);\n        delete feeRecords[_borrower][_asset];\n        emit FeeRecordUpdated(_borrower, _asset, block.timestamp, 0, 0);\n    }\n\n    /**\n     * @dev Calculates the expired fee amount at the time.\n     * @param _from The timestamp when the fee record is created.\n     * @param _to The timestamp when the fee record expires.\n     * @param _amount The amount of fee record.\n     */\n    function _calcExpiredAmount(\n        uint256 _from,\n        uint256 _to,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 NOW = block.timestamp;\n        if (_from > NOW) {\n            return 0;\n        }\n        if (NOW >= _to) {\n            return _amount;\n        }\n        uint256 PRECISION = 1e9;\n        uint256 lifeTime = _to - _from;\n        uint256 elapsedTime = NOW - _from;\n        uint256 decayRate = (_amount * PRECISION) / lifeTime;\n        uint256 expiredAmount = (elapsedTime * decayRate) / PRECISION;\n        return expiredAmount;\n    }\n\n    /**\n     * @dev Calculates new duration when fee record is updated.\n     * @param _remainingAmount The amount of refundable fee.\n     * @param _remainingTimeToLive The remaining duration until the refundable fee is all expired.\n     * @param _addedAmount The added amount to fee record.\n     */\n    function _calcNewDuration(\n        uint256 _remainingAmount,\n        uint256 _remainingTimeToLive,\n        uint256 _addedAmount\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 prevWeight = _remainingAmount * _remainingTimeToLive;\n        uint256 nextWeight = _addedAmount * FEE_EXPIRATION_SECONDS;\n        uint256 newDuration = (prevWeight + nextWeight) / (_remainingAmount + _addedAmount);\n        return newDuration;\n    }\n\n    /**\n     * @dev Transfers collected (debt token) fees to either the treasury or the staking contract.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     * @param _feeAmount The fee amount to collect.\n     */\n    function _collectFee(address _borrower, address _asset, uint256 _feeAmount) internal {\n        if (_feeAmount != 0) {\n            address destination = getProtocolRevenueDestination();\n            IERC20(debtToken).safeTransfer(destination, _feeAmount);\n            if (IAdminContract(adminContract).getRouteToTRENStaking()) {\n                ITRENStaking(trenStaking).increaseFeeDebtToken(_feeAmount);\n            }\n            emit FeeCollected(_borrower, _asset, destination, _feeAmount);\n        }\n    }\n\n    /**\n     * @dev Refund the remaining fees to the borrower.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     * @param _refundAmount The fee amount to refund.\n     */\n    function _refundFee(address _borrower, address _asset, uint256 _refundAmount) internal {\n        if (_refundAmount != 0) {\n            IERC20(debtToken).safeTransfer(_borrower, _refundAmount);\n            emit FeeRefunded(_borrower, _asset, _refundAmount);\n        }\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner { }\n}\n"
    },
    "contracts/FlashLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { UUPSUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { OwnableUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { ConfigurableAddresses } from \"./Dependencies/ConfigurableAddresses.sol\";\n\nimport { IAdminContract } from \"./Interfaces/IAdminContract.sol\";\nimport { IBorrowerOperations } from \"./Interfaces/IBorrowerOperations.sol\";\nimport { IFeeCollector } from \"./Interfaces/IFeeCollector.sol\";\nimport { IFlashLoan } from \"./Interfaces/IFlashLoan.sol\";\nimport { IFlashLoanReceiver } from \"./Interfaces/IFlashLoanReceiver.sol\";\nimport { ITrenBoxManager } from \"./Interfaces/ITrenBoxManager.sol\";\nimport { IUniswapRouterV3 } from \"./Interfaces/IUniswapRouterV3.sol\";\nimport { IDebtToken } from \"./Interfaces/IDebtToken.sol\";\n\n/// @title FlashLoan\n/// @notice This contract provides functionality for executing flash loans.\ncontract FlashLoan is\n    IFlashLoan,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    ConfigurableAddresses,\n    UUPSUpgradeable\n{\n    /// @notice The name of contract.\n    string public constant NAME = \"FlashLoan\";\n\n    /// @notice The denominator to calculate fee percentage.\n    uint256 public constant FEE_DENOMINATOR = 1000;\n\n    /// @notice The address of Swap Router contract.\n    IUniswapRouterV3 public swapRouter;\n    /// @notice The address of Stable Coin contract.\n    address public stableCoin;\n\n    /// @notice The index that setup is initialized or not.\n    bool public isSetupInitialized;\n\n    // ------------------------------------------ Initializer -------------------------------------\n\n    /// @dev Sets an intiial owner for the contract.\n    /// @param initialOwner The address of initial owner.\n    function initialize(address initialOwner) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n    }\n\n    // ------------------------------------------ Set functions -----------------------------------\n\n    /**\n     * @notice Sets addresses for stableCoin and swapRouter contracts.\n     * @param _stableCoin The address of Stable Coin contract.\n     * @param _swapRouter The address of Swap Router contract.\n     */\n    function setInternalAddresses(address _stableCoin, address _swapRouter) external onlyOwner {\n        if (isSetupInitialized) revert FlashLoan__SetupIsInitialized();\n        if (_stableCoin == address(0) || _swapRouter == address(0)) {\n            revert FlashLoan__ZeroAddresses();\n        }\n        stableCoin = _stableCoin;\n        swapRouter = IUniswapRouterV3(_swapRouter);\n\n        isSetupInitialized = true;\n\n        emit AddressesSet(_stableCoin, _swapRouter);\n    }\n\n    // ------------------------------------------ External functions ------------------------------\n\n    /// @inheritdoc IFlashLoan\n    function flashLoan(uint256 _amount) external nonReentrant {\n        if (IAdminContract(adminContract).getFlashLoanMinNetDebt() > _amount) {\n            revert FlashLoan__AmountBeyondMin();\n        }\n        if (IAdminContract(adminContract).getFlashLoanMaxNetDebt() < _amount) {\n            revert FlashLoan__AmountBeyondMax();\n        }\n\n        mintTokens(_amount);\n        uint256 balanceBefore = IDebtToken(debtToken).balanceOf(address(this));\n        uint256 fee = calculateFee(_amount);\n\n        IDebtToken(debtToken).transfer(msg.sender, _amount);\n\n        IFlashLoanReceiver(msg.sender).executeOperation(_amount, fee, address(debtToken));\n\n        if (IDebtToken(debtToken).balanceOf(address(this)) < balanceBefore + fee) {\n            revert FlashLoan__LoanIsNotRepayable();\n        }\n\n        burnTokens(_amount);\n        sendFeeToCollector();\n\n        emit FlashLoanExecuted(msg.sender, _amount, fee);\n    }\n\n    /**\n     * @notice Executes a flash loan specifically to repay a debt on the provided asset.\n     * @param _asset The address of the asset for which the debt is to be repaid.\n     * @dev This function initiates a flash loan transaction to repay a debt on the specified asset.\n     */\n    function flashLoanForRepay(address _asset) external nonReentrant {\n        if (!IAdminContract(adminContract).getIsActive(_asset)) {\n            revert FlashLoan__CollateralIsNotActive();\n        }\n        uint256 debt = ITrenBoxManager(trenBoxManager).getTrenBoxDebt(_asset, msg.sender);\n        uint256 gasCompensation = IAdminContract(adminContract).getDebtTokenGasCompensation(_asset);\n        uint256 refund = IFeeCollector(feeCollector).simulateRefund(msg.sender, _asset, 1 ether);\n        uint256 netDebt = debt - gasCompensation - refund;\n\n        mintTokens(netDebt);\n\n        IDebtToken(debtToken).transfer(msg.sender, netDebt);\n\n        uint256 fee = calculateFee(netDebt);\n\n        IBorrowerOperations(borrowerOperations).repayDebtTokens(\n            _asset, netDebt, address(0), address(0)\n        );\n\n        uint256 collAmountIn = IERC20(_asset).balanceOf(address(this));\n        uint256 debtTokensToGet = netDebt + fee;\n\n        swapTokens(_asset, collAmountIn, debtTokensToGet);\n\n        if (IDebtToken(debtToken).balanceOf(address(this)) < debtTokensToGet) {\n            revert FlashLoan__LoanIsNotRepayable();\n        }\n\n        burnTokens(netDebt);\n\n        sendFeeToCollector();\n\n        emit FlashLoanExecuted(msg.sender, netDebt, fee);\n    }\n\n    /**\n     * @notice Gets the current flash loan rate.\n     * @return The flash loan fee rate.\n     */\n    function getFlashLoanRate() external view returns (uint256) {\n        return IAdminContract(adminContract).getFlashLoanFee();\n    }\n\n    function authorizeUpgrade(address newImplementation) public {\n        _authorizeUpgrade(newImplementation);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner { }\n\n    // ------------------------------------------ Private functions -------------------------------\n\n    /**\n     * @dev Calculates the fee for a given loan amount.\n     * @param _amount The amount of the loan.\n     * @return The calculated fee for the loan amount.\n     */\n    function calculateFee(uint256 _amount) private view returns (uint256) {\n        uint256 _feeRate = IAdminContract(adminContract).getFlashLoanFee();\n        return (_amount * _feeRate) / FEE_DENOMINATOR;\n    }\n\n    /// @dev Sends the collected fees to the fee collector.\n    function sendFeeToCollector() private {\n        address collector = IFeeCollector(feeCollector).getProtocolRevenueDestination();\n        uint256 feeAmount = IDebtToken(debtToken).balanceOf(address(this));\n        IDebtToken(debtToken).transfer(collector, feeAmount);\n    }\n\n    /// @dev Mints the specified amount of debt tokens.\n    /// @param _amount The amount of debt tokens to mint.\n    function mintTokens(uint256 _amount) private {\n        IDebtToken(debtToken).mintFromWhitelistedContract(_amount);\n    }\n\n    /// @dev Burns the specified amount of debt tokens.\n    /// @param _amount The amount of debt tokens to burn.\n    function burnTokens(uint256 _amount) private {\n        IDebtToken(debtToken).burnFromWhitelistedContract(_amount);\n    }\n\n    /**\n     * @dev Swaps as little as possible of one token for `amountOut` of another along the specified\n     * path (reversed).\n     * @param _tokenIn The address of input collateral.\n     * @param _collAmountIn The amount of collateral which will be swapped.\n     * @param _debtAmountOut The amount of trenUSD which will (should) be received.\n     */\n    function swapTokens(address _tokenIn, uint256 _collAmountIn, uint256 _debtAmountOut) private {\n        // Approve swapRouter to spend amountInMaximum\n        IERC20(_tokenIn).approve(address(swapRouter), _collAmountIn);\n\n        // The tokenIn/tokenOut field is the shared token between the two pools used in the multiple\n        // pool swap. In this case stable coin is the \"shared\" token.\n        // For an exactOutput swap, the first swap that occurs is the swap which returns the\n        // eventual desired token.\n        // In this case, our desired output token is debtToken so that swap happpens first, and is\n        // encoded in the path accordingly.\n        IUniswapRouterV3.ExactOutputParams memory params = IUniswapRouterV3.ExactOutputParams({\n            path: abi.encodePacked(address(debtToken), uint24(3000), stableCoin, uint24(3000), _tokenIn),\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountOut: _debtAmountOut,\n            amountInMaximum: _collAmountIn\n        });\n\n        // Executes the swap, returning the amountIn actually spent.\n        uint256 amountIn = swapRouter.exactOutput(params);\n\n        // If the swap did not require the full _collAmountIn to achieve the exact amountOut then we\n        // refund msg.sender and approve the router to spend 0.\n        if (amountIn < _collAmountIn) {\n            IERC20(_tokenIn).approve(address(swapRouter), 0);\n            IERC20(_tokenIn).transfer(msg.sender, _collAmountIn - amountIn);\n        }\n    }\n}\n"
    },
    "contracts/Interfaces/IAdminContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title IAdminContract\n * @notice Defines the basic interface for AdminContract.\n */\ninterface IAdminContract {\n    /**\n     * @dev Struct for storing parameters of a specific collateral asset.\n     * @param index The index to map to token address in collateral arrays.\n     * @param active The status of collateral asset.\n     * @param borrowingFee The one-time fee charged on the loan amount.\n     * @param ccr Critical collateral ratio to trigger recovery mode.\n     * @param mcr Minimum collateral ratio.\n     * @param debtTokenGasCompensation The amount of debt token to be locked\n     * on opening TrenBoxes as liquidation reserve.\n     * @param minNetDebt Minimum amount of debtToken a TrenBox must have.\n     * @param mintCap The total amount of debt token that can be minted.\n     * @param percentDivisor The liquidation fee.\n     * @param redemptionFeeFloor The floor of redemption fee.\n     * @param redemptionBlockTimestamp The timestamp which the redemption can be started from.\n     */\n    struct CollateralParams {\n        uint256 index;\n        bool active;\n        uint256 borrowingFee;\n        uint256 ccr;\n        uint256 mcr;\n        uint256 debtTokenGasCompensation;\n        uint256 minNetDebt;\n        uint256 mintCap;\n        uint256 percentDivisor;\n        uint256 redemptionFeeFloor;\n        uint256 redemptionBlockTimestamp;\n    }\n\n    /**\n     * @dev Struct for storing flash loan parameters.\n     * @param flashLoanFee The flash loan fee. (10 = 0,1%, 100 = 10%)\n     * @param flashLoanMinDebt The minimum amount of debt token to mint for flash loan.\n     * @param flashLoanMaxDebt The maximum amount of debt token to mint for flash loan.\n     */\n    struct FlashLoanParams {\n        uint256 flashLoanFee;\n        uint256 flashLoanMinDebt;\n        uint256 flashLoanMaxDebt;\n    }\n\n    /**\n     * @dev Error emitted when the input value is not between min and max values.\n     * @param _parameter The label of input parameter.\n     * @param _valueEntered The input value.\n     * @param _minValue The minimum value.\n     * @param _maxValue The maximum value.\n     */\n    error SafeCheckError(\n        string _parameter, uint256 _valueEntered, uint256 _minValue, uint256 _maxValue\n    );\n\n    /**\n     * @dev Error emitted when the caller is not owner.\n     */\n    error AdminContract__OnlyOwner();\n\n    /**\n     * @dev Error emitted when the caller is not timelock contract.\n     */\n    error AdminContract__OnlyTimelock();\n\n    /**\n     * @dev Error emitted when the collateral asset already exists.\n     */\n    error AdminContract__CollateralExists();\n\n    /**\n     * @dev Error emitted when the collateral asset does not exist.\n     */\n    error AdminContract__CollateralDoesNotExist();\n\n    /**\n     * @dev Error emitted when the collateral asset is not active.\n     */\n    error AdminContract__CollateralNotConfigured();\n\n    /**\n     * @dev Emitted when the collateral asset is added.\n     * @param _collateral The address of collateral asset.\n     */\n    event CollateralAdded(address _collateral);\n\n    /**\n     * @dev Emitted when the minimum collateral ratio is updated.\n     * @param _oldMCR The old minimum collateral ratio.\n     * @param _newMCR The new minimum collateral ratio.\n     */\n    event MCRChanged(uint256 _oldMCR, uint256 _newMCR);\n\n    /**\n     * @dev Emitted when the critical collateral ratio is updated.\n     * @param _oldCCR The old critical collateral ratio.\n     * @param _newCCR The new critical collateral ratio.\n     */\n    event CCRChanged(uint256 _oldCCR, uint256 _newCCR);\n\n    /**\n     * @dev Emitted when the minimum amount of debt token is updated.\n     * @param _oldMinNet The old minimum amount of debt token.\n     * @param _newMinNet The new minimum amount of debt token.\n     */\n    event MinNetDebtChanged(uint256 _oldMinNet, uint256 _newMinNet);\n\n    /**\n     * @dev Emitted when the liquidation fee is updated.\n     * @param _oldPercentDiv The old liquidation fee.\n     * @param _newPercentDiv The new liquidation fee.\n     */\n    event PercentDivisorChanged(uint256 _oldPercentDiv, uint256 _newPercentDiv);\n\n    /**\n     * @dev Emitted when the borrowing fee is updated.\n     * @param _oldBorrowingFee The old borrowing fee.\n     * @param _newBorrowingFee The new borrowing fee.\n     */\n    event BorrowingFeeChanged(uint256 _oldBorrowingFee, uint256 _newBorrowingFee);\n\n    /**\n     * @dev Emitted when the floor of redemption fee is updated.\n     * @param _oldRedemptionFeeFloor The old floor of redemption fee.\n     * @param _newRedemptionFeeFloor The new floor of redemption fee.\n     */\n    event RedemptionFeeFloorChanged(uint256 _oldRedemptionFeeFloor, uint256 _newRedemptionFeeFloor);\n\n    /**\n     * @dev Emitted when the mint cap is updated.\n     * @param _oldMintCap The old mint cap.\n     * @param _newMintCap The new mint cap.\n     */\n    event MintCapChanged(uint256 _oldMintCap, uint256 _newMintCap);\n\n    /**\n     * @dev Emitted when the redemption timestamp of specific collateral is updated.\n     * @param _collateral The address of collateral asset.\n     * @param _blockTimestamp The new redemption timestamp.\n     */\n    event RedemptionBlockTimestampChanged(address _collateral, uint256 _blockTimestamp);\n\n    /**\n     * @dev Emitted when the flash loan fee is updated.\n     * @param _oldFee The old flash loan fee.\n     * @param _newFee The new flash loan fee.\n     */\n    event FlashLoanFeeChanged(uint256 _oldFee, uint256 _newFee);\n\n    /**\n     * @dev Emitted when the minimum amount of debt token for flash loan is updated.\n     * @param _oldMinDebt The old minimum amount of debt token.\n     * @param _newMinDebt The new minimum amount of debt token.\n     */\n    event FlashLoanMinDebtChanged(uint256 _oldMinDebt, uint256 _newMinDebt);\n\n    /**\n     * @dev Emitted when the maximum amount of debt token for flash loan is updated.\n     * @param _oldMaxDebt The old minimum amount of debt token.\n     * @param _newMaxDebt The new minimum amount of debt token.\n     */\n    event FlashLoanMaxDebtChanged(uint256 _oldMaxDebt, uint256 _newMaxDebt);\n\n    /// @notice Returns decimal precision, 1 ether.\n    function DECIMAL_PRECISION() external pure returns (uint256);\n\n    /// @notice Returns the scaled number which means 100 percent, 1 ether.\n    function _100pct() external view returns (uint256);\n\n    /**\n     * @notice Adds new collateral asset.\n     * @param _collateral The address of collateral asset.\n     * @param _debtTokenGasCompensation The amount of debtToken to be locked on opening\n     * TrenBoxes as liquidation reserve.\n     */\n    function addNewCollateral(address _collateral, uint256 _debtTokenGasCompensation) external;\n\n    /**\n     * @notice Sets collateral parameters.\n     * @param _collateral The address of collateral asset.\n     * @param _borrowingFee The one-time fee charged on the loan amount.\n     * @param _ccr The critical collateral ratio to trigger recovery mode.\n     * @param _mcr The minimum collateral ratio to avoid liquidation under normal mode.\n     * @param _minNetDebt The minimum amount of debtToken a TrenBox must have.\n     * @param _mintCap The total amount of debt tokens to be allocated.\n     * @param _percentDivisor The liquidation fee.\n     * @param _redemptionFeeFloor The floor of redemption fee.\n     */\n    function setCollateralParameters(\n        address _collateral,\n        uint256 _borrowingFee,\n        uint256 _ccr,\n        uint256 _mcr,\n        uint256 _minNetDebt,\n        uint256 _mintCap,\n        uint256 _percentDivisor,\n        uint256 _redemptionFeeFloor\n    )\n        external;\n\n    /**\n     * @notice Set the status for the specific collateral asset.\n     * @param _collateral The address of collateral asset.\n     * @param _active The status of collateral; true or false.\n     */\n    function setIsActive(address _collateral, bool _active) external;\n    /**\n     * @notice Sets the minimum collateral ratio.\n     * @param _collateral The address of collateral asset.\n     * @param _newMCR The minimum collateral ratio to avoid liquidations under normal mode.\n     */\n    function setMCR(address _collateral, uint256 _newMCR) external;\n\n    /**\n     * @notice Sets the critical collateral ratio.\n     * @param _collateral The address of collateral asset.\n     * @param _newCCR The new critical collateral ratio. If the system's total collateral ratio\n     * (TCR) falls below the CCR, Recovery Mode is triggered.\n     */\n    function setCCR(address _collateral, uint256 _newCCR) external;\n\n    /**\n     * @notice Sets the minimum amount of debt token to mint when opening a TrenBox.\n     * @param _collateral The address of collateral asset.\n     * @param _minNetDebt The minimum amount of debt token a TrenBox must have.\n     */\n    function setMinNetDebt(address _collateral, uint256 _minNetDebt) external;\n\n    /**\n     * @notice Sets the liquidation fee.\n     * @param _collateral The address of collateral asset.\n     * @param _percentDivisor The new :(min 2, max 200).\n     */\n    function setPercentDivisor(address _collateral, uint256 _percentDivisor) external;\n\n    /**\n     * @notice Sets the borrowing fee.\n     * @param _collateral The address of collateral asset.\n     * @param _borrowingFee The one-time fee charged on the loan amount.\n     */\n    function setBorrowingFee(address _collateral, uint256 _borrowingFee) external;\n\n    /**\n     * @notice Sets the floor of redemption fee.\n     * @param _collateral The address of collateral asset.\n     * @param _redemptionFeeFloor The floor of redemption fee charged on the redeemed\n     * amount(scaled by 1e18); min 0.001(0.1%), max 0.1(10%).\n     */\n    function setRedemptionFeeFloor(address _collateral, uint256 _redemptionFeeFloor) external;\n\n    /**\n     * @notice Sets the total amount of debt tokens that can be allocated.\n     * @param _collateral The address of collateral asset.\n     * @param _mintCap The mint cap.\n     */\n    function setMintCap(address _collateral, uint256 _mintCap) external;\n\n    /**\n     * @notice Sets the redemption timestamp.\n     * @param _collateral The address of collateral asset.\n     * @param _blockTimestamp The timestamp which redemption can be started from.\n     */\n    function setRedemptionBlockTimestamp(address _collateral, uint256 _blockTimestamp) external;\n\n    /**\n     * @notice Sets the flash loan fee.\n     * @param _flashLoanFee The new flash loan fee.\n     */\n    function setFeeForFlashLoan(uint256 _flashLoanFee) external;\n\n    /**\n     * @notice Sets the minimum amount of debt token to mint for flash loan.\n     * @param _flashLoanMinDebt The new minimum amount of debt token.\n     */\n    function setMinDebtForFlashLoan(uint256 _flashLoanMinDebt) external;\n\n    /**\n     * @notice Sets the maximum amount of debt token to mint for flash loan.\n     * @param _flashLoanMaxDebt The new maximum amount of debt token.\n     */\n    function setMaxDebtForFlashLoan(uint256 _flashLoanMaxDebt) external;\n\n    /// @notice Changes the destination where the collected fees go.\n    function switchRouteToTRENStaking() external;\n\n    /**\n     * @notice Returns the index of a specific collateral which maps to\n     * asset address in collateral array.\n     * @param _collateral The address of collateral asset.\n     */\n    function getIndex(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the list of index matched with collateral arrays.\n     * @param _colls The arrays of collateral assets.\n     */\n    function getIndices(address[] memory _colls) external view returns (uint256[] memory);\n\n    /**\n     * @notice Returns if a specific collateral is active or not.\n     * @param _collateral The address of collateral asset.\n     */\n    function getIsActive(address _collateral) external view returns (bool);\n\n    /// @notice Returns list of all collateral types in collateral params.\n    function getValidCollateral() external view returns (address[] memory);\n\n    /**\n     * @notice Returns the minimum collateral ratio of a specific collateral asset.\n     * @param _collateral The address of collateral asset.\n     */\n    function getMcr(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the critical collateral ratio of a specific collateral asset.\n     * @param _collateral The address of collateral asset.\n     */\n    function getCcr(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of debt token to be locked on opening TrenBoxes\n     * as liquidation reserve.\n     * @param _collateral The address of collateral asset.\n     */\n    function getDebtTokenGasCompensation(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the minimum amount of debt token a TrenBox must have.\n     * @param _collateral The address of collateral asset.\n     */\n    function getMinNetDebt(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the liquidation fee; min 2, max 200.\n     * @param _collateral The address of collateral asset.\n     */\n    function getPercentDivisor(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the one-time fee charged on the loan amount.\n     * @param _collateral The address of collateral asset.\n     */\n    function getBorrowingFee(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the floor of redemption fee for the specific collateral.\n     * @param _collateral The address of collateral asset.\n     */\n    function getRedemptionFeeFloor(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the redemption timestamp for the specific collateral.\n     * @param _collateral The address of collateral asset.\n     */\n    function getRedemptionBlockTimestamp(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the total allocated amount of debt token for the specific collateral.\n     * @param _collateral The address of collateral asset.\n     */\n    function getMintCap(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the current total amount of debt token for the specific collateral.\n     * @param _asset The address of collateral asset.\n     */\n    function getTotalAssetDebt(address _asset) external view returns (uint256);\n\n    /// @notice Returns the flash loan fee.\n    function getFlashLoanFee() external view returns (uint256);\n\n    /// @notice Returns the minimum amount of debt token to mint for flash loan.\n    function getFlashLoanMinNetDebt() external view returns (uint256);\n\n    /// @notice Returns the maximum amount of debt token to mint for flash loan.\n    function getFlashLoanMaxNetDebt() external view returns (uint256);\n\n    /**\n     * @notice Returns if the collected fees go to stakers or treasury.\n     * if true, collected fees go to stakers; if false, to the treasury\n     */\n    function getRouteToTRENStaking() external view returns (bool);\n}\n"
    },
    "contracts/Interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title IBorrowerOperations\n * @notice Defines the basic interface for BorrowerOperations contract.\n */\ninterface IBorrowerOperations {\n    /**\n     * @dev Enum for storing the borrower operation type.\n     * @param openTrenBox The operation type to open a trenBox.\n     * @param closeTrenBox The operation type to close a trenBox.\n     * @param adjustTrenBox The operation type to adjust trenBoxes.\n     */\n    enum BorrowerOperation {\n        openTrenBox,\n        closeTrenBox,\n        adjustTrenBox\n    }\n\n    /**\n     * @dev Struct for storing collateral and debt changes for a specific asset.\n     * @param asset The address of collateral asset.\n     * @param isCollIncrease The flag to indicate whether the collateral balance increases or not.\n     * @param price The price of collateral asset.\n     * @param collChange The change of collateral balance.\n     * @param netDebtChange The change of net debt balance.\n     * @param debt The current debt balance of a specific collateral asset.\n     * @param coll The current collateral balance of a specific collateral asset.\n     * @param oldICR The old individual collateral ratio.\n     * @param newICR The new individual collateral ratio.\n     * @param debtTokenFee The fee amount of debt tokens for borrowing.\n     * @param newDebt The updated debt balance of a specific collateral asset.\n     * @param newColl The updated collateral balance of a specific collateral asset.\n     * @param stake The new stake based on updated collateral balance.\n     */\n    struct AdjustTrenBox {\n        address asset;\n        bool isCollIncrease;\n        uint256 price;\n        uint256 collChange;\n        uint256 netDebtChange;\n        uint256 debt;\n        uint256 coll;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 debtTokenFee;\n        uint256 newDebt;\n        uint256 newColl;\n        uint256 stake;\n    }\n\n    /**\n     * @dev Struct for storing its information on opening a trenBox.\n     * @param asset The address of collateral asset.\n     * @param price The price of collateral asset.\n     * @param debtTokenFee The fee amount of debt tokens for borrowing.\n     * @param newDebt The updated debt balance of a specific collateral asset.\n     * @param compositeDebt The composite debt balance including gas compensation.\n     * @param ICR The individual collateral ratio.\n     * @param NICR The nominal individual collateral ratio.\n     * @param stake The new stake on opening new trenBox.\n     * @param arrayIndex The index to map to borrower address from owners array.\n     */\n    struct OpenTrenBox {\n        address asset;\n        uint256 price;\n        uint256 debtTokenFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 NICR;\n        uint256 stake;\n        uint256 arrayIndex;\n    }\n\n    /**\n     * @dev Emitted when the borrowing fee is paid on opening or adjusting a trenBox.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The address of borrower.\n     * @param _feeAmount The amount paid as borrowing fee.\n     */\n    event BorrowingFeePaid(address indexed _asset, address indexed _borrower, uint256 _feeAmount);\n\n    /**\n     * @dev Emitted when a trenBox is created.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The address of borrower.\n     * @param _arrayIndex The index to map to borrower address from owners array.\n     */\n    event TrenBoxCreated(address indexed _asset, address indexed _borrower, uint256 _arrayIndex);\n\n    /**\n     * @dev Emitted when a trenBox is adjusted.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The address of borrower.\n     * @param _debt The new debt balance.\n     * @param _coll The new collateral balance.\n     * @param _stake The new stake balance.\n     * @param _operation The type of borrower's operation.\n     */\n    event TrenBoxUpdated(\n        address indexed _asset,\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _stake,\n        BorrowerOperation _operation\n    );\n\n    /// @dev Error emitted when the specific collateral asset is not active.\n    error BorrowerOperations__NotActiveColl();\n\n    /// @dev Error emitted when the specific borrower's trenBox is not active.\n    error BorrowerOperations__TrenBoxNotExistOrClosed();\n\n    /// @dev Error emitted when the specific borrower's trenBox is active.\n    error BorrowerOperations__TrenBoxIsActive();\n\n    /**\n     * @dev Error emitted when the net debt of a specific collateral asset\n     * is less than minimum debt amount.\n     */\n    error BorrowerOperations__TrenBoxNetDebtLessThanMin();\n\n    /// @dev Error emitted when the composite debt amount is zero.\n    error BorrowerOperations__CompositeDebtZero();\n\n    /**\n     * @dev Error emitted when new individual collateral ratio is below\n     * the critical collateral ratio.\n     */\n    error BorrowerOperations__TrenBoxICRBelowCCR();\n\n    /**\n     * @dev Error emitted when new individual collateral ratio is below\n     * the minimum collateral ratio.\n     */\n    error BorrowerOperations__TrenBoxICRBelowMCR();\n\n    /**\n     * @dev Error emitted when new individual collateral ratio is below\n     * the old ratio.\n     */\n    error BorrowerOperations__TrenBoxNewICRBelowOldICR();\n\n    /**\n     * @dev Error emitted when the total collateral ratio is below\n     * the critical collateral ratio.\n     */\n    error BorrowerOperations__TrenBoxNewTCRBelowCCR();\n\n    /// @dev Error emitted when the debt balance change is zero.\n    error BorrowerOperations__ZeroDebtChange();\n\n    /// @dev Error emitted when both collateral top-up and withdrawal changes are made.\n    error BorrowerOperations__NotSingularChange();\n\n    /**\n     * @dev Error emitted when neither debt change nor collateral top-up nor collateral\n     * withdrawal happened.\n     */\n    error BorrowerOperations__ZeroAdjustment();\n\n    /// @dev Error emitted when a borrowing operation is not allowed in Recovery Mode.\n    error BorrowerOperations__OperationInRecoveryMode();\n\n    /// @dev Error emitted when the collateral withdrawal is requested in Recovery Mode.\n    error BorrowerOperations__CollWithdrawalInRecoveryMode();\n\n    /// @dev Error emitted when the current debt balance is below repayment amount.\n    error BorrowerOperations__InsufficientDebtBalance();\n\n    /// @dev Error emitted when the withdrawal amount is above current collateral balance.\n    error BorrowerOperations__InsufficientCollateral();\n\n    /// @dev Error emitted when the total debt amount exceeds mint cap.\n    error BorrowerOperations__ExceedMintCap();\n\n    /**\n     * @notice Creates a trenBox for the specific collateral asset with requested debt amount.\n     * @dev In addition to the requested debt, extra debt is issued to pay the borrowing fee,\n     * and cover the gas compensation.\n     * @param _asset The address of collateral asset.\n     * @param _assetAmount The amount of collateral asset.\n     * @param _debtTokenAmount The amount of debt tokens.\n     * @param _upperHint Id of previous node for the insert position, used in SortedTrenBoxes.\n     * @param _lowerHint Id of next node for the insert position, used in SortedTrenBoxes.\n     */\n    function openTrenBox(\n        address _asset,\n        uint256 _assetAmount,\n        uint256 _debtTokenAmount,\n        address _upperHint,\n        address _lowerHint\n    )\n        external;\n\n    /**\n     * @notice Adds collateral to the caller's active trenBox.\n     * @param _asset The address of collateral asset.\n     * @param _assetSent The amount of collateral asset to add.\n     * @param _upperHint Id of previous node for the new insert position, used in SortedTrenBoxes.\n     * @param _lowerHint Id of next node for the new insert position, used in SortedTrenBoxes.\n     */\n    function addColl(\n        address _asset,\n        uint256 _assetSent,\n        address _upperHint,\n        address _lowerHint\n    )\n        external;\n\n    /**\n     * @notice Withdraws collateral from the caller's active trenBox.\n     * @param _asset The address of collateral asset.\n     * @param _collWithdrawal The amount of collateral asset to withdraw.\n     * @param _upperHint Id of previous node for the new insert position.\n     * @param _lowerHint Id of next node for the new insert position.\n     */\n    function withdrawColl(\n        address _asset,\n        uint256 _collWithdrawal,\n        address _upperHint,\n        address _lowerHint\n    )\n        external;\n\n    /**\n     * @notice Withdraws debt tokens from the caller's trenBox. Mints new debt tokens to the owner,\n     * and increase the trenBox's debt accordingly.\n     * @param _asset The address of collateral asset.\n     * @param _debtTokenAmount The amount of debt token to withdraw.\n     * @param _upperHint Id of previous node for the new insert position.\n     * @param _lowerHint Id of next node for the new insert position.\n     */\n    function withdrawDebtTokens(\n        address _asset,\n        uint256 _debtTokenAmount,\n        address _upperHint,\n        address _lowerHint\n    )\n        external;\n\n    /**\n     * @notice Repays debt tokens to the caller's trenBox. Burns the repaid debt tokens, and\n     * reduces the trenBox's debt accordingly or Closes trenBox if user has enough tokens at all.\n     * @param _asset The address of collateral asset.\n     * @param _debtTokenAmount The amount of debt token to repay.\n     * @param _upperHint Id of previous node for the new insert position.\n     * @param _lowerHint Id of next node for the new insert position.\n     */\n    function repayDebtTokens(\n        address _asset,\n        uint256 _debtTokenAmount,\n        address _upperHint,\n        address _lowerHint\n    )\n        external;\n\n    /**\n     * @notice Enables a caller to simultaneously change both their collateral and debt balances.\n     * @param _asset The address of collateral asset.\n     * @param _assetSent The amount of collateral asset to send.\n     * @param _collWithdrawal The amount of collateral asset to withdraw.\n     * @param _debtTokenChange The amount of debt token to withdraw or repay.\n     * @param _isDebtIncrease The flag to indicate if current operation is withdrawal or repayment.\n     * @param _upperHint Id of previous node for the new insert position.\n     * @param _lowerHint Id of next node for the new insert position.\n     */\n    function adjustTrenBox(\n        address _asset,\n        uint256 _assetSent,\n        uint256 _collWithdrawal,\n        uint256 _debtTokenChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    )\n        external;\n\n    /**\n     * @notice Claims remaining collateral from a redemption or from a liquidation\n     * with ICR > MCR in Recovery Mode.\n     * @param _asset The address of collateral asset.\n     */\n    function claimCollateral(address _asset) external;\n\n    /**\n     * @notice Returns the composite debt (drawn debt + gas compensation) of a trenBox.\n     */\n    function getCompositeDebt(address _asset, uint256 _debt) external view returns (uint256);\n}\n"
    },
    "contracts/Interfaces/ICommunityIssuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.23;\n\ninterface ICommunityIssuance {\n    // --- Errors ---\n\n    error CommunityIssuance__SetupAlreadyInitialized();\n    error CommunityIssuance__InvalidAddresses();\n    error CommunityIssuance__InvalidAdminContract();\n    error CommunityIssuance__InvalidPermission();\n    error CommunityIssuance__NotStabilityPool();\n    error CommunityIssuance__SPHaveInsufficientSupply();\n    error CommunityIssuance__SPNotAssigned();\n\n    // --- Events ---\n\n    event TotalTRENIssuedUpdated(uint256 _totalTRENIssued);\n\n    // --- Functions ---\n\n    function issueTREN() external returns (uint256);\n\n    function sendTREN(address _account, uint256 _TRENamount) external;\n\n    function addFundToStabilityPool(uint256 _assignedSupply) external;\n\n    function addFundToStabilityPoolFrom(uint256 _assignedSupply, address _spender) external;\n\n    function setWeeklyTrenDistribution(uint256 _weeklyReward) external;\n}\n"
    },
    "contracts/Interfaces/IDebtToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IDebtToken\n * @notice Defines the basic interface for DebtToken contract.\n */\ninterface IDebtToken is IERC20 {\n    /**\n     * @dev Emitted when minting debt tokens against specific collateral asset\n     * is stopped.\n     * @param _asset The address of the collateral asset.\n     * @param _state The indicator that shows if minting is stopped or not.\n     */\n    event EmergencyStopMintingCollateral(address indexed _asset, bool _state);\n\n    /**\n     * @dev Emitted when a contract is added to whitelist or removed from it.\n     * @param _address The address of contract to add or remove.\n     * @param _whitelisted The indicator that shows if contract is added or removed.\n     */\n    event WhitelistChanged(address indexed _address, bool _whitelisted);\n\n    /**\n     * @dev Emitted when BorrowerOperations, StabilityPool, and TrenBoxManager addresses\n     * are set.\n     * @param _borrowerOperations The address of BorrowerOperations.\n     * @param _stabilityPool The address of StabilityPool.\n     * @param _trenBoxManager The address of TrenBoxManager.\n     */\n    event ProtocolContractsAddressesSet(\n        address indexed _borrowerOperations,\n        address indexed _stabilityPool,\n        address indexed _trenBoxManager\n    );\n\n    /**\n     * @dev Error emitted when a specific collateral has been already blocked from minting.\n     * @param _collateral The address of the collateral asset.\n     */\n    error DebtToken__MintBlockedForCollateral(address _collateral);\n\n    /**\n     * @dev Error emitted when zero address is set.\n     */\n    error DebtToken__InvalidAddressToConnect();\n\n    /**\n     * @dev Error emitted when the recipient address is zero address.\n     */\n    error DebtToken__CannotTransferTokensToZeroAddress();\n\n    /**\n     * @dev Error emitted when the recipient address is token contract address itself.\n     */\n    error DebtToken__CannotTransferTokensToTokenContract();\n\n    /**\n     * @dev Error emitted when caller is not whitelisted contract.\n     * @param _notWhitelistedContract The address of not whitelisted contract.\n     */\n    error DebtToken__NotWhitelistedContract(address _notWhitelistedContract);\n\n    /**\n     * @dev Error emitted when caller is not BorrowerOperations.\n     * @param _caller The address of caller.\n     */\n    error DebtToken__CallerIsNotBorrowerOperations(address _caller);\n\n    /**\n     * @dev Error emitted when caller is not StabilityPool.\n     * @param _caller The address of caller.\n     */\n    error DebtToken__CallerIsNotStabilityPool(address _caller);\n\n    /**\n     * @dev Error emitted when caller is neither BorrowerOperations nor StabilityPool.\n     * nor TrenBoxManager\n     */\n    error DebtToken__CannotBurnTokens();\n\n    /**\n     * @dev Error emitted when caller is neither StabilityPool nor TrenBoxManager.\n     */\n    error DebtToken__CannotReturnFromPool();\n\n    /**\n     * @notice Allows the whitelisted contracts to mint debt tokens without any collateral.\n     * @param _amount The amount to mint debt token.\n     */\n    function mintFromWhitelistedContract(uint256 _amount) external;\n\n    /**\n     * @notice Allows the whitelisted contracts to burn their debt tokens.\n     * @param _amount The amount to burn debt token.\n     */\n    function burnFromWhitelistedContract(uint256 _amount) external;\n\n    /**\n     * @notice Allows BorrowerOperations to mint debt tokens to the specific account.\n     * @param _asset The address of collateral asset.\n     * @param _account The address of account to receive debt tokens.\n     * @param _amount The amount to mint debt token.\n     */\n    function mint(address _asset, address _account, uint256 _amount) external;\n\n    /**\n     * @notice Allows BorrowerOperations, TrenBoxManager & StabilityPool to\n     * burn debt tokens from the specific account\n     * @param _account The address of account to burn debt tokens\n     * @param _amount THe amount to burn debt tokens.\n     */\n    function burn(address _account, uint256 _amount) external;\n\n    /**\n     * @notice Transfers the debt tokens from a user to a pool contract.\n     * @param _sender The address of account that sends debt tokens.\n     * @param _poolAddress The address of pool to receive debt tokens.\n     * @param _amount The amount to transfer debt tokens.\n     */\n    function sendToPool(address _sender, address _poolAddress, uint256 _amount) external;\n\n    /**\n     * @notice Sends debt tokens to a user from a pool contract.\n     * @param _poolAddress The address of pool that sends debt tokens.\n     * @param _receiver The address of account to receive debt tokens.\n     * @param _amount The amount to send debt token.\n     */\n    function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external;\n}\n"
    },
    "contracts/Interfaces/IDeposit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IDeposit {\n    function receivedERC20(address _asset, uint256 _amount) external;\n}\n"
    },
    "contracts/Interfaces/IERC20Decimals.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.23;\n\ninterface IERC20Decimals {\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/Interfaces/IFeeCollector.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title IFeeCollector\n * @notice Defines the basic interface for the FeeCollector contract.\n */\ninterface IFeeCollector {\n    /**\n     * @dev Struct for storing fee records of specific collateral asset.\n     * @param from The timestamp in seconds when the decay of refundable fee started.\n     * @param to The timestamp in seconds when the decay of refundable fee expired.\n     * @param _amount The amount of refundable fee.\n     */\n    struct FeeRecord {\n        uint256 from;\n        uint256 to;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Emitted when the fee record is updated.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     * @param _from The timestamp in seconds when the decay of refundable fee started.\n     * @param _to The timestamp in seconds when the decay of refundable fee expired.\n     * @param _amount The amount of refundable fee\n     */\n    event FeeRecordUpdated(\n        address indexed _borrower,\n        address indexed _asset,\n        uint256 _from,\n        uint256 _to,\n        uint256 _amount\n    );\n\n    /**\n     * @dev Emitted when the collected fees are transferred to either the treasury\n     * or the TRENStaking contract.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     * @param _collector The address of destination.\n     * @param _amount The amount of collected fees (debt tokens).\n     */\n    event FeeCollected(\n        address indexed _borrower,\n        address indexed _asset,\n        address indexed _collector,\n        uint256 _amount\n    );\n\n    /**\n     * @dev Emitted when the fees are refunded to the borrower.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     * @param _amount The amount of refunded fees.\n     */\n    event FeeRefunded(address indexed _borrower, address indexed _asset, uint256 _amount);\n\n    /**\n     * @dev Emitted when the redemption fees are collected.\n     * @param _asset The address of collateral asset.\n     * @param _amount The amount of collected fees.\n     */\n    event RedemptionFeeCollected(address indexed _asset, uint256 _amount);\n\n    /**\n     * @dev Emitted when the lengths of array parameters are mismatched.\n     */\n    error FeeCollector__ArrayMismatch();\n\n    /**\n     * @dev Emitted when the caller is not BorrowerOperations.\n     * @param _sender The address of caller.\n     * @param _expected The address of BorrowerOperations.\n     */\n    error FeeCollector__BorrowerOperationsOnly(address _sender, address _expected);\n\n    /**\n     * @dev Emitted when the caller is neither BorrowerOperations nor TrenBoxManager.\n     * @param _sender The address of caller.\n     * @param _expected1 The address of BorrowerOperations.\n     * @param _expected2 The address of TrenBoxManager.\n     */\n    error FeeCollector__BorrowerOperationsOrTrenBoxManagerOnly(\n        address _sender, address _expected1, address _expected2\n    );\n\n    /**\n     * @dev Emitted when the caller is not TrenBoxManager.\n     * @param _sender The address of caller.\n     * @param _expected The address of TrenBoxManager.\n     */\n    error FeeCollector__TrenBoxManagerOnly(address _sender, address _expected);\n\n    /**\n     * @dev Emitted when the payback fraction is higher than 1 ether(10**18 wei).\n     */\n    error FeeCollector__PaybackFractionHigherThanOne();\n\n    /**\n     * @dev Emitted when the payback fraction is zero.\n     */\n    error FeeCollector__ZeroPaybackFraction();\n\n    /**\n     * @notice Increases debt of fee amount when a TrenBox is created and again\n     * whenever the borrower acquires additional loans.\n     * Collects the minimum fee to the platform, for which there is no refund; holds on to the\n     * remaining fees until debt is paid, liquidated, or expired.\n     * @dev Attention: this method assumes that (debt token) _feeAmount has already been minted and\n     * transferred to this contract.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     * @param _feeAmount The fee amount to collect.\n     */\n    function increaseDebt(address _borrower, address _asset, uint256 _feeAmount) external;\n\n    /**\n     * @notice Decreases debt when a TrenBox is adjusted.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     * @param _paybackFraction The amount that the borrower pays back.\n     */\n    function decreaseDebt(address _borrower, address _asset, uint256 _paybackFraction) external;\n\n    /**\n     * @notice Closes debt when it is paid in full.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     */\n    function closeDebt(address _borrower, address _asset) external;\n\n    /**\n     * @notice Triggered when a TrenBox is liquidated. In that case, all remaining fees are\n     * collected by the platform, and no refunds are generated.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     */\n    function liquidateDebt(address _borrower, address _asset) external;\n\n    /**\n     * @notice Simulates the refund due if a TrenBox would be closed at this moment\n     * @dev Helper function used by the UI.\n     * @param _borrower The address of borrower.\n     * @param _asset The address of collateral asset.\n     * @param _paybackFraction The amount that the borrower pays back.\n     */\n    function simulateRefund(\n        address _borrower,\n        address _asset,\n        uint256 _paybackFraction\n    )\n        external\n        returns (uint256);\n\n    /**\n     * @notice Batches collect fees from an array of borrowers and assets.\n     * @param _borrowers The address array of borrowers.\n     * @param _assets The address array of collateral assets.\n     */\n    function collectFees(address[] calldata _borrowers, address[] calldata _assets) external;\n\n    /**\n     * @notice Sends redemption fee to the protocol revenue destination.\n     * @param _asset The address of collateral asset.\n     * @param _amount The amount of redemption fee to send.\n     */\n    function handleRedemptionFee(address _asset, uint256 _amount) external;\n\n    /**\n     * @notice Gets the protocol revenue destination.\n     */\n    function getProtocolRevenueDestination() external view returns (address);\n}\n"
    },
    "contracts/Interfaces/IFlashLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title IFlashLoan\n * @dev Defines the basic interface for FlashLoan contract.\n */\ninterface IFlashLoan {\n    // ------------------------------------------ Custom Errors -----------------------------------\n\n    /// @dev Thrown when attempting to setup an already initialized flash loan.\n    error FlashLoan__SetupIsInitialized();\n\n    /// @dev Thrown when one or more provided addresses are zero addresses.\n    error FlashLoan__ZeroAddresses();\n\n    /// @dev Thrown when the flash loan cannot be repaid.\n    error FlashLoan__LoanIsNotRepayable();\n\n    /// @dev Thrown when the loan amount is below the minimum allowed.\n    error FlashLoan__AmountBeyondMin();\n\n    /// @dev Thrown when the loan amount exceeds the maximum allowed.\n    error FlashLoan__AmountBeyondMax();\n\n    /// @dev Thrown when the collateral required for the loan is not active.\n    error FlashLoan__CollateralIsNotActive();\n\n    // ------------------------------------------ Events ------------------------------------------\n\n    /**\n     * @notice Emitted when a flash loan is executed.\n     * @param _borrower The address of the borrower.\n     * @param _debtAmount The amount of debt incurred by the borrower.\n     * @param _feeAmount The fee amount for the flash loan.\n     */\n    event FlashLoanExecuted(\n        address indexed _borrower, uint256 indexed _debtAmount, uint256 _feeAmount\n    );\n\n    /**\n     * @notice Emitted when the addresses for stableCoin and swapRouter are set.\n     * @param _stableCoin The address of the stable coin contract.\n     * @param _swapRouter The address of the swap router contract.\n     */\n    event AddressesSet(address _stableCoin, address _swapRouter);\n\n    // ------------------------------------------ Functions ---------------------------------------\n\n    /**\n     * @notice Executes a flash loan for the specified amount.\n     * @param _amount The amount of the flash loan.\n     * @dev This function initiates a flash loan transaction where the specified amount is borrowed\n     * and must be repaid along with a fee within the same transaction\n     */\n    function flashLoan(uint256 _amount) external;\n}\n"
    },
    "contracts/Interfaces/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IFlashLoanReceiver {\n    function executeOperation(uint256 _amount, uint256 _fee, address _debtToken) external;\n}\n"
    },
    "contracts/Interfaces/ILockedTREN.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface ILockedTREN {\n    struct Rule {\n        uint256 createdDate;\n        uint256 totalSupply;\n        uint256 startVestingDate;\n        uint256 endVestingDate;\n        uint256 claimed;\n    }\n\n    error LockedTREN__NotHaveVestingRule();\n    error LockedTREN__InvalidAddress();\n    error LockedTREN__AlreadyHaveVestingRule();\n    error LockedTREN__TotalSupplyLessThanClaimed();\n\n    event AddEntityVesting(\n        address indexed entity,\n        uint256 totalSupply,\n        uint256 startVestingDate,\n        uint256 endVestingDate\n    );\n}\n"
    },
    "contracts/Interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.23;\n\n/**\n * @dev Chainlink aggregator interface\n * @author From\n * https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\n */\ninterface ChainlinkAggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n/**\n * @title IPriceFeed\n * @notice Defines the basic interface for a PriceFeed contract.\n */\ninterface IPriceFeed {\n    /**\n     * @dev Enum for storing provider type for price feed.\n     * @param Chainlink The chainlink price feed.\n     * @param API3 The The api3 price feed.\n     */\n    enum ProviderType {\n        Chainlink,\n        API3,\n        Pyth\n    }\n\n    /**\n     * @dev Struct for storing information for price oracle.\n     * @param oracleAddress The oracle address.\n     * @param providerType The provider type.\n     * @param timeoutSeconds The maximum period that lasts a stale price.\n     * @param decimals The decimal precision of price oracle.\n     * @param isEthIndexed The flag to indicate whether to fetch price based on ETH.\n     * @param additionalData The additional data required by the specific oracle type.\n     */\n    struct OracleRecord {\n        address oracleAddress;\n        ProviderType providerType;\n        uint256 timeoutSeconds;\n        uint256 decimals;\n        bool isEthIndexed;\n        bytes32 additionalData;\n    }\n\n    /// @dev Error emitted when setting up fallback oracle without no existing primary oracle.\n    error PriceFeed__ExistingOracleRequired();\n\n    /// @dev Error emitted when the decimal precision of price oracle is zero.\n    error PriceFeed__InvalidDecimalsError();\n\n    /// @dev Error emitted when the fetched price for a specific token is zero.\n    /// @param _token The token address to fetch price.\n    error PriceFeed__InvalidOracleResponseError(address _token);\n\n    /// @dev Error emitted when the caller is not Timelock contract.\n    error PriceFeed__TimelockOnlyError();\n\n    /// @dev Error emitted when returning oracle address for unknown asset.\n    error PriceFeed__UnknownAssetError();\n\n    /// @dev Error emitted when the price feed is missing Pyth feed id.\n    error PriceFeed__MissingPythFeedId();\n\n    /**\n     * @dev Emitted when new oracle for a specific asset is registered.\n     * @param _token The asset address.\n     * @param _oracleAddress The oracle address.\n     * @param _isEthIndexed The flag to indicate whether to fetch price based on ETH.\n     * @param _isFallback The flag to indicate whether to set as fallback oracle.\n     */\n    event NewOracleRegistered(\n        address _token, address _oracleAddress, bool _isEthIndexed, bool _isFallback\n    );\n\n    /**\n     * @notice Fetches the price for an asset from a previously configured oracle.\n     * @dev Callers:\n     *    - BorrowerOperations.openTrenBox()\n     *    - BorrowerOperations.adjustTrenBox()\n     *    - BorrowerOperations.closeTrenBox()\n     *    - TrenBoxManagerOperations.liquidateTrenBoxes()\n     *    - TrenBoxManagerOperations.batchLiquidateTrenBoxes()\n     *    - TrenBoxManagerOperations.redeemCollateral()\n     * @param _token The asset address.\n     */\n    function fetchPrice(address _token) external view returns (uint256);\n\n    /**\n     * @notice Sets an oracle information for a specific asset.\n     * @param _token The asset address.\n     * @param _oracle The oracle address.\n     * @param _type The provider type.\n     * @param _timeoutSeconds The maximum period that lasts a stale price.\n     * @param _isEthIndexed The flag to indicate whether to fetch price based on ETH.\n     * @param _isFallback The flag to indicate whether to set as fallback oracle.\n     * @param _additionalData The additional data required by the oracle provider.\n     */\n    function setOracle(\n        address _token,\n        address _oracle,\n        ProviderType _type,\n        uint256 _timeoutSeconds,\n        bool _isEthIndexed,\n        bool _isFallback,\n        bytes32 _additionalData\n    )\n        external;\n}\n"
    },
    "contracts/Interfaces/IPriceFeedL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IPriceFeedL2 {\n    // Custom Errors\n    // --------------------------------------------------------------------------------------------------\n\n    error PriceFeedL2__SequencerDown();\n    error PriceFeedL2__SequencerGracePeriodNotOver();\n    error PriceFeedL2__SequencerZeroAddress();\n\n    // Events\n    // -----------------------------------------------------------------------------------------------------------\n\n    event SequencerUptimeFeedUpdated(address _sequencerUptimeFeed);\n\n    // Functions\n    // ------------------------------------------------------------------------------------------------------\n\n    function setSequencerUptimeFeedAddress(address _sequencerUptimeFeedAddress) external;\n\n    function fetchPrice(address _token) external view returns (uint256);\n}\n"
    },
    "contracts/Interfaces/ISortedTrenBoxes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title ISortedTrenBoxes\n * @notice Defines the basic interface for SortedTrenBoxes contract.\n */\ninterface ISortedTrenBoxes {\n    // --- Structs ---\n\n    /**\n     * @dev Struct for storing Node information.\n     * @param exists The existence indicator.\n     * @param nextId The Id of next Node (smaller NICR) in the list.\n     * @param prevId The Id of previous Node (larger NICR) in the list.\n     */\n    struct Node {\n        bool exists;\n        address nextId;\n        address prevId;\n    }\n\n    /**\n     * @dev Struct for storing Node list.\n     * @param head The head of the list. Also the Node in the list with the largest NICR.\n     * @param tail The tail of the list. Also the Node in the list with the smallest NICR.\n     * @param size The current size of the list.\n     * @param nodes The mapping from depositor address to its Node in the list.\n     */\n    struct TrenBoxesList {\n        address head;\n        address tail;\n        uint256 size;\n        mapping(address depositor => Node node) nodes;\n    }\n\n    // --- Events ---\n\n    /**\n     * @dev Emitted when the new Node is added to the list.\n     * @param _asset The address of collateral asset.\n     * @param _id The new Node's id.\n     * @param _NICR The new Node's NICR.\n     */\n    event NodeAdded(address indexed _asset, address _id, uint256 _NICR);\n\n    /**\n     * @dev Emitted when a Node is removed from the list.\n     * @param _asset The address of collateral asset.\n     * @param _id The Node's id.\n     */\n    event NodeRemoved(address indexed _asset, address _id);\n\n    // --- Errors ---\n\n    /// @dev Error emitted when the list does not contain the specific Node.\n    error SortedTrenBoxes__ListDoesNotContainNode();\n\n    /// @dev Error emitted when the list already contains the specific Node.\n    error SortedTrenBoxes__ListAlreadyContainsNode();\n\n    /// @dev Error emitted when the specific Node's id is zero.\n    error SortedTrenBoxes__IdCannotBeZeroAddress();\n\n    /// @dev Error emitted when the specific Node's NICR is zero.\n    error SortedTrenBoxes__NICRMustBeGreaterThanZero();\n\n    /// @dev Error emitted when the caller is not TrenBoxManager contract.\n    error SortedTrenBoxes__CallerMustBeTrenBoxManager();\n\n    /// @dev Error emitted when the caller is neither BorrowerOperations nor\n    /// TrenBoxManager contract.\n    error SortedTrenBoxes__CallerMustBeBorrowerOperationsOrTrenBoxManager();\n\n    // --- Functions ---\n\n    /**\n     * @notice Adds a new Node to the list.\n     * @param _asset The address of collateral asset.\n     * @param _id The Node's id.\n     * @param _NICR The Node's NICR.\n     * @param _prevId The Id of previous node for the insert position.\n     * @param _nextId The Id of next node for the insert position.\n     */\n    function insert(\n        address _asset,\n        address _id,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    )\n        external;\n\n    /**\n     * @notice Removes a Node from the list.\n     * @param _asset The address of collateral asset.\n     * @param _id The Node's id.\n     */\n    function remove(address _asset, address _id) external;\n\n    /**\n     * @notice Reinserts the Node at a new position based on its new NICR.\n     * @param _asset The address of collateral asset.\n     * @param _id The Node's id.\n     * @param _newNICR The Node's new NICR.\n     * @param _prevId The Id of previous Node for the new insert position.\n     * @param _nextId The Id of next Node for the new insert position.\n     */\n    function reInsert(\n        address _asset,\n        address _id,\n        uint256 _newNICR,\n        address _prevId,\n        address _nextId\n    )\n        external;\n\n    /**\n     * @notice Checks if the list contains a Node.\n     * @param _asset The address of collateral asset.\n     * @param _id The Node's id.\n     */\n    function contains(address _asset, address _id) external view returns (bool);\n\n    /**\n     * @notice Checks if the list is empty.\n     * @param _asset The address of collateral asset.\n     */\n    function isEmpty(address _asset) external view returns (bool);\n\n    /**\n     * @notice Returns the current size of the list.\n     * @param _asset The address of collateral asset.\n     */\n    function getSize(address _asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the first Node (with the largest NICR) in the list.\n     * @param _asset The address of collateral asset.\n     */\n    function getFirst(address _asset) external view returns (address);\n\n    /**\n     * @notice Returns the last Node (with the smallest NICR) in the list.\n     * @param _asset The address of collateral asset.\n     */\n    function getLast(address _asset) external view returns (address);\n\n    /**\n     * @notice Returns the next Node (with a smaller NICR) in the list for\n     * a given Node.\n     * @param _asset The address of collateral asset.\n     * @param _id The Node's id.\n     */\n    function getNext(address _asset, address _id) external view returns (address);\n\n    /**\n     * @notice Returns the previous Node (with a larger NICR) in the list for\n     * a given Node.\n     * @param _asset The address of collateral asset.\n     * @param _id The Node's id.\n     */\n    function getPrev(address _asset, address _id) external view returns (address);\n\n    /**\n     * @notice Checks if a pair of Nodes is a valid insertion point for\n     * a new Node with the given NICR.\n     * @param _asset The address of collateral asset.\n     * @param _NICR The Node's NICR.\n     * @param _prevId The Id of previous Node for the insert position.\n     * @param _nextId The Id of next Node for the insert position.\n     */\n    function validInsertPosition(\n        address _asset,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Finds the insert position for a new Node with the given NICR.\n     * @param _asset The address of collateral asset.\n     * @param _NICR The Node's NICR.\n     * @param _prevId The Id of previous node for the insert position.\n     * @param _nextId The Id of next node for the insert position.\n     */\n    function findInsertPosition(\n        address _asset,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    )\n        external\n        view\n        returns (address, address);\n}\n"
    },
    "contracts/Interfaces/IStabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.23;\n\nimport { IDeposit } from \"./IDeposit.sol\";\n\n/**\n * @title IStabilityPool\n * @notice Defines the basic interface for StabilityPool contract.\n */\ninterface IStabilityPool is IDeposit {\n    // --- Structs ---\n\n    /**\n     * @dev Struct for tracking a depositor's snapshot.\n     * @param S The sum of collateral gains.\n     * @param P The product.\n     * @param G The sum of TREN gains.\n     * @param scale The current scale.\n     * @param epoch The current epoch.\n     */\n    struct Snapshots {\n        mapping(address => uint256) S;\n        uint256 P;\n        uint256 G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    // --- Events ---\n\n    /**\n     * @dev Emitted when the snapshot for a specific depositor is updated.\n     * @param _depositor The caller address.\n     * @param _P The product.\n     * @param _G The sum of TREN gains.\n     */\n    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);\n\n    /**\n     * @dev Emitted when collateral gains are transferred to a depositor.\n     * @param _depositor The depositor address.\n     * @param _collaterals The address array of collaterals gained.\n     * @param _amounts The amount array of collaterals gained.\n     * @param _debtTokenLoss The loss of debt tokens against initial deposit.\n     */\n    event GainsWithdrawn(\n        address indexed _depositor,\n        address[] _collaterals,\n        uint256[] _amounts,\n        uint256 _debtTokenLoss\n    );\n\n    /**\n     * @dev Emitted when TREN gains are transferred to a depositor.\n     * @param _depositor The depositor address.\n     * @param _TREN The amount of TREN tokens.\n     */\n    event TRENPaidToDepositor(address indexed _depositor, uint256 _TREN);\n\n    /**\n     * @dev Emitted when the specific collateral is received from trenBoxStorage contract.\n     * @param _asset The address of collateral asset.\n     * @param _newBalance The updated balance of collateral asset.\n     */\n    event StabilityPoolAssetBalanceUpdated(address _asset, uint256 _newBalance);\n\n    /**\n     * @dev Emitted when debt tokens are sent to a user or moved to other pool.\n     * @param _newBalance The updated balance of debt tokens.\n     */\n    event StabilityPoolDebtTokenBalanceUpdated(uint256 _newBalance);\n\n    /**\n     * @dev Emitted when a user deposits or withdraws debt tokens.\n     * @param _depositor The depositor address.\n     * @param _newDeposit The updated user balance.\n     */\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n\n    /**\n     * @dev Emitted when the product is updated.\n     * @param _P The new product.\n     */\n    event ProductUpdated(uint256 _P);\n\n    /**\n     * @dev Emitted when the sum is updated.\n     * @param _asset The address of collateral asset.\n     * @param _S The new sum of collateral gains.\n     * @param _epoch The current epoch.\n     * @param _scale THe current scale.\n     */\n    event SumUpdated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);\n\n    /**\n     * @dev Emitted when the sum of TREN gains is updated.\n     * @param _G The new sum of TREN gains.\n     * @param _epoch The current epoch.\n     * @param _scale The current scale.\n     */\n    event GainsUpdated(uint256 _G, uint128 _epoch, uint128 _scale);\n\n    /**\n     * @dev Emitted when the current epoch is updated.\n     * @param _currentEpoch The new epoch.\n     */\n    event EpochUpdated(uint128 _currentEpoch);\n\n    /**\n     * @dev Emitted when the current scale is updated.\n     * @param _currentScale The new scale.\n     */\n    event ScaleUpdated(uint128 _currentScale);\n\n    // --- Errors ---\n\n    /**\n     * @dev Error emitted when the caller is not TrenBoxStorage.\n     * @param _sender The caller address.\n     * @param _expected The TrenBoxStorage address.\n     */\n    error StabilityPool__TrenBoxStorageOnly(address _sender, address _expected);\n\n    /**\n     * @dev Error emitted when the caller is not AdminContract.\n     * @param _sender The caller address.\n     * @param _expected The AdminContract address.\n     */\n    error StabilityPool__AdminContractOnly(address _sender, address _expected);\n\n    /**\n     * @dev Error emitted when the caller is not TrenBoxManager.\n     * @param _sender The caller address.\n     * @param _expected The TrenBoxManager address.\n     */\n    error StabilityPool__TrenBoxManagerOnly(address _sender, address _expected);\n\n    /// @dev Error emitted when the asset list is not in ascending order.\n    error StabilityPool__ArrayNotInAscendingOrder();\n\n    /**\n     * @dev Error emitted when the debt loss per unit staked is not less than\n     * decimal precision.\n     * @param _debtLoss The debt loss per unit staked.\n     */\n    error StabilityPool__DebtLossBelowOne(uint256 _debtLoss);\n\n    /// @dev Error emitted when the amount of debt to offset is larger than\n    /// total deposits.\n    error StabilityPool__DebtLargerThanTotalDeposits();\n\n    /// @dev Error emitted when the new product is zero.\n    error StabilityPool__ProductZero();\n\n    /// @dev Error emitted when the array length is mismatched.\n    error StabilityPool__AssetsAndAmountsLengthMismatch();\n\n    /// @dev Error emitted when the user's initial deposit is zero.\n    error StabilityPool__UserHasNoDeposit();\n\n    /// @dev Error emitted when the amount is zero.\n    error StabilityPool__AmountMustBeNonZero();\n\n    // --- Functions ---\n\n    /**\n     * @notice Gets collateral balance in the Stability Pool for a given collateral type.\n     * @dev Not necessarily this contract's actual collateral balance;\n     * just what is stored in state\n     * @param _collateral The address of collateral asset.\n     * @return The amount of collateral asset.\n     */\n    function getCollateral(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Gets all collateral assets and amounts.\n     */\n    function getAllCollateral() external view returns (address[] memory, uint256[] memory);\n\n    /**\n     * @notice Returns total deposits of debt tokens held in the pool.\n     * Changes when users deposit/withdraw, and when a TrenBox debt is offset.\n     */\n    function getTotalDebtTokenDeposits() external view returns (uint256);\n\n    /**\n     * @notice Calculates the gains earned by a deposit since its last snapshots were taken for\n     * selected assets.\n     * @dev Given by the formula: E = d0 * (S - S(0))/P(0),\n     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\n     * d0 is the last recorded deposit value.\n     * @param _depositor The depositor address.\n     * @param _assets The array of collateral assets to check gains for.\n     */\n    function getDepositorGains(\n        address _depositor,\n        address[] calldata _assets\n    )\n        external\n        view\n        returns (address[] memory, uint256[] memory);\n\n    /**\n     * @notice Calculates the TREN gain earned by a deposit since its last snapshots were taken.\n     * @dev Given by the formula: TREN = d0 * (G - G(0))/P(0),\n     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\n     * d0 is the last recorded deposit value.\n     * @param _depositor The depositor address.\n     */\n    function getDepositorTRENGain(address _depositor) external view returns (uint256);\n\n    /**\n     * @notice Returns the user's compounded deposit.\n     * @dev Given by the formula: d = d0 * P/P(0),\n     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their\n     * deposit.\n     * @param _depositor The depositor address.\n     */\n    function getCompoundedDebtTokenDeposits(address _depositor) external view returns (uint256);\n\n    /**\n     * @notice Adds new collateral type.\n     * @param _collateral The address of collateral asset to add.\n     */\n    function addCollateralType(address _collateral) external;\n\n    /**\n     * @notice Provides debt tokens to the Stability Pool.\n     * @dev Triggers a TREN issuance, based on time passed since the last issuance.\n     * The TREN issuance is shared between all depositors.\n     * - Sends depositor's accumulated gains (TREN, collateral assets) to depositor.\n     * - Increases deposit stake, and takes new snapshots for each.\n     * Skipping a collateral forfeits the available rewards (can be useful for gas optimizations).\n     * @param _amount The amount of debt tokens provided.\n     * @param _assets The array of collateral assets to be claimed.\n     */\n    function provideToSP(uint256 _amount, address[] calldata _assets) external;\n\n    /**\n     * @notice Withdraws debt tokens from the Stability Pool.\n     * @dev Triggers a TREN issuance, based on time passed since the last issuance.\n     * The TREN issuance is shared between all depositors.\n     * - Sends all depositor's accumulated gains (TREN, assets) to depositor\n     * - Decreases deposit's stake, and takes new snapshots.\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n     * @param _amount The amount of debt tokens to withdraw.\n     * @param _assets The array of collateral assets to be claimed.\n     */\n    function withdrawFromSP(uint256 _amount, address[] calldata _assets) external;\n\n    /**\n     * @notice Sets the offset for liquidation.\n     * @dev Cancels out the specified debt against the debt tokens contained in the\n     * Stability Pool (as far as possible)\n     * and transfers the TrenBox's collateral from TrenBoxStorage to Stability Pool.\n     * Only called by liquidation functions in the TrenBoxManager.\n     * @param _debtToOffset The amount of debt tokens to offset.\n     * @param _asset The address of collateral asset.\n     * @param _amountAdded The amount of collateral asset to be added.\n     */\n    function offset(uint256 _debtToOffset, address _asset, uint256 _amountAdded) external;\n}\n"
    },
    "contracts/Interfaces/ITrenBoxManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title ITrenBoxManager\n * @notice Defines the basic interface for TrenBoxManager contract.\n */\ninterface ITrenBoxManager {\n    // Enums\n    // ------------------------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Enum for storing TrenBox status.\n     * @param nonExistent The non-existence status .\n     * @param active The active status.\n     * @param closedByOwner The closed status by owner.\n     * @param closedByLiquidation The closed status by liquidation.\n     * @param closedByRedemption The closed status by redemption.\n     * @param closedByRedistribution The closed status by redistribution.\n     */\n    enum Status {\n        nonExistent,\n        active,\n        closedByOwner,\n        closedByLiquidation,\n        closedByRedemption,\n        closedByRedistribution\n    }\n\n    /**\n     * @dev Enum for storing operation type by TrenBoxManagerOperations contract.\n     * @param applyPendingRewards The operation that adds pending rewards to the TrenBox.\n     * @param liquidateInNormalMode The operation that closes the TrenBox by liquidation\n     * under normal mode.\n     * @param liquidateInRecoveryMode The operation that closes the TrenBox by liquidation\n     * under recovery mode.\n     * @param redeemCollateral The operation that redeems the collateral by redemption.\n     * @param redistributeCollateral The operation that closes the TrenBox by redistribution.\n     */\n    enum TrenBoxManagerOperation {\n        applyPendingRewards,\n        liquidateInNormalMode,\n        liquidateInRecoveryMode,\n        redeemCollateral,\n        redistributeCollateral\n    }\n\n    // Structs\n    // ----------------------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Struct for storing TrenBox information.\n     * @param debt The debt token amount.\n     * @param coll The collateral amount.\n     * @param stake The stake amount.\n     * @param status The current status.\n     * @param arrayIndex The index in the owner array.\n     */\n    struct TrenBox {\n        uint256 debt;\n        uint256 coll;\n        uint256 stake;\n        Status status;\n        uint128 arrayIndex;\n    }\n\n    /**\n     * @dev Struct for storing the collateral and debt token snapshots for a given active TrenBox.\n     * @param asset The snapshot of collateral asset.\n     * @param debt The snapshot of debt token.\n     */\n    struct RewardSnapshot {\n        uint256 asset;\n        uint256 debt;\n    }\n\n    // Events\n    // -----------------------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Emitted when the base rate is updated by redemption.\n     * @param _asset The address of collateral asset.\n     * @param _baseRate The new base rate.\n     */\n    event BaseRateUpdated(address indexed _asset, uint256 _baseRate);\n\n    /**\n     * @dev Emitted when the timestamp of last fee operation is updated.\n     * @param _asset The address of collateral asset.\n     * @param _lastFeeOpTime The timestamp of latest fee operation.\n     */\n    event LastFeeOpTimeUpdated(address indexed _asset, uint256 _lastFeeOpTime);\n\n    /**\n     * @dev Emitted when the total staked amount for a specific collateral is updated.\n     * @param _asset The address of collateral asset.\n     * @param _newTotalStakes The new total staked amount.\n     */\n    event TotalStakesUpdated(address indexed _asset, uint256 _newTotalStakes);\n\n    /**\n     * @dev Emitted when the system snapshot is updated.\n     * @param _asset The address of collateral asset.\n     * @param _totalStakesSnapshot The total stakes snapshot.\n     * @param _totalCollateralSnapshot The total collateral snapshot.\n     */\n    event SystemSnapshotsUpdated(\n        address indexed _asset, uint256 _totalStakesSnapshot, uint256 _totalCollateralSnapshot\n    );\n\n    /**\n     * @dev Emitted when the accumulated liquidation rewards per unit staked are updated.\n     * @param _asset The address of collateral asset.\n     * @param _L_Coll The liquidated collateral.\n     * @param _L_Debt The liquidated debt.\n     */\n    event LTermsUpdated(address indexed _asset, uint256 _L_Coll, uint256 _L_Debt);\n\n    /**\n     * @dev Emitted when the reward snapshot is updated.\n     * @param _asset The address of collateral asset.\n     * @param _L_Coll The liquidated collateral.\n     * @param _L_Debt The liquidated debt.\n     */\n    event TrenBoxSnapshotsUpdated(address indexed _asset, uint256 _L_Coll, uint256 _L_Debt);\n\n    /**\n     * @dev Emitted when the owner of TrenBox is removed in owners array.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _newIndex The new array index.\n     */\n    event TrenBoxIndexUpdated(address indexed _asset, address _borrower, uint256 _newIndex);\n\n    /**\n     * @dev Emitted when the specific TrenBox is updated.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _debt The new debt amount.\n     * @param _coll The new collateral amount.\n     * @param _stake The new stake amount.\n     * @param _operation The operation type.\n     */\n    event TrenBoxUpdated(\n        address indexed _asset,\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _stake,\n        TrenBoxManagerOperation _operation\n    );\n\n    // Custom Errors\n    // ----------------------------------------------------------------------------------------------------\n\n    /// @dev Error emitted when the redemption fee is bigger than the drawn amount.\n    error TrenBoxManager__FeeBiggerThanAssetDraw();\n\n    /// @dev Error emitted when there is only one or zero TrenBox.\n    error TrenBoxManager__OnlyOneTrenBox();\n\n    /// @dev Error emitted when the caller is not TrenBoxManagerOperations contract.\n    error TrenBoxManager__OnlyTrenBoxManagerOperations();\n\n    /// @dev Error emitted when the caller is not BorrowerOperations contract.\n    error TrenBoxManager__OnlyBorrowerOperations();\n\n    /// @dev Error emitted when the caller is neither TrenBoxManagerOperations\n    /// nor BorrowerOperations.\n    error TrenBoxManager__OnlyTrenBoxManagerOperationsOrBorrowerOperations();\n\n    // Functions\n    // --------------------------------------------------------------------------------------------------------\n\n    /**\n     * @notice Returns whether it is the first redemption for a specific borrower.\n     * @param _asset The address of collateral asset.\n     * @param _firstRedemptionHint The borrower address to check.\n     * @param _price The price of collateral asset.\n     */\n    function isValidFirstRedemptionHint(\n        address _asset,\n        address _firstRedemptionHint,\n        uint256 _price\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Returns the nominal collateral ratio (ICR) of a given TrenBox without the price.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function getNominalICR(address _asset, address _borrower) external view returns (uint256);\n\n    /**\n     * @notice Returns the current collateral ratio (ICR) of a given TrenBox.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _price The price of collateral asset.\n     */\n    function getCurrentICR(\n        address _asset,\n        address _borrower,\n        uint256 _price\n    )\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the borrower's pending accumulated collateral reward\n     * earned by their stake.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function getPendingAssetReward(\n        address _asset,\n        address _borrower\n    )\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the borrower's pending accumulated debt token reward\n     * earned by their stake.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function getPendingDebtTokenReward(\n        address _asset,\n        address _borrower\n    )\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns whether the borrower has pending rewards.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function hasPendingRewards(address _asset, address _borrower) external view returns (bool);\n\n    /**\n     * @notice Returns the borrower's entire debt and collateral balances\n     * with pending rewards.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function getEntireDebtAndColl(\n        address _asset,\n        address _borrower\n    )\n        external\n        view\n        returns (uint256 debt, uint256 coll, uint256 pendingDebtReward, uint256 pendingCollReward);\n\n    /**\n     * @notice Returns whether the specific TrenBox is active or not.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function isTrenBoxActive(address _asset, address _borrower) external view returns (bool);\n\n    /**\n     * @notice Returns the total collateral ratio for a specific collaterl asset.\n     * @param _asset The address of collateral asset.\n     * @param _price The price of collateral asset.\n     */\n    function getTCR(address _asset, uint256 _price) external view returns (uint256);\n\n    /**\n     * @notice Checks whether the current mode is Recovery Mode or not.\n     * @param _asset The address of collateral asset.\n     * @param _price The price of collateral asset.\n     */\n    function checkRecoveryMode(address _asset, uint256 _price) external view returns (bool);\n\n    /**\n     * @notice Returns the borrowing fee rate for a specific collateral asset.\n     * @param _asset The address of collateral asset.\n     */\n    function getBorrowingRate(address _asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the borrowing fee amount for a given debt amount.\n     * @param _asset The address of collateral asset.\n     * @param _debtTokenAmount The amount of debt tokens to borrow.\n     */\n    function getBorrowingFee(\n        address _asset,\n        uint256 _debtTokenAmount\n    )\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the redemption fee amount for a given collateral amount.\n     * @param _asset The address of collateral asset.\n     * @param _assetDraw The amount of collateral asset to draw.\n     */\n    function getRedemptionFee(address _asset, uint256 _assetDraw) external view returns (uint256);\n\n    /**\n     * @notice Returns the redemption fee amount with decay for a given collateral amount.\n     * @param _asset The address of collateral asset.\n     * @param _assetDraw The amount of collateral asset to draw.\n     */\n    function getRedemptionFeeWithDecay(\n        address _asset,\n        uint256 _assetDraw\n    )\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the redemption rate for a specific collateral asset.\n     * @param _asset The address of collateral asset.\n     */\n    function getRedemptionRate(address _asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the redemption rate with decay for a specific collateral asset.\n     * @param _asset The address of collateral asset.\n     */\n    function getRedemptionRateWithDecay(address _asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the TrenBox owner based on array index.\n     * @param _asset The address of collateral asset.\n     * @param _index The array index.\n     */\n    function getTrenBoxFromTrenBoxOwnersArray(\n        address _asset,\n        uint256 _index\n    )\n        external\n        view\n        returns (address);\n\n    /**\n     * @notice Returns the net debt amount excluded gas compensation.\n     * @param _asset The address of collateral asset.\n     * @param _debt The amount of debt tokens.\n     */\n    function getNetDebt(address _asset, uint256 _debt) external view returns (uint256);\n\n    /**\n     * @notice Returns the number of TrenBox owners for a specific collateral asset.\n     * @param _asset The address of collateral asset.\n     */\n    function getTrenBoxOwnersCount(address _asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the TrenBox status for a specific borrower.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function getTrenBoxStatus(address _asset, address _borrower) external view returns (uint256);\n\n    /**\n     * @notice Returns the TrenBox stake for a specific borrower.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function getTrenBoxStake(address _asset, address _borrower) external view returns (uint256);\n\n    /**\n     * @notice Returns the TrenBox debt balance for a specific borrower.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function getTrenBoxDebt(address _asset, address _borrower) external view returns (uint256);\n\n    /**\n     * @notice Returns the TrenBox collateral balance for a specific borrower.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function getTrenBoxColl(address _asset, address _borrower) external view returns (uint256);\n\n    /**\n     * @notice Adds a specific borrower to the owner array.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function addTrenBoxOwnerToArray(\n        address _asset,\n        address _borrower\n    )\n        external\n        returns (uint256 index);\n\n    /**\n     * @notice Executes full redemption for a specific TrenBox.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _newColl The new collateral balance to update.\n     */\n    function executeFullRedemption(address _asset, address _borrower, uint256 _newColl) external;\n\n    /**\n     * @notice Executes partial redemption for a specific TrenBox.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _newDebt The new debt balance to update.\n     * @param _newColl The new collateral balance to update.\n     * @param _newNICR The new nominal collateral ratio.\n     * @param _upperPartialRedemptionHint Id of previous node for the new insert position.\n     * @param _lowerPartialRedemptionHint Id of next node for the new insert position.\n     */\n    function executePartialRedemption(\n        address _asset,\n        address _borrower,\n        uint256 _newDebt,\n        uint256 _newColl,\n        uint256 _newNICR,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint\n    )\n        external;\n\n    /**\n     * @notice Finalizes redemption for a specific TrenBox.\n     * @param _asset The address of collateral asset.\n     * @param _receiver The redeemer address.\n     * @param _debtToRedeem The amount of debt tokens to redeem.\n     * @param _assetFeeAmount The amount of redemption fee.\n     * @param _assetRedeemedAmount The amount of redeemed collateral.\n     */\n    function finalizeRedemption(\n        address _asset,\n        address _receiver,\n        uint256 _debtToRedeem,\n        uint256 _assetFeeAmount,\n        uint256 _assetRedeemedAmount\n    )\n        external;\n\n    /**\n     * @notice Updates redemption base rate.\n     * @param _asset The address of collateral asset.\n     * @param _assetDrawn The amount of collateral asset to draw.\n     * @param _price The price of collateral asset.\n     * @param _totalDebtTokenSupply The total supply of debt tokens.\n     */\n    function updateBaseRateFromRedemption(\n        address _asset,\n        uint256 _assetDrawn,\n        uint256 _price,\n        uint256 _totalDebtTokenSupply\n    )\n        external;\n\n    /**\n     * @notice Adds the pending debt and collateral rewards to the TrenBox.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function applyPendingRewards(address _asset, address _borrower) external;\n\n    /**\n     * @notice Moves the TrenBox's pending debt and collateral rewards to active TrenBoxStorage.\n     * @param _asset The address of collateral asset.\n     * @param _debtTokenAmount The amount of debt tokens to move.\n     * @param _assetAmount The amount of collateral asset to move.\n     */\n    function movePendingTrenBoxRewardsFromLiquidatedToActive(\n        address _asset,\n        uint256 _debtTokenAmount,\n        uint256 _assetAmount\n    )\n        external;\n\n    /**\n     * @notice Updates the borrower's rewards snapshot.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function updateTrenBoxRewardSnapshots(address _asset, address _borrower) external;\n\n    /**\n     * @notice Updates the borrower's stake based on their latest collateral.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function updateStakeAndTotalStakes(\n        address _asset,\n        address _borrower\n    )\n        external\n        returns (uint256);\n\n    /**\n     * @notice Removes the borrower's stake amount from total staked amount.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function removeStake(address _asset, address _borrower) external;\n\n    /**\n     * @notice Adds distributed collateral and debt rewards to the running totals.\n     * @param _asset The address of collateral asset.\n     * @param _debt The debt amount to redistribute.\n     * @param _coll The collateral amount to redistribute.\n     * @param _debtToOffset The debt amount to offset.\n     * @param _collToSendToStabilityPool The collateral amount to send to the Stability Pool.\n     */\n    function redistributeDebtAndColl(\n        address _asset,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _debtToOffset,\n        uint256 _collToSendToStabilityPool\n    )\n        external;\n\n    /**\n     * @notice Updates system snapshot excluding collateral remainder.\n     * @param _asset The address of collateral asset.\n     * @param _collRemainder The collateral remainder.\n     */\n    function updateSystemSnapshots_excludeCollRemainder(\n        address _asset,\n        uint256 _collRemainder\n    )\n        external;\n\n    /**\n     * @notice Closes a specific borrower's TrenBox.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function closeTrenBox(address _asset, address _borrower) external;\n\n    /**\n     * @notice Closes a specific borrower's TrenBox by liquidation.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function closeTrenBoxLiquidation(address _asset, address _borrower) external;\n\n    /**\n     * @notice Closes a specific borrower's TrenBox by redistribution.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _debtTokenGasCompensationToBurn The gas compensation to burn.\n     */\n    function closeTrenBoxRedistribution(\n        address _asset,\n        address _borrower,\n        uint256 _debtTokenGasCompensationToBurn\n    )\n        external;\n\n    /**\n     * @notice Sends gas compensation to the liquidator.\n     * @param _asset The address of collateral asset.\n     * @param _liquidator The liquidator address.\n     * @param _debtTokenAmount The debt token amount of gas compensation.\n     * @param _assetAmount The collateral amount of gas compensation.\n     */\n    function sendGasCompensation(\n        address _asset,\n        address _liquidator,\n        uint256 _debtTokenAmount,\n        uint256 _assetAmount\n    )\n        external;\n\n    /**\n     * @notice Sets the TrenBox's status.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _num The enum status to set.\n     */\n    function setTrenBoxStatus(address _asset, address _borrower, uint256 _num) external;\n\n    /**\n     * @notice Increases the TrenBox's collateral balance.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _collIncrease The collateral amount to increase.\n     */\n    function increaseTrenBoxColl(\n        address _asset,\n        address _borrower,\n        uint256 _collIncrease\n    )\n        external\n        returns (uint256);\n\n    /**\n     * @notice Decreases the TrenBox's collateral balance.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _collDecrease The collateral amount to decrease.\n     */\n    function decreaseTrenBoxColl(\n        address _asset,\n        address _borrower,\n        uint256 _collDecrease\n    )\n        external\n        returns (uint256);\n\n    /**\n     * @notice Increases the TrenBox's debt token balance.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _debtIncrease The debt token amount to increase.\n     */\n    function increaseTrenBoxDebt(\n        address _asset,\n        address _borrower,\n        uint256 _debtIncrease\n    )\n        external\n        returns (uint256);\n\n    /**\n     * @notice Decreases the TrenBox's debt token balance.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _debtDecrease The deb token amount to decrease.\n     */\n    function decreaseTrenBoxDebt(\n        address _asset,\n        address _borrower,\n        uint256 _debtDecrease\n    )\n        external\n        returns (uint256);\n}\n"
    },
    "contracts/Interfaces/ITrenBoxManagerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { ITrenBoxManager } from \"./ITrenBoxManager.sol\";\n\n/**\n * @title ITrenBoxManagerOperations\n * @notice Defines the basic interface for TrenBoxManagerOperations contract.\n */\ninterface ITrenBoxManagerOperations {\n    // ------------------------------------------ Structs -----------------------------------------\n\n    /**\n     * @dev The struct for local variables storing of redemption total parameters.\n     * @param remainingDebt The remaining amount of debt.\n     * @param totalDebtToRedeem The total amount of debt to redeem.\n     * @param totalCollDrawn The total amount of collateral.\n     * @param collFee The amount of collateral fee.\n     * @param price The amount of collateral price.\n     * @param totalDebtTokenSupplyAtStart The total amount of trenUSD supply at the start of\n     * redemption.\n     */\n    struct RedemptionTotals {\n        uint256 remainingDebt;\n        uint256 totalDebtToRedeem;\n        uint256 totalCollDrawn;\n        uint256 collFee;\n        uint256 price;\n        uint256 totalDebtTokenSupplyAtStart;\n    }\n\n    /**\n     * @dev The struct for local variables storing of single redemption parameters.\n     * @param debtLot The remaining amount of debt.\n     * @param collLot The remaining amount of collateral.\n     * @param cancelledPartial The index of cancelled partial redemption.\n     */\n    struct SingleRedemptionValues {\n        uint256 debtLot;\n        uint256 collLot;\n        bool cancelledPartial;\n    }\n\n    /**\n     * @dev The struct for local variables storing of liquidation total parameters.\n     * @param totalCollInSequence The total amount of collateral in list.\n     * @param totalDebtInSequence The total amount of debt in list.\n     * @param totalCollGasCompensation The total amount of gas compensation, expressed in\n     * collateral.\n     * @param totalDebtTokenGasCompensation The total amount of gas compensation, expressed in\n     * trenUSD.\n     * @param totalDebtToOffset The total amount to be offset, expressed in trenUSD.\n     * @param totalCollToSendToSP The total amount of collateral to be sent to Stability Pool.\n     * @param totalDebtToRedistribute The total amount of debt to be redistributed, expressed in\n     * trenUSD.\n     * @param totalCollToRedistribute The total amount of collateral to be redistributed.\n     * @param totalCollToClaim The total amount of collateral to be claimed.\n     */\n    struct LiquidationTotals {\n        uint256 totalCollInSequence;\n        uint256 totalDebtInSequence;\n        uint256 totalCollGasCompensation;\n        uint256 totalDebtTokenGasCompensation;\n        uint256 totalDebtToOffset;\n        uint256 totalCollToSendToSP;\n        uint256 totalDebtToRedistribute;\n        uint256 totalCollToRedistribute;\n        uint256 totalCollToClaim;\n    }\n\n    /**\n     * @dev The struct for local variables storing of signle liquidation parameters.\n     * @param entireTrenBoxDebt The entire amount of debt.\n     * @param entireTrenBoxColl The entire amount of collateral.\n     * @param collGasCompensation The amount of gas compensation, expressed in collateral.\n     * @param debtTokenGasCompensation The amount of gas compensation, expressed in trenUSD.\n     * @param debtToOffset The amount to be offset, expressed in trenUSD.\n     * @param collToSendToSP The amount of collateral to be sent to Stability Pool.\n     * @param debtToRedistribute The amount of debt to be redistributed, expressed in trenUSD.\n     * @param collToRedistribute The amount of collateral to be redistributed.\n     * @param collToClaim The amount of collateral to be claimed.\n     */\n    struct LiquidationValues {\n        uint256 entireTrenBoxDebt;\n        uint256 entireTrenBoxColl;\n        uint256 collGasCompensation;\n        uint256 debtTokenGasCompensation;\n        uint256 debtToOffset;\n        uint256 collToSendToSP;\n        uint256 debtToRedistribute;\n        uint256 collToRedistribute;\n        uint256 collToClaim;\n    }\n\n    /**\n     * @dev The struct for local variables storing of inner single liquidation parameters.\n     * @param collToLiquidate The amount of collateral to be liquidated.\n     * @param pendingDebtReward The amount of pending rewards, expressed in trenUSD.\n     * @param pendingCollReward The amount of pending rewards, expressed in collateral.\n     */\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        uint256 collToLiquidate;\n        uint256 pendingDebtReward;\n        uint256 pendingCollReward;\n    }\n\n    /**\n     * @dev The struct for local variables storing of outer single liquidation parameters.\n     * @param price The amount of collateral price.\n     * @param debtTokenInStabPool The amount of debt to be sent in Stability Pool, expressed in\n     * trenUSD.\n     * @param recoveryModeAtStart The index of Recovery Mode at the beginning.\n     * @param liquidatedDebt The amount of liquidated debt.\n     * @param liquidatedColl The amount of liquidated collateral.\n     */\n    struct LocalVariables_OuterLiquidationFunction {\n        uint256 price;\n        uint256 debtTokenInStabPool;\n        bool recoveryModeAtStart;\n        uint256 liquidatedDebt;\n        uint256 liquidatedColl;\n    }\n\n    /**\n     * @dev The struct for local variables storing of liquidation list.\n     * @param remainingDebtTokenInStabPool The remaining amount of debt in Stability Pool.\n     * @param price The amount of collateral price.\n     * @param ICR The individual collateral ratio.\n     * @param user The address of borrower.\n     * @param backToNormalMode The index of backing to normal mode or no.\n     * @param entireSystemDebt The entire amount of system debt.\n     * @param entireSystemColl The entire amount of system collateral.\n     */\n    struct LocalVariables_LiquidationSequence {\n        uint256 remainingDebtTokenInStabPool;\n        uint256 price;\n        uint256 ICR;\n        address user;\n        bool backToNormalMode;\n        uint256 entireSystemDebt;\n        uint256 entireSystemColl;\n    }\n\n    /**\n     * @dev The struct for local variables storing of hint helper parameters.\n     * @param asset The address of collateral asset.\n     * @param debtTokenAmount The amount of debt.\n     * @param price The price of collateral asset.\n     * @param maxIterations The maximum number of iterations.\n     */\n    struct LocalVariables_HintHelper {\n        address asset;\n        uint256 debtTokenAmount;\n        uint256 price;\n        uint256 maxIterations;\n    }\n\n    // ------------------------------------------ Events ------------------------------------------\n\n    /**\n     * @dev Emitted when the TrenBox is redeemed.\n     * @param _asset The address of collateral asset.\n     * @param _attemptedDebtAmount The attempted amount of debt.\n     * @param _actualDebtAmount The actual amount of debt.\n     * @param _collSent The amount of collateral which will be sent to redeemer.\n     * @param _collFee The amount of collateral fee which should be paid.\n     */\n    event Redemption(\n        address indexed _asset,\n        uint256 _attemptedDebtAmount,\n        uint256 _actualDebtAmount,\n        uint256 _collSent,\n        uint256 _collFee\n    );\n\n    /**\n     * @dev Emitted when the TrenBox is liquidated.\n     * @param _asset The address of collateral asset.\n     * @param _liquidatedDebt The liquidated amount of debt.\n     * @param _liquidatedColl The liquidated amount of collateral.\n     * @param _collGasCompensation The amount of gas compensation, expressed in collateral.\n     * @param _debtTokenGasCompensation The amount of gas compensation, expressed in trenUSD.\n     */\n    event Liquidation(\n        address indexed _asset,\n        uint256 _liquidatedDebt,\n        uint256 _liquidatedColl,\n        uint256 _collGasCompensation,\n        uint256 _debtTokenGasCompensation\n    );\n\n    /**\n     * @dev Emitted when the TrenBox is redistributed.\n     * @param _asset The address of collateral asset.\n     * @param _redistributedDebt The redistributed amount of debt.\n     * @param _redistributedCool The redistributed amount of collateral.\n     * @param _totalDebtTokenGasCompensation The total amount of gas compensation, expressed in\n     * trenUSD.\n     */\n    event Redistribution(\n        address indexed _asset,\n        uint256 _redistributedDebt,\n        uint256 _redistributedCool,\n        uint256 _totalDebtTokenGasCompensation\n    );\n\n    /**\n     * @dev Emitted when the exact TrenBox is liquidated.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The address of borrower.\n     * @param _debt The amount of debt.\n     * @param _coll The amount of collateral.\n     * @param _operation The index of liquidation.\n     */\n    event TrenBoxLiquidated(\n        address indexed _asset,\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        ITrenBoxManager.TrenBoxManagerOperation _operation\n    );\n\n    /**\n     * @dev Emitted when the redemption softening parameter is changed.\n     * @param _redemptionSofteningParam The new redemption softening parameter.\n     */\n    event RedemptionSoftenParamChanged(uint256 _redemptionSofteningParam);\n\n    // ------------------------------------------ Custom Errors -----------------------------------\n\n    /// @dev Thrown when an operation involves an array with an invalid size.\n    error TrenBoxManagerOperations__InvalidArraySize();\n\n    /// @dev Thrown when an operation involves an amount that is empty or zero.\n    error TrenBoxManagerOperations__EmptyAmount();\n\n    /// @dev Thrown when the fee percentage is outside the allowed boundaries.\n    /// @param lowerBoundary The lower boundary of the allowed fee percentage.\n    /// @param upperBoundary The upper boundary of the allowed fee percentage.\n    error TrenBoxManagerOperations__FeePercentOutOfBounds(\n        uint256 lowerBoundary, uint256 upperBoundary\n    );\n\n    /// @dev Thrown when there is insufficient balance of the debt token to complete an\n    /// operation.\n    /// @param availableBalance The available balance of the debt token.\n    error TrenBoxManagerOperations__InsufficientDebtTokenBalance(uint256 availableBalance);\n\n    /// @dev Thrown when there is nothing to liquidate during a liquidation process.\n    error TrenBoxManagerOperations__NothingToLiquidate();\n\n    /// @dev Thrown when a function is called by an entity that is not the TrenBox Manager.\n    error TrenBoxManagerOperations__OnlyTrenBoxManager();\n\n    /// @dev Thrown when redemption of tokens is blocked.\n    error TrenBoxManagerOperations__RedemptionIsBlocked();\n\n    /// @dev Thrown when the Total Collateral Ratio (TCR) is below the Minimum Collateral Ratio\n    /// (MCR).\n    /// @param tcr The current Total Collateral Ratio.\n    /// @param mcr The Minimum Collateral Ratio that must be met or exceeded.\n    error TrenBoxManagerOperations__TCRMustBeAboveMCR(uint256 tcr, uint256 mcr);\n\n    /// @dev Thrown when no amount can be redeemed due to insufficient conditions or\n    /// restrictions.\n    error TrenBoxManagerOperations__UnableToRedeemAnyAmount();\n\n    /// @dev Thrown when an operation is attempted on an inactive TrenBox.\n    error TrenBoxManagerOperations__TrenBoxNotActive();\n\n    /// @dev Thrown when a provided parameter is invalid.\n    error TrenBoxManagerOperations__InvalidParam();\n\n    /// @dev Thrown when a function is called by caller that is not the Timelock contract.\n    error TrenBoxManagerOperations__NotTimelock();\n\n    // ------------------------------------------ Functions ---------------------------------------\n\n    /**\n     * @notice Liquidate a single TrenBox.\n     * @dev Closes the TrenBox if its ICR is lower than the minimum collateral ratio.\n     * @param _asset The address of asset.\n     * @param _borrower The address of borrower.\n     */\n    function liquidate(address _asset, address _borrower) external;\n\n    /**\n     * @notice Liquidate a sequence of TrenBoxes.\n     * @dev Closes a maximum number of n under-collateralized TrenBoxes,\n     * starting from the one with the lowest collateral ratio in the system, and moving upwards.\n     * @param _asset The address of asset.\n     * @param _n The list TrenBoxes that should be liquidated.\n     */\n    function liquidateTrenBoxes(address _asset, uint256 _n) external;\n\n    /**\n     * @notice Attempt to liquidate a custom list of TrenBoxes provided by the caller.\n     * @param _asset The address of asset.\n     * @param _trenBoxArray The array of custom TrenBoxes.\n     */\n    function batchLiquidateTrenBoxes(address _asset, address[] memory _trenBoxArray) external;\n\n    /**\n     * @notice Redeem collateral from active TrenBox.\n     * @dev Closes an active TrenBox even if its ICR is higher than the minimum collateral ratio.\n     * @param _asset The address of asset.\n     * @param _debtTokenAmount The amount of debt.\n     * @param _upperPartialRedemptionHint The address of upper partial redemption hint.\n     * @param _lowerPartialRedemptionHint The address of lower partial redemption hint.\n     * @param _firstRedemptionHint The address of first redemption hint.\n     * @param _partialRedemptionHintNICR The number of partial redemption hint NICR.\n     * @param _maxIterations The maximum number of iterations.\n     * @param _maxFeePercentage The maximum number of fee.\n     */\n    function redeemCollateral(\n        address _asset,\n        uint256 _debtTokenAmount,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        address _firstRedemptionHint,\n        uint256 _partialRedemptionHintNICR,\n        uint256 _maxIterations,\n        uint256 _maxFeePercentage\n    )\n        external;\n\n    /**\n     * @notice Find the right hints to pass to redeemCollateral().\n     *\n     * It simulates a redemption of `_debtTokenAmount` to figure out where the redemption sequence\n     * will start and what state the final TrenBox of the sequence will end up in.\n     *\n     * Returns three hints:\n     *  - `firstRedemptionHint` is the address of the first TrenBox with ICR >= MCR (i.e. the first\n     *      TrenBox that will be redeemed).\n     *  - `partialRedemptionHintNICR` is the final nominal ICR of the last TrenBox of the sequence\n     *      after being hit by partial redemption, or zero in case of no partial redemption.\n     *  - `truncatedDebtTokenAmount` is the maximum amount that can be redeemed out of the the\n     *      provided `_debtTokenAmount`. This can be lower than `_debtTokenAmount` when redeeming\n     *      the full amount would leave the last TrenBox of the redemption sequence with less net\n     * debt\n     *      than the minimum allowed value (i.e. IAdminContract(adminContract).MIN_NET_DEBT()).\n     *\n     * The number of TrenBoxes to consider for redemption can be capped by passing a non-zero value\n     * as `_maxIterations`, while passing zero will leave it uncapped.\n     */\n    function getRedemptionHints(\n        address _asset,\n        uint256 _debtTokenAmount,\n        uint256 _price,\n        uint256 _maxIterations\n    )\n        external\n        returns (\n            address firstRedemptionHint,\n            uint256 partialRedemptionHintNICR,\n            uint256 truncatedDebtTokenAmount\n        );\n\n    /**\n     * @notice Return address of a TrenBox that is, on average, (length /\n     * numTrials) positions away in the sortedTrenBoxes list from the correct insert position of the\n     * TrenBox to be inserted.\n     *\n     * Note: The output address is worst-case O(n) positions away from the correct insert position,\n     * however, the function is probabilistic.\n     * Input can be tuned to guarantee results to a high degree of confidence,\n     * e.g:\n     * Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the\n     * ouput address will be <= sqrt(length) positions away from the correct insert position.\n     */\n    function getApproxHint(\n        address _asset,\n        uint256 _CR,\n        uint256 _numTrials,\n        uint256 _inputRandomSeed\n    )\n        external\n        returns (address hintAddress, uint256 diff, uint256 latestRandomSeed);\n\n    /**\n     *\n     * @notice Return nominal collateral ratio.\n     * @param _coll The amount of collateral.\n     * @param _debt The amount of debt.\n     */\n    function computeNominalCR(uint256 _coll, uint256 _debt) external returns (uint256);\n}\n"
    },
    "contracts/Interfaces/ITrenBoxStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title ITrenBoxStorage\n * @notice Defines the basic interface for TrenBoxStorage contract.\n */\ninterface ITrenBoxStorage {\n    // ------------------------------------------ Structs -----------------------------------------\n\n    /// @dev Struct for storing debt balances of a specific collateral asset.\n    /// @param active The entire debt of all active TrenBoxes.\n    /// @param liquidated The entire debt of all liquidated TrenBoxes.\n    struct DebtBalances {\n        uint256 active;\n        uint256 liquidated;\n    }\n\n    /// @dev Struct for storing balances of a specific collateral asset.\n    /// @param active The entire collateral amount of all active TrenBoxes.\n    /// @param liquidated The entire collateral amount of all liquidated TrenBoxes.\n    /// @param claimable The entire collateral amount of all liquidated TrenBoxes that can be\n    /// claimed by user.\n    struct CollBalances {\n        uint256 active;\n        uint256 liquidated;\n        uint256 claimable;\n    }\n\n    // ------------------------------------------ Events ------------------------------------------\n\n    /**\n     * @dev Emitted when the active collateral balance is updated.\n     * @param _collateral The address of the collateral asset.\n     * @param _newBalance The new active collateral balance.\n     */\n    event ActiveCollateralBalanceUpdated(address indexed _collateral, uint256 _newBalance);\n\n    /**\n     * @dev Emitted when the active debt balance is updated.\n     * @param _collateral The address of the collateral asset.\n     * @param _newBalance The new active debt balance.\n     */\n    event ActiveDebtBalanceUpdated(address indexed _collateral, uint256 _newBalance);\n\n    /**\n     * @dev Emitted when the liquidated collateral balance is updated.\n     * @param _collateral The address of the collateral asset.\n     * @param _newBalance The new liquidated collateral balance.\n     */\n    event LiquidatedCollateralBalanceUpdated(address indexed _collateral, uint256 _newBalance);\n\n    /**\n     * @dev Emitted when the liquidated debt balance is updated.\n     * @param _collateral The address of the collateral asset.\n     * @param _newBalance The new liquidated debt balance.\n     */\n    event LiquidatedDebtBalanceUpdated(address indexed _collateral, uint256 _newBalance);\n\n    /**\n     * @dev Emitted when the claimable collateral balance is updated.\n     * @param _collateral The address of the collateral asset.\n     * @param _newBalance The new claimable collateral balance.\n     */\n    event ClaimableCollateralBalanceUpdated(address indexed _collateral, uint256 _newBalance);\n\n    /**\n     * @dev Emitted when collateral is sent.\n     * @param _to The address of the user which get collateral amount.\n     * @param _collateral The address of the collateral asset.\n     * @param _amount The amount of collateral sent.\n     */\n    event CollateralSent(address indexed _to, address indexed _collateral, uint256 _amount);\n\n    /**\n     * @dev Emitted when the user claimable collateral balance is updated.\n     * @param _account The address of the user.\n     * @param _collateral The address of the collateral asset.\n     * @param _newBalance The new user claimable collateral balance.\n     */\n    event UserClaimableCollateralBalanceUpdated(\n        address indexed _account, address indexed _collateral, uint256 _newBalance\n    );\n\n    // ------------------------------------------ Custom Errors -----------------------------------\n\n    /**\n     * @dev Thrown when contract is not authorized.\n     */\n    error TrenBoxStorage__NotAuthorizedContract();\n\n    /**\n     * @dev Thrown when caller is not TrenBoxManager contract.\n     */\n    error TrenBoxStorage__TrenBoxManagerOnly();\n\n    /**\n     * @dev Thrown when caller is not BorrowerOperations contract.\n     */\n    error TrenBoxStorage__BorrowerOperationsOnly();\n\n    /**\n     * @dev Thrown when caller is not BorrowerOperations nor TrenBoxManager contract.\n     */\n    error TrenBoxStorage__BorrowerOperationsOrTrenBoxManagerOnly();\n\n    /**\n     * @dev Thrown when caller is not TrenBoxManagerOperations contract.\n     */\n    error TrenBoxStorage__TrenBoxManagerOperationsOnly();\n\n    /**\n     * @dev Thrown when there is no claimable collateral available.\n     */\n    error TrenBoxStorage__NoClaimableCollateral();\n\n    // ------------------------------------------ Functions ---------------------------------------\n\n    /**\n     * @notice Returns the active collateral balance for a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     */\n    function getActiveCollateralBalance(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the active debt balance for a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     */\n    function getActiveDebtBalance(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the liquidated collateral balance for a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     */\n    function getLiquidatedCollateralBalance(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the liquidated debt balance for a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     */\n    function getLiquidatedDebtBalance(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns sum of active and liquidated debt for a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     */\n    function getTotalDebtBalance(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns sum of active and liquidated amount of a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     */\n    function getTotalCollateralBalance(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the claimable collateral balance for a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     */\n    function getClaimableCollateralBalance(address _collateral) external view returns (uint256);\n\n    /**\n     * @notice Returns the claimable collateral balance for a specific user.\n     * @param _collateral The address of the collateral asset.\n     * @param _account The address of the user.\n     */\n    function getUserClaimableCollateralBalance(\n        address _collateral,\n        address _account\n    )\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Increases the active debt balance for a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     * @param _amount The amount to increase the debt balance.\n     */\n    function increaseActiveDebt(address _collateral, uint256 _amount) external;\n\n    /**\n     * @notice Decreases the active debt balance for a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     * @param _amount The amount to decrease the debt balance.\n     */\n    function decreaseActiveDebt(address _collateral, uint256 _amount) external;\n\n    /**\n     * @notice Decreases the active balances of debt and collateral for a specific collateral after\n     * redemption exists.\n     * @param _collateral The address of the collateral asset.\n     * @param _debtAmount The amount to decrease the debt balance.\n     * @param _collAmount The amount to decrease the collateral balance.\n     */\n    function decreaseActiveBalancesAfterRedemption(\n        address _collateral,\n        uint256 _debtAmount,\n        uint256 _collAmount\n    )\n        external;\n\n    /**\n     * @notice Increases the active balance for a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     * @param _amount The amount to increase the debt balance.\n     */\n    function increaseActiveCollateral(address _collateral, uint256 _amount) external;\n\n    /**\n     * @notice Decreases the active balance for a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     * @param _amount The amount to decrease the collateral balance.\n     */\n    function decreaseActiveCollateral(address _collateral, uint256 _amount) external;\n\n    /**\n     * @notice Updates the active and liquidated debt and collateral balances.\n     * @param _collateral The address of the collateral asset.\n     * @param _debtAmount The amount to decrease the debt balance.\n     * @param _collAmount The amount to decrease the collateral balance.\n     * @param _isActiveIncrease The indicator that shows increasing or decreasing of active\n     * balances.\n     */\n    function updateDebtAndCollateralBalances(\n        address _collateral,\n        uint256 _debtAmount,\n        uint256 _collAmount,\n        bool _isActiveIncrease\n    )\n        external;\n\n    /**\n     * @notice Updates the entire and user claimable balance for a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     * @param _account The address of the user.\n     * @param _amount The amount to update the claimable balance.\n     */\n    function updateUserAndEntireClaimableBalance(\n        address _collateral,\n        address _account,\n        uint256 _amount\n    )\n        external;\n\n    /**\n     * @notice Increases the claimable collateral balance for a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     * @param _amount The amount to increase the claimable collateral balance.\n     */\n    function increaseClaimableCollateral(address _collateral, uint256 _amount) external;\n\n    /**\n     * @notice Updates the claimable collateral balance of the user for a specific collateral asset.\n     * @param _collateral The address of the collateral asset.\n     * @param _account The address of the user.\n     * @param _amount The amount to update the claimable balance.\n     */\n    function updateUserClaimableBalance(\n        address _collateral,\n        address _account,\n        uint256 _amount\n    )\n        external;\n\n    /**\n     * @notice Sends amount of active collateral from contract to user.\n     * @param _collateral The address of the collateral asset.\n     * @param _account The address of the user to send.\n     * @param _amount The amount of the collateral to send.\n     */\n    function sendCollateral(address _collateral, address _account, uint256 _amount) external;\n\n    /**\n     * @notice Sends amount of claimable collateral from contract to user.\n     * @param _collateral The address of the collateral asset.\n     * @param _account The address of the user to send.\n     */\n    function claimCollateral(address _collateral, address _account) external;\n}\n"
    },
    "contracts/Interfaces/ITRENStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface ITRENStaking {\n    struct Snapshot {\n        mapping(address asset => uint256 feeAmount) assetsFeeSnapshot;\n        uint256 debtTokenFeeSnapshot;\n    }\n\n    error TRENStaking__SetupAlreadyInitialized();\n    error TRENStaking__StakingOnPause();\n    error TRENStaking__InvalidAddresses();\n    error TRENStaking__InvalidAmount(uint256 zeroValue);\n    error TRENStaking__OnlyFeeCollector(address caller, address expected);\n    error TRENStaking__InvalidStakeAmount(uint256 zeroValue);\n\n    event SentAssetFeeToTreasury(address indexed _asset, uint256 _amount);\n    event StakeUpdated(address indexed _staker, uint256 _newStake);\n    event StakingAssetGainWithdrawn(\n        address indexed _staker, address indexed _asset, uint256 _assetGain\n    );\n\n    event StakingDebtTokenGainWithdrawn(address indexed _staker, uint256 _debtTokenAmount);\n    event AssetFeeUpdated(address indexed _asset, uint256 _amount);\n    event TotalDebtTokenFeeUpdated(uint256 _amount);\n    event TotalTRENStakedUpdated(uint256 _totalTRENStaked);\n    event SentAsset(address indexed _asset, address indexed _account, uint256 _amount);\n    event StakerSnapshotsUpdated(address _staker, uint256 _feeAsset, uint256 _feeDebtToken);\n\n    function increaseFeeAsset(address _asset, uint256 _feeAsset) external;\n    function increaseFeeDebtToken(uint256 _TRENFee) external;\n}\n"
    },
    "contracts/Interfaces/IUniswapRouterV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\npragma abicoder v2;\n\ninterface IUniswapRouterV3 {\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    function exactOutput(ExactOutputParams memory params) external returns (uint256 amountIn);\n}\n"
    },
    "contracts/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { OwnableUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { UUPSUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport { IPyth } from \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport { PythStructs } from \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\n\nimport { ConfigurableAddresses } from \"./Dependencies/ConfigurableAddresses.sol\";\n\nimport { IPriceFeed, ChainlinkAggregatorV3Interface } from \"./Interfaces/IPriceFeed.sol\";\nimport { API3ProxyInterface } from \"./Pricing/API3ProxyInterface.sol\";\n\n/**\n * @title PriceFeed\n * @notice Contains a directory of oracles for fetching prices for assets based on their addresses;\n * optionally fallback oracles can also be registered in case the primary source\n * fails or is stale.\n */\ncontract PriceFeed is IPriceFeed, OwnableUpgradeable, UUPSUpgradeable, ConfigurableAddresses {\n    /// @notice The contract name.\n    string public constant NAME = \"PriceFeed\";\n\n    /// @notice Used to convert an oracle price answer to an 18-digit precision uint\n    uint256 public constant TARGET_DIGITS = 18;\n\n    /// @notice The mapping from an asset address to primary oracle record.\n    mapping(address token => OracleRecord oracleRecord) public oracles;\n\n    /// @notice The mapping from an asset address to fallback oracle record.\n    mapping(address token => OracleRecord oracleRecord) public fallbacks;\n\n    // Initializer\n    // ------------------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Runs all the setup logic only once.\n     * @param initialOwner The address of initial owner.\n     */\n    function initialize(address initialOwner) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n    }\n\n    // Admin routines\n    // ---------------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IPriceFeed\n    function setOracle(\n        address _token,\n        address _oracle,\n        ProviderType _type,\n        uint256 _timeoutSeconds,\n        bool _isEthIndexed,\n        bool _isFallback,\n        bytes32 _additionalData\n    )\n        external\n        override\n    {\n        _requireOwnerOrTimelock(_token, _isFallback);\n        if (_isFallback && oracles[_token].oracleAddress == address(0)) {\n            // fallback setup requires an existing primary oracle for the asset\n            revert PriceFeed__ExistingOracleRequired();\n        }\n        uint256 decimals = _fetchDecimals(_oracle, _type);\n        if (decimals == 0) {\n            revert PriceFeed__InvalidDecimalsError();\n        }\n\n        if (_type == ProviderType.Pyth && _additionalData == bytes32(0)) {\n            revert PriceFeed__MissingPythFeedId();\n        }\n\n        OracleRecord memory newOracle = OracleRecord({\n            oracleAddress: _oracle,\n            providerType: _type,\n            timeoutSeconds: _timeoutSeconds,\n            decimals: decimals,\n            isEthIndexed: _isEthIndexed,\n            additionalData: _additionalData\n        });\n        uint256 price = _fetchOracleScaledPrice(newOracle);\n        if (price == 0) {\n            revert PriceFeed__InvalidOracleResponseError(_token);\n        }\n        if (_isFallback) {\n            fallbacks[_token] = newOracle;\n        } else {\n            oracles[_token] = newOracle;\n        }\n        emit NewOracleRegistered(_token, _oracle, _isEthIndexed, _isFallback);\n    }\n\n    // Public functions\n    // -------------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IPriceFeed\n    function fetchPrice(address _token) public view virtual returns (uint256) {\n        // Tries fetching the price from the oracle\n        OracleRecord memory oracle = oracles[_token];\n        uint256 price = _fetchOracleScaledPrice(oracle);\n        if (price != 0) {\n            return oracle.isEthIndexed ? _calcEthIndexedPrice(price) : price;\n        }\n        // If the oracle fails (and returns 0), try again with the fallback\n        oracle = fallbacks[_token];\n        price = _fetchOracleScaledPrice(oracle);\n        if (price != 0) {\n            return oracle.isEthIndexed ? _calcEthIndexedPrice(price) : price;\n        }\n        revert PriceFeed__InvalidOracleResponseError(_token);\n    }\n\n    // Internal functions\n    // -----------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Fetches the decimal precision of a specific oracle provider.\n     * @param _oracle The oracle address.\n     * @param _type The provider type.\n     */\n    function _fetchDecimals(address _oracle, ProviderType _type) internal view returns (uint8) {\n        if (ProviderType.Chainlink == _type) {\n            return ChainlinkAggregatorV3Interface(_oracle).decimals();\n        } else if (ProviderType.API3 == _type) {\n            return 18;\n        } else if (ProviderType.Pyth == _type) {\n            return 18;\n        }\n        return 0;\n    }\n\n    /**\n     * @dev Fetches the scaled price by target decimal based on oracle answer.\n     * @param oracle The oracle record information.\n     */\n    function _fetchOracleScaledPrice(OracleRecord memory oracle) internal view returns (uint256) {\n        uint256 oraclePrice = 0;\n        uint256 priceTimestamp = 0;\n\n        if (oracle.oracleAddress == address(0)) {\n            revert PriceFeed__UnknownAssetError();\n        }\n\n        if (ProviderType.Chainlink == oracle.providerType) {\n            (oraclePrice, priceTimestamp) = _fetchChainlinkOracleResponse(oracle.oracleAddress);\n        } else if (ProviderType.API3 == oracle.providerType) {\n            (oraclePrice, priceTimestamp) = _fetchAPI3OracleResponse(oracle.oracleAddress);\n        } else if (ProviderType.Pyth == oracle.providerType) {\n            (oraclePrice, priceTimestamp) =\n                _fetchPythOracleResponse(oracle.oracleAddress, oracle.additionalData);\n        }\n\n        if (oraclePrice != 0 && !_isStalePrice(priceTimestamp, oracle.timeoutSeconds)) {\n            return _scalePriceByDigits(oraclePrice, oracle.decimals);\n        }\n\n        return 0;\n    }\n\n    /**\n     * @dev Returns the flag to indicate if it is the latest or stale price.\n     * @param _priceTimestamp The latest timestamp the price was updated.\n     * @param _oracleTimeoutSeconds The maximum period that lasts a stale price.\n     */\n    function _isStalePrice(\n        uint256 _priceTimestamp,\n        uint256 _oracleTimeoutSeconds\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return block.timestamp - _priceTimestamp > _oracleTimeoutSeconds;\n    }\n\n    /**\n     * @dev Fetches the price and its updated timestamp from Chainlink oracle.\n     * @param _oracleAddress The address of Chainlink oracle.\n     */\n    function _fetchChainlinkOracleResponse(address _oracleAddress)\n        internal\n        view\n        returns (uint256 price, uint256 timestamp)\n    {\n        try ChainlinkAggregatorV3Interface(_oracleAddress).latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256, /* startedAt */\n            uint256 updatedAt,\n            uint80 /* answeredInRound */\n        ) {\n            if (roundId != 0 && updatedAt != 0 && answer != 0) {\n                price = uint256(answer);\n                timestamp = updatedAt;\n            }\n        } catch {\n            // If call to Chainlink aggregator reverts, return a zero response\n            price = 0;\n            timestamp = 0;\n        }\n    }\n\n    /**\n     * @dev Fetches the price and its updated timestamp from Pyth oracle.\n     * @param _oracleAddress The address of Pyth oracle.\n     */\n    function _fetchPythOracleResponse(\n        address _oracleAddress,\n        bytes32 _priceFeedId\n    )\n        internal\n        view\n        returns (uint256 price, uint256 timestamp)\n    {\n        IPyth pythOracle = IPyth(_oracleAddress);\n        PythStructs.Price memory pythResponse = pythOracle.getPriceUnsafe(_priceFeedId);\n\n        timestamp = pythResponse.publishTime;\n        price = (uint256(uint64(pythResponse.price)) * (10 ** 18))\n            / (10 ** uint8(uint32(-1 * pythResponse.expo)));\n    }\n\n    /**\n     * @dev Fetches the price and its updated timestamp from API3 oracle.\n     * @param _oracleAddress The address of API3 oracle.\n     */\n    function _fetchAPI3OracleResponse(address _oracleAddress)\n        internal\n        view\n        returns (uint256 price, uint256 timestamp)\n    {\n        (int224 _value, uint256 _timestamp) = API3ProxyInterface(_oracleAddress).read();\n        if (_value > 0) {\n            /// @dev negative check -> see API3ProxyInterface\n            price = uint256(int256(_value));\n            timestamp = _timestamp;\n        }\n    }\n\n    /**\n     * @dev Fetches the ETH:USD price (using the zero address as being the ETH asset), then\n     * multiplies it by the indexed price. Assumes an oracle has been set for that purpose.\n     * @param _ethAmount The asset price based on ETH.\n     */\n    function _calcEthIndexedPrice(uint256 _ethAmount) internal view returns (uint256) {\n        uint256 ethPrice = fetchPrice(address(0));\n        return (ethPrice * _ethAmount) / 1 ether;\n    }\n\n    /**\n     * @dev Scales oracle's response up/down to target precision; returns unaltered price\n     * if already on target digits.\n     * @param _price The fetched price.\n     * @param _priceDigits The price decimal.\n     */\n    function _scalePriceByDigits(\n        uint256 _price,\n        uint256 _priceDigits\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            if (_priceDigits > TARGET_DIGITS) {\n                return _price / (10 ** (_priceDigits - TARGET_DIGITS));\n            } else if (_priceDigits < TARGET_DIGITS) {\n                return _price * (10 ** (TARGET_DIGITS - _priceDigits));\n            }\n        }\n        return _price;\n    }\n\n    // Access control functions\n    // -----------------------------------------------------------------------------------------\n\n    /**\n     * @dev Requires the caller to be the contract owner when the oracle is first set. Subsequent\n     * updates need to come through the timelock contract.\n     * @param _token The asset address.\n     * @param _isFallback The flag to indicate whether to set as fallback oracle.\n     */\n    function _requireOwnerOrTimelock(address _token, bool _isFallback) internal view {\n        OracleRecord storage record = _isFallback ? fallbacks[_token] : oracles[_token];\n        if (record.oracleAddress == address(0)) {\n            _checkOwner();\n        } else if (msg.sender != timelockAddress) {\n            revert PriceFeed__TimelockOnlyError();\n        }\n    }\n\n    function authorizeUpgrade(address newImplementation) public {\n        _authorizeUpgrade(newImplementation);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner { }\n}\n"
    },
    "contracts/Pricing/API3ProxyInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/// @notice Interface for reading dAPI data feeds from https://market.api3.org/dapis\n/// @dev The proxy contracts are generalized to support most types of numerical\n/// data feeds. This means that the user of this proxy is expected to validate\n/// the read values according to the specific use-case. For example, `value` is\n/// a signed integer, yet it being negative may not make sense in the case that\n/// the data feed represents the spot price of an asset. In that case, the user\n/// is responsible with ensuring that `value` is not negative.\n/// In the case that the data feed is from a single source, `timestamp` is the\n/// system time of the Airnode when it signed the data. In the case that the\n/// data feed is from multiple sources, `timestamp` is the median of system\n/// times of the Airnodes when they signed the respective data. There are two\n/// points to consider while using `timestamp` in your contract logic: (1) It\n/// is based on the system time of the Airnodes, and not the block timestamp.\n/// This may be relevant when either of them drifts. (2) `timestamp` is an\n/// off-chain value that is being reported, similar to `value`. Both should\n/// only be trusted as much as the Airnode(s) that report them.\n///\n/// from https://vscode.blockscan.com/arbitrum-one/0x26690F9f17FdC26D419371315bc17950a0FC90eD\n\ninterface API3ProxyInterface {\n    function read() external view returns (int224 value, uint32 timestamp);\n}\n"
    },
    "contracts/Pricing/FixedPriceAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { AggregatorV3Interface } from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @dev This contract was created to serve as a price feed for the bLUSD-USD pair, fixed at a 1:1\n * rate.\n * Responses' roundId and updateTime will always be 2 minutes ago, while the previousRound will\n * be 5 min ago.\n */\ncontract FixedPriceAggregator is AggregatorV3Interface {\n    uint8 private constant DECIMALS_VAL = 8;\n    int256 private immutable PRICE;\n\n    constructor(int256 _price) {\n        PRICE = _price;\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return DECIMALS_VAL;\n    }\n\n    function description() external pure override returns (string memory) {\n        return \"FixedPriceAggregator\";\n    }\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        uint256 timestamp = block.timestamp - 5 minutes;\n        return (_roundId, PRICE, 0, timestamp, uint80(timestamp));\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        uint256 timestamp = block.timestamp - 2 minutes;\n        return (uint80(timestamp), PRICE, 0, timestamp, uint80(timestamp));\n    }\n\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n}\n"
    },
    "contracts/Pricing/PriceFeedL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { ChainlinkAggregatorV3Interface } from \"../Interfaces/IPriceFeed.sol\";\nimport { IPriceFeedL2 } from \"../Interfaces/IPriceFeedL2.sol\";\nimport { PriceFeed } from \"../PriceFeed.sol\";\n\ncontract PriceFeedL2 is IPriceFeedL2, PriceFeed {\n    // Constants\n    // --------------------------------------------------------------------------------------------------------\n\n    /// @dev after sequencer comes back up, wait for up to X seconds for openTrenBox, adjustTrenBox\n    /// & closeTrenBox\n    uint256 public constant SEQUENCER_BORROWING_DELAY_SECONDS = 3600;\n\n    /// @dev after sequencer comes back up, wait for up to X seconds for redemptions & liquidations\n    uint256 public constant SEQUENCER_LIQUIDATION_DELAY_SECONDS = 7200;\n\n    // State\n    // ------------------------------------------------------------------------------------------------------------\n\n    address public sequencerUptimeFeedAddress;\n\n    // Admin routines\n    // ---------------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Requires msg.sender to be the contract owner when the sequencer is first set. Subsequent\n     * updates need to come through the timelock contract.\n     */\n    function setSequencerUptimeFeedAddress(address _sequencerUptimeFeedAddress) external {\n        if (_sequencerUptimeFeedAddress == address(0)) {\n            revert PriceFeedL2__SequencerZeroAddress();\n        }\n\n        if (sequencerUptimeFeedAddress == address(0)) {\n            _checkOwner();\n        } else if (msg.sender != timelockAddress) {\n            revert PriceFeed__TimelockOnlyError();\n        }\n\n        sequencerUptimeFeedAddress = _sequencerUptimeFeedAddress;\n        emit SequencerUptimeFeedUpdated(_sequencerUptimeFeedAddress);\n    }\n\n    // Public functions\n    // -------------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Callers:\n     *   - BorrowerOperations.openTrenBox()\n     *   - BorrowerOperations.adjustTrenBox()\n     *   - BorrowerOperations.closeTrenBox()\n     *   - TrenBoxManagerOperations.liquidateTrenBoxes()\n     *   - TrenBoxManagerOperations.batchLiquidateTrenBoxes()\n     *   - TrenBoxManagerOperations.redeemCollateral()\n     */\n    function fetchPrice(address _token)\n        public\n        view\n        override(IPriceFeedL2, PriceFeed)\n        returns (uint256)\n    {\n        _checkSequencerUptimeFeed();\n        return super.fetchPrice(_token);\n    }\n\n    // Internal functions\n    // -----------------------------------------------------------------------------------------------\n\n    function _checkSequencerUptimeFeed() internal view {\n        if (sequencerUptimeFeedAddress != address(0)) {\n            // prettier-ignore\n            (\n                /* uint80 roundId */\n                ,\n                int256 answer,\n                /* uint256 startedAt */\n                ,\n                uint256 updatedAt,\n                /* uint80 answeredInRound */\n            ) = ChainlinkAggregatorV3Interface(sequencerUptimeFeedAddress).latestRoundData();\n\n            // answer == 0 -> sequencer is up\n            // answer == 1 -> sequencer is down\n            bool isSequencerUp = answer == 0;\n            if (!isSequencerUp) {\n                revert PriceFeedL2__SequencerDown();\n            }\n\n            uint256 delay;\n            if (msg.sender == trenBoxManagerOperations) {\n                // TrenBoxManagerOperations triggers liquidations and redemptions\n                delay = SEQUENCER_LIQUIDATION_DELAY_SECONDS;\n            } else {\n                delay = SEQUENCER_BORROWING_DELAY_SECONDS;\n            }\n            uint256 timeSinceSequencerUp = block.timestamp - updatedAt;\n            if (timeSinceSequencerUp <= delay) {\n                revert PriceFeedL2__SequencerGracePeriodNotOver();\n            }\n        }\n    }\n}\n"
    },
    "contracts/Pricing/SfrxEth2EthPriceAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { AggregatorV3Interface } from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @notice Returns the ETH price for 1 sfrxETH by multiplying the results from the sfrxETH:frxETH\n * and frxETH:ETH feeds.\n * Needs to be multiplied by the ETH:USD feed for the final price.\n */\ncontract SfrxEth2EthPriceAggregator is AggregatorV3Interface {\n    error NotImplementedException();\n    error sfrxEthToFrxEthZeroPrice();\n    error frxEthToEthZeroPrice();\n\n    int256 internal constant PRECISION = 1 ether;\n    AggregatorV3Interface public constant sfrxEth2FrxEthAggregator =\n        AggregatorV3Interface(0x98E5a52fB741347199C08a7a3fcF017364284431);\n    AggregatorV3Interface public constant frxEth2EthAggregator =\n        AggregatorV3Interface(0x5C3e80763862CB777Aa07BDDBcCE0123104e1c34);\n\n    // AggregatorV3Interface functions\n    // ----------------------------------------------------------------------------------\n\n    function decimals() external pure override returns (uint8) {\n        // both (unupgradeable) source aggregators use 18 decimals\n        return 18;\n    }\n\n    function description() external pure override returns (string memory) {\n        return \"SfrxEth2EthPriceAggregator\";\n    }\n\n    function getRoundData(\n        uint80 // roundId\n    )\n        external\n        pure\n        virtual\n        override\n        returns (\n            uint80, // roundId,\n            int256, // answer,\n            uint256, // startedAt,\n            uint256, // updatedAt,\n            uint80 // answeredInRound\n        )\n    {\n        // nondeterministic as there are two sources with different round ids\n        revert NotImplementedException();\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        (\n            uint80 roundId1,\n            int256 answer1,\n            uint256 startedAt1,\n            uint256 updatedAt1,\n            uint80 answeredInRound1\n        ) = sfrxEth2FrxEthAggregator.latestRoundData();\n\n        if (answer1 == 0) {\n            revert sfrxEthToFrxEthZeroPrice();\n        }\n\n        (\n            uint80 roundId2,\n            int256 answer2,\n            uint256 startedAt2,\n            uint256 updatedAt2,\n            uint80 answeredInRound2\n        ) = frxEth2EthAggregator.latestRoundData();\n\n        if (answer2 == 0) {\n            revert frxEthToEthZeroPrice();\n        }\n\n        answer = (answer1 * answer2) / PRECISION;\n\n        // for the round/time-related values, return the \"oldest\"\n        roundId = roundId1 < roundId2 ? roundId1 : roundId2;\n        startedAt = startedAt1 < startedAt2 ? startedAt1 : startedAt2;\n        updatedAt = updatedAt1 < updatedAt2 ? updatedAt1 : updatedAt2;\n        answeredInRound = answeredInRound1 < answeredInRound2 ? answeredInRound1 : answeredInRound2;\n    }\n\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n}\n"
    },
    "contracts/Pricing/WstEth2UsdPriceAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { AggregatorV3Interface } from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @dev Based on https://github.com/lidofinance/lido-dao/blob/master/contracts/0.6.12/WstETH.sol\n */\ninterface IWstETH {\n    function stEthPerToken() external view returns (uint256);\n}\n\n/**\n * @notice Returns the USD price for 1 wstETH.\n *\n * @dev Queries the wstETH token for its stETH value/rate; then queries the stETH:USD oracle for the\n * price, and multiplies the results.\n * There is a known (minor) issue with the getRoundData() function, where the historical\n * value for a previous round (price) can be queried from the feed, but the current st/wstEth\n * rate is used (instead of the historical pair);\n * we do not see that as a problem as this contract's return values are\n * supposed to be used in short-time context checks (and not for long-term\n * single-source-of-truth queries)\n */\ncontract WstEth2UsdPriceAggregator is AggregatorV3Interface {\n    error stEthZeroPrice();\n    error stEthPerTokenZero();\n\n    int256 internal constant PRECISION = 1 ether;\n\n    IWstETH public immutable wstETH;\n    AggregatorV3Interface public immutable stETH2USDAggregator;\n\n    constructor(address _wstETHAddress, address _stETH2USDAggregatorAddress) {\n        wstETH = IWstETH(_wstETHAddress);\n        stETH2USDAggregator = AggregatorV3Interface(_stETH2USDAggregatorAddress);\n    }\n\n    // AggregatorV3Interface functions\n    // ----------------------------------------------------------------------------------\n\n    function decimals() external view override returns (uint8) {\n        return stETH2USDAggregator.decimals();\n    }\n\n    function description() external pure override returns (string memory) {\n        return \"WstEth2UsdPriceAggregator\";\n    }\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        (roundId, answer, startedAt, updatedAt, answeredInRound) =\n            stETH2USDAggregator.getRoundData(_roundId);\n        answer = _stETH2wstETH(answer);\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        (roundId, answer, startedAt, updatedAt, answeredInRound) =\n            stETH2USDAggregator.latestRoundData();\n        answer = _stETH2wstETH(answer);\n    }\n\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n\n    // Internal/Helper functions\n    // ----------------------------------------------------------------------------------------\n\n    function _stETH2wstETH(int256 stETHValue) internal view returns (int256) {\n        if (stETHValue == 0) {\n            revert stEthZeroPrice();\n        }\n\n        int256 multiplier = int256(wstETH.stEthPerToken());\n        if (multiplier == 0) {\n            revert stEthPerTokenZero();\n        }\n        // wstETH.stEthPerToken() response has 18-digit precision, hence we need the denominator\n        // below\n        return (stETHValue * multiplier) / PRECISION;\n    }\n}\n"
    },
    "contracts/SortedTrenBoxes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { OwnableUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { UUPSUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport { ConfigurableAddresses } from \"./Dependencies/ConfigurableAddresses.sol\";\n\nimport { ISortedTrenBoxes } from \"./Interfaces/ISortedTrenBoxes.sol\";\nimport { ITrenBoxManager } from \"./Interfaces/ITrenBoxManager.sol\";\n\n/**\n * @title SortedTrenBoxes\n * @notice A sorted doubly linked list with nodes sorted in descending order.\n *\n * Nodes map to active TrenBoxes in the system - the ID property is the address of a TrenBox owner.\n * Nodes are ordered according to their current nominal individual collateral ratio (NICR),\n * which is like the ICR but without the price, i.e., just collateral / debt.\n *\n * The list optionally accepts insert position hints.\n *\n * @dev NICRs are computed dynamically at runtime, and not stored on the Node. This is because\n * NICRs of active TrenBoxes change dynamically as liquidation events occur.\n *\n * The list relies on the fact that liquidation events preserve ordering: a liquidation decreases\n * the NICRs of all active TrenBoxes, but maintains their order.\n * A node inserted based on current NICR will maintain the correct position,\n * relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not\n * changed.\n * Thus, Nodes remain sorted by current NICR.\n *\n * Nodes need only be re-inserted upon a TrenBox operation - when the owner adds or removes\n * collateral or debt to their position.\n *\n * The list is a modification of the following audited SortedDoublyLinkedList:\n * https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol\n *\n * Changes made in the Gravita implementation:\n *\n * - Keys have been removed from nodes\n *\n * - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR,\n * calculated at runtime.\n *   The list relies on the property that ordering by ICR is maintained as the ETH:USD price varies.\n *\n * - Public functions with parameters have been made internal to save gas, and given an external\n * wrapper function for external access\n */\ncontract SortedTrenBoxes is\n    OwnableUpgradeable,\n    UUPSUpgradeable,\n    ISortedTrenBoxes,\n    ConfigurableAddresses\n{\n    /// @notice The contract name.\n    string public constant NAME = \"SortedTrenBoxes\";\n    /// @notice The mapping from collateral asset to its Node list.\n    mapping(address collateral => TrenBoxesList orderedList) public trenBoxes;\n\n    // Modifiers\n    // ------------------------------------------------------------------------------------------------------\n\n    modifier onlyTrenBoxManager() {\n        if (msg.sender != trenBoxManager) {\n            revert SortedTrenBoxes__CallerMustBeTrenBoxManager();\n        }\n        _;\n    }\n\n    modifier onlyBorrowerOperationsOrTrenBoxManager() {\n        if (msg.sender != borrowerOperations && msg.sender != trenBoxManager) {\n            revert SortedTrenBoxes__CallerMustBeBorrowerOperationsOrTrenBoxManager();\n        }\n        _;\n    }\n\n    modifier hasNonZeroId(address _id) {\n        if (_id == address(0)) {\n            revert SortedTrenBoxes__IdCannotBeZeroAddress();\n        }\n        _;\n    }\n\n    modifier hasPositiveNICR(uint256 _NICR) {\n        if (_NICR == 0) {\n            revert SortedTrenBoxes__NICRMustBeGreaterThanZero();\n        }\n        _;\n    }\n\n    // Initializer\n    // ------------------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Runs all the setup logic only once.\n     * @param initialOwner The address of initial owner.\n     */\n    function initialize(address initialOwner) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n    }\n\n    // External/public functions\n    // --------------------------------------------------------------------------------------\n\n    /// @inheritdoc ISortedTrenBoxes\n    function insert(\n        address _asset,\n        address _id,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    )\n        external\n        override\n        onlyBorrowerOperationsOrTrenBoxManager\n    {\n        _insert(_asset, _id, _NICR, _prevId, _nextId);\n    }\n\n    /// @inheritdoc ISortedTrenBoxes\n    function remove(address _asset, address _id) external override onlyTrenBoxManager {\n        _remove(_asset, _id);\n    }\n\n    /// @inheritdoc ISortedTrenBoxes\n    function reInsert(\n        address _asset,\n        address _id,\n        uint256 _newNICR,\n        address _prevId,\n        address _nextId\n    )\n        external\n        override\n        onlyBorrowerOperationsOrTrenBoxManager\n    {\n        if (!contains(_asset, _id)) {\n            revert SortedTrenBoxes__ListDoesNotContainNode();\n        }\n\n        if (_newNICR == 0) {\n            revert SortedTrenBoxes__NICRMustBeGreaterThanZero();\n        }\n\n        _remove(_asset, _id);\n        _insert(_asset, _id, _newNICR, _prevId, _nextId);\n    }\n\n    /// @inheritdoc ISortedTrenBoxes\n    function contains(address _asset, address _id) public view override returns (bool) {\n        return trenBoxes[_asset].nodes[_id].exists;\n    }\n\n    /// @inheritdoc ISortedTrenBoxes\n    function isEmpty(address _asset) public view override returns (bool) {\n        return trenBoxes[_asset].size == 0;\n    }\n\n    /// @inheritdoc ISortedTrenBoxes\n    function getSize(address _asset) external view override returns (uint256) {\n        return trenBoxes[_asset].size;\n    }\n\n    /// @inheritdoc ISortedTrenBoxes\n    function getFirst(address _asset) external view override returns (address) {\n        return trenBoxes[_asset].head;\n    }\n\n    /// @inheritdoc ISortedTrenBoxes\n    function getLast(address _asset) external view override returns (address) {\n        return trenBoxes[_asset].tail;\n    }\n\n    /// @inheritdoc ISortedTrenBoxes\n    function getNext(address _asset, address _id) external view override returns (address) {\n        return trenBoxes[_asset].nodes[_id].nextId;\n    }\n\n    /// @inheritdoc ISortedTrenBoxes\n    function getPrev(address _asset, address _id) external view override returns (address) {\n        return trenBoxes[_asset].nodes[_id].prevId;\n    }\n\n    /// @inheritdoc ISortedTrenBoxes\n    function validInsertPosition(\n        address _asset,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    )\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _validInsertPosition(_asset, _NICR, _prevId, _nextId);\n    }\n\n    /// @inheritdoc ISortedTrenBoxes\n    function findInsertPosition(\n        address _asset,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    )\n        external\n        view\n        override\n        returns (address, address)\n    {\n        return _findInsertPosition(_asset, _NICR, _prevId, _nextId);\n    }\n\n    // Internal functions\n    // ---------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Adds a new Node to the list.\n     * @param _asset The address of collateral asset.\n     * @param _id The Node's id.\n     * @param _NICR The Node's NICR.\n     * @param _prevId The Id of previous node for the insert position.\n     * @param _nextId The Id of next node for the insert position.\n     */\n    function _insert(\n        address _asset,\n        address _id,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    )\n        internal\n        hasNonZeroId(_id)\n        hasPositiveNICR(_NICR)\n    {\n        TrenBoxesList storage assetData = trenBoxes[_asset];\n\n        if (_contains(assetData, _id)) {\n            revert SortedTrenBoxes__ListAlreadyContainsNode();\n        }\n\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (!_validInsertPosition(_asset, _NICR, prevId, nextId)) {\n            // Sender's hint was not a valid insert position\n            // Use sender's hint to find a valid insert position\n            (prevId, nextId) = _findInsertPosition(_asset, _NICR, prevId, nextId);\n        }\n\n        Node storage node = assetData.nodes[_id];\n        node.exists = true;\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // Insert as head and tail\n            assetData.head = _id;\n            assetData.tail = _id;\n        } else if (prevId == address(0)) {\n            // Insert before `prevId` as the head\n            node.nextId = assetData.head;\n            assetData.nodes[assetData.head].prevId = _id;\n            assetData.head = _id;\n        } else if (nextId == address(0)) {\n            // Insert after `nextId` as the tail\n            node.prevId = assetData.tail;\n            assetData.nodes[assetData.tail].nextId = _id;\n            assetData.tail = _id;\n        } else {\n            // Insert at insert position between `prevId` and `nextId`\n            node.nextId = nextId;\n            node.prevId = prevId;\n            assetData.nodes[prevId].nextId = _id;\n            assetData.nodes[nextId].prevId = _id;\n        }\n\n        assetData.size = assetData.size + 1;\n        emit NodeAdded(_asset, _id, _NICR);\n    }\n\n    /**\n     * @dev Removes a Node from the list.\n     * @param _asset The address of collateral asset.\n     * @param _id The Node's id.\n     */\n    function _remove(address _asset, address _id) internal {\n        TrenBoxesList storage assetData = trenBoxes[_asset];\n\n        if (!_contains(assetData, _id)) {\n            revert SortedTrenBoxes__ListDoesNotContainNode();\n        }\n\n        Node storage node = assetData.nodes[_id];\n        if (assetData.size > 1) {\n            // List contains more than a single node\n            if (_id == assetData.head) {\n                // The removed node is the head\n                // Set head to next node\n                assetData.head = node.nextId;\n                // Set prev pointer of new head to null\n                assetData.nodes[assetData.head].prevId = address(0);\n            } else if (_id == assetData.tail) {\n                // The removed node is the tail\n                // Set tail to previous node\n                assetData.tail = node.prevId;\n                // Set next pointer of new tail to null\n                assetData.nodes[assetData.tail].nextId = address(0);\n            } else {\n                // The removed node is neither the head nor the tail\n                // Set next pointer of previous node to the next node\n                assetData.nodes[node.prevId].nextId = node.nextId;\n                // Set prev pointer of next node to the previous node\n                assetData.nodes[node.nextId].prevId = node.prevId;\n            }\n        } else {\n            // List contains a single node\n            // Set the head and tail to null\n            assetData.head = address(0);\n            assetData.tail = address(0);\n        }\n\n        delete assetData.nodes[_id];\n        assetData.size = assetData.size - 1;\n        emit NodeRemoved(_asset, _id);\n    }\n\n    /**\n     * @dev Checks if the list contains a Node.\n     * @param _dataAsset The Node list.\n     * @param _id The Node's id.\n     */\n    function _contains(\n        TrenBoxesList storage _dataAsset,\n        address _id\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return _dataAsset.nodes[_id].exists;\n    }\n\n    /**\n     * @dev Checks if a pair of Nodes is a valid insertion point for\n     * a new Node with the given NICR.\n     * @param _asset The address of collateral asset.\n     * @param _NICR The Node's NICR.\n     * @param _prevId The Id of previous Node for the insert position.\n     * @param _nextId The Id of next Node for the insert position.\n     */\n    function _validInsertPosition(\n        address _asset,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    )\n        internal\n        view\n        returns (bool)\n    {\n        if (_prevId == address(0) && _nextId == address(0)) {\n            // `(null, null)` is a valid insert position if the list is empty\n            return isEmpty(_asset);\n        } else if (_prevId == address(0)) {\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\n            return trenBoxes[_asset].head == _nextId\n                && _NICR >= ITrenBoxManager(trenBoxManager).getNominalICR(_asset, _nextId);\n        } else if (_nextId == address(0)) {\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\n            return trenBoxes[_asset].tail == _prevId\n                && _NICR <= ITrenBoxManager(trenBoxManager).getNominalICR(_asset, _prevId);\n        } else {\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and\n            // `_NICR` falls between the two nodes' NICRs\n            return trenBoxes[_asset].nodes[_prevId].nextId == _nextId\n                && ITrenBoxManager(trenBoxManager).getNominalICR(_asset, _prevId) >= _NICR\n                && _NICR >= ITrenBoxManager(trenBoxManager).getNominalICR(_asset, _nextId);\n        }\n    }\n\n    /**\n     * @dev Descends the list (larger NICRs to smaller NICRs) to find a valid insert position.\n     * @param _asset The address of collateral asset.\n     * @param _NICR The Node's NICR.\n     * @param _startId The Id of Node to start descending the list from.\n     */\n    function _descendList(\n        address _asset,\n        uint256 _NICR,\n        address _startId\n    )\n        internal\n        view\n        returns (address, address)\n    {\n        TrenBoxesList storage assetData = trenBoxes[_asset];\n\n        // If `_startId` is the head, check if the insert position is before the head\n        if (\n            assetData.head == _startId\n                && _NICR >= ITrenBoxManager(trenBoxManager).getNominalICR(_asset, _startId)\n        ) {\n            return (address(0), _startId);\n        }\n\n        address prevId = _startId;\n        address nextId = assetData.nodes[prevId].nextId;\n\n        // Descend the list until we reach the end or until we find a valid insert position\n        while (prevId != address(0) && !_validInsertPosition(_asset, _NICR, prevId, nextId)) {\n            prevId = assetData.nodes[prevId].nextId;\n            nextId = assetData.nodes[prevId].nextId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /**\n     * @dev Ascends the list (smaller NICRs to larger NICRs) to find a valid insert position\n     * @param _asset The address of collateral asset.\n     * @param _NICR The Node's NICR.\n     * @param _startId The Id of Node to start ascending the list from.\n     */\n    function _ascendList(\n        address _asset,\n        uint256 _NICR,\n        address _startId\n    )\n        internal\n        view\n        returns (address, address)\n    {\n        TrenBoxesList storage assetData = trenBoxes[_asset];\n\n        // If `_startId` is the tail, check if the insert position is after the tail\n        if (\n            assetData.tail == _startId\n                && _NICR <= ITrenBoxManager(trenBoxManager).getNominalICR(_asset, _startId)\n        ) {\n            return (_startId, address(0));\n        }\n\n        address nextId = _startId;\n        address prevId = assetData.nodes[nextId].prevId;\n\n        // Ascend the list until we reach the end or until we find a valid insertion point\n        while (nextId != address(0) && !_validInsertPosition(_asset, _NICR, prevId, nextId)) {\n            nextId = assetData.nodes[nextId].prevId;\n            prevId = assetData.nodes[nextId].prevId;\n        }\n\n        return (prevId, nextId);\n    }\n\n    /**\n     * @dev Finds the insert position for a new Node with the given NICR.\n     * @param _asset The address of collateral asset.\n     * @param _NICR The Node's NICR.\n     * @param _prevId The Id of previous node for the insert position.\n     * @param _nextId The Id of next node for the insert position.\n     */\n    function _findInsertPosition(\n        address _asset,\n        uint256 _NICR,\n        address _prevId,\n        address _nextId\n    )\n        internal\n        view\n        returns (address, address)\n    {\n        address prevId = _prevId;\n        address nextId = _nextId;\n\n        if (prevId != address(0)) {\n            if (\n                !contains(_asset, prevId)\n                    || _NICR > ITrenBoxManager(trenBoxManager).getNominalICR(_asset, prevId)\n            ) {\n                // `prevId` does not exist anymore or now has a smaller NICR than the given NICR\n                prevId = address(0);\n            }\n        }\n\n        if (nextId != address(0)) {\n            if (\n                !contains(_asset, nextId)\n                    || _NICR < ITrenBoxManager(trenBoxManager).getNominalICR(_asset, nextId)\n            ) {\n                // `nextId` does not exist anymore or now has a larger NICR than the given NICR\n                nextId = address(0);\n            }\n        }\n\n        if (prevId == address(0) && nextId == address(0)) {\n            // No hint - descend list starting from head\n            return _descendList(_asset, _NICR, trenBoxes[_asset].head);\n        } else if (prevId == address(0)) {\n            // No `prevId` for hint - ascend list starting from `nextId`\n            return _ascendList(_asset, _NICR, nextId);\n        } else if (nextId == address(0)) {\n            // No `nextId` for hint - descend list starting from `prevId`\n            return _descendList(_asset, _NICR, prevId);\n        } else {\n            // Descend list starting from `prevId`\n            return _descendList(_asset, _NICR, prevId);\n        }\n    }\n\n    function authorizeUpgrade(address newImplementation) public {\n        _authorizeUpgrade(newImplementation);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner { }\n}\n"
    },
    "contracts/StabilityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuardUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { UUPSUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport { TrenBase } from \"./Dependencies/TrenBase.sol\";\nimport { TrenMath, DECIMAL_PRECISION } from \"./Dependencies/TrenMath.sol\";\n\nimport { IAdminContract } from \"./Interfaces/IAdminContract.sol\";\nimport { IStabilityPool } from \"./Interfaces/IStabilityPool.sol\";\nimport { IDebtToken } from \"./Interfaces/IDebtToken.sol\";\nimport { ICommunityIssuance } from \"./Interfaces/ICommunityIssuance.sol\";\nimport { ITrenBoxStorage } from \"./Interfaces/ITrenBoxStorage.sol\";\n\n/**\n * @title StabilityPool\n * @notice Holds debt tokens deposited by Stability Pool depositors.\n * @dev When a trenBox is liquidated, then depending on system conditions, some of its debt tokens\n * debt gets offset with\n * debt tokens in the Stability Pool: that is, the offset debt evaporates, and an equal amount of\n * debt tokens tokens in the Stability Pool is burned.\n *\n * Thus, a liquidation causes each depositor to receive a debt tokens loss, in proportion to their\n * deposit as a share of total deposits.\n * They also receive an Collateral gain, as the amount of collateral of the liquidated trenBox is\n * distributed among Stability depositors,\n * in the same proportion.\n *\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a\n * liquidation that depletes 40%\n * of the total debt tokens in the Stability Pool, depletes 40% of each deposit.\n *\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each\n * liquidation depletes the deposit,\n * multiplying it by some factor in range [0,1]\n *\n * --- IMPLEMENTATION ---\n *\n * We use a highly scalable method of tracking deposits and Collateral gains that has O(1)\n * complexity.\n *\n * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we\n * simply update two state variables:\n * a product P, and a sum S. These are kept track for each type of collateral.\n *\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all\n * depositors' compounded deposits\n * and accumulated Collateral amount gains over time, as liquidations occur, using just these two\n * variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n *\n * The formula for a depositor's accumulated Collateral amount gain is derived here:\n * https://github.com/liquity/dev/blob/main/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased\n * since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.\n *\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded\n * deposit and corresponding Collateral amount gain\n * can be calculated using the initial deposit, the depositor’s snapshots of P and S, and the\n * latest values of P and S.\n *\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral\n * amount gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they\n * receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n *\n * --- SCALE FACTOR ---\n *\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0\n * when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n *\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small\n * number in range [0,1]) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this\n * would break deposit tracking.\n *\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to\n * <1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n *\n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures\n * negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to\n * floor division is only on the\n * order of 1e-9.\n *\n * --- EPOCHS ---\n *\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However,\n * setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n *\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale =\n * 0, and increment the currentEpoch by 1.\n *\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n *\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n *\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch\n * snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been\n * depleted to 0.\n *\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal,\n * the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale\n * change, we define the compounded deposit\n * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion debt\n * tokens has depleted to < 1 debt token).\n *\n *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---\n *\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping\n * (scale -> S) is stored for each epoch.\n *\n * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in\n * which the deposit was non-zero and earned Collateral amount.\n *\n * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made\n * the deposit, using the Collateral amount gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n *\n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n *\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus\n * no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n *\n *        S_i-S_t + S_{i+1}\n *      .<--------.------------>\n *      .         .\n *      . S_i     .   S_{i+1}\n *   <--.-------->.<----------->\n *   S_t.         .\n *   <->.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n *\n * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain,\n * handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the\n * compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n *\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n *\n * Please see the implementation spec in the proof document, which closely follows on from the\n * compounded deposit / Collateral amount gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n *\n * --- TREN ISSUANCE TO STABILITY POOL DEPOSITORS ---\n *\n * An TREN issuance event occurs at every deposit operation, and every liquidation.\n *\n * All deposits earn a share of the issued TREN in proportion to the deposit as a share of total\n * deposits.\n *\n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\n *\n * We use the same mathematical product-sum approach to track TREN gains for depositors, where\n * 'G' is the sum corresponding to TREN gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due\n * to liquidations.\n */\ncontract StabilityPool is ReentrancyGuardUpgradeable, UUPSUpgradeable, TrenBase, IStabilityPool {\n    using SafeERC20 for IERC20;\n\n    /// @notice The contract name.\n    string public constant NAME = \"StabilityPool\";\n\n    /// @dev The tracker for debt tokens held in the pool. Changes when users deposit/withdraw,\n    /// and when TrenBox debt is offset.\n    uint256 internal totalDebtTokenDeposits;\n\n    /// @dev totalColl.tokens and totalColl.amounts should be the same length and\n    /// always be the same length as IAdminContract(adminContract).validCollaterals().\n    /// Anytime a new collateral is added to AdminContract, both lists are lengthened.\n    Colls internal totalColl;\n\n    /// @notice The mapping from depositor address to its deposit amount.\n    mapping(address depositor => uint256 amount) public deposits;\n\n    /**\n     * @notice The mapping maintains an entry for each depositor that tracks P, S, G, scale,\n     * and epoch.\n     * @dev depositor's snapshot is updated only when they deposit or withdraw from stability pool.\n     * depositSnapshots are used to allocate TREN rewards, calculate compoundedDepositAmount\n     * and to calculate how much Collateral amount the depositor is entitled to.\n     */\n    mapping(address depositor => Snapshots snapshot) public depositSnapshots;\n\n    /**\n     * @notice Product 'P': Running product by which to multiply an initial deposit, in order to\n     * find the current compounded deposit,\n     * after a series of liquidations have occurred, each of which cancel some debt tokens debt with\n     * the deposit.\n     *\n     * @dev During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n     */\n    uint256 public P;\n\n    /// @notice The unit factor to be used in scale increment.\n    uint256 public constant SCALE_FACTOR = 1e9;\n\n    /// @notice Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1.\n    uint128 public currentScale;\n\n    /// @notice With each offset that fully empties the Pool, the epoch is incremented by 1.\n    uint128 public currentEpoch;\n\n    /**\n     * @dev Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns\n     * an Collateral amount gain of ( d_t * [S - S_t] )/P_t,\n     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.\n     *\n     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\n     * - The inner mapping records the (scale => sum)\n     * - The middle mapping records (epoch => (scale => sum))\n     * - The outer mapping records (collateralType => (epoch => (scale => sum)))\n     */\n    mapping(\n        address collateral\n            => mapping(uint128 collateralType => mapping(uint128 epoch => uint256 sum))\n    ) public epochToScaleToSum;\n\n    /**\n     * @dev Similarly, the sum 'G' is used to calculate TREN gains. During it's lifetime,\n     * each deposit d_t earns a TREN gain of\n     * ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t\n     * when the deposit was made.\n     *\n     * TREN reward events occur are triggered by depositor operations (new deposit, topup,\n     * withdrawal), and liquidations.\n     * In each case, the TREN reward is issued (i.e. G is updated), before other state changes are\n     * made.\n     */\n    mapping(uint128 epoch => mapping(uint128 scale => uint256 G)) public epochToScaleToG;\n\n    /// @notice The tracker for the error correction in the TREN issuance calculation.\n    uint256 public lastTRENError;\n\n    /// @notice The trackers for the error correction in the offset calculation.\n    uint256[] public lastAssetError_Offset;\n\n    /// @notice The tracker for the error correction in the calculation of debt token loss.\n    uint256 public lastDebtTokenLossError_Offset;\n\n    // --- Modifiers ---\n\n    modifier onlyAdminContract() {\n        if (msg.sender != adminContract) {\n            revert StabilityPool__AdminContractOnly(msg.sender, adminContract);\n        }\n        _;\n    }\n\n    modifier onlyTrenBoxStorage() {\n        if (msg.sender != trenBoxStorage) {\n            revert StabilityPool__TrenBoxStorageOnly(msg.sender, trenBoxStorage);\n        }\n        _;\n    }\n\n    modifier onlyTrenBoxManager() {\n        if (msg.sender != trenBoxManager) {\n            revert StabilityPool__TrenBoxManagerOnly(msg.sender, trenBoxManager);\n        }\n        _;\n    }\n\n    // --- Initializer ---\n\n    /**\n     * @dev Runs all the setup logic only once.\n     * @param initialOwner The address of initial owner.\n     */\n    function initialize(address initialOwner) external initializer {\n        __Ownable_init(initialOwner);\n        __ReentrancyGuard_init();\n        __UUPSUpgradeable_init();\n        P = DECIMAL_PRECISION;\n    }\n\n    /// @inheritdoc IStabilityPool\n    function getCollateral(address _collateral) external view override returns (uint256) {\n        uint256 collateralIndex = IAdminContract(adminContract).getIndex(_collateral);\n        return totalColl.amounts[collateralIndex];\n    }\n\n    /// @inheritdoc IStabilityPool\n    function getAllCollateral()\n        external\n        view\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        return (totalColl.tokens, totalColl.amounts);\n    }\n\n    /// @inheritdoc IStabilityPool\n    function getTotalDebtTokenDeposits() external view override returns (uint256) {\n        return totalDebtTokenDeposits;\n    }\n\n    /// @inheritdoc IStabilityPool\n    function getDepositorGains(\n        address _depositor,\n        address[] memory _assets\n    )\n        public\n        view\n        returns (address[] memory, uint256[] memory)\n    {\n        uint256 initialDeposit = deposits[_depositor];\n\n        if (initialDeposit == 0) {\n            address[] memory emptyAddress = new address[](0);\n            uint256[] memory emptyUint = new uint256[](0);\n            return (emptyAddress, emptyUint);\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256[] memory amountsFromNewGains =\n            _calculateNewGains(initialDeposit, snapshots, _assets);\n        return (_assets, amountsFromNewGains);\n    }\n\n    /// @inheritdoc IStabilityPool\n    function getDepositorTRENGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor];\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n        return _getTRENGainFromSnapshots(initialDeposit, snapshots);\n    }\n\n    /// @inheritdoc IStabilityPool\n    function getCompoundedDebtTokenDeposits(address _depositor)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 initialDeposit = deposits[_depositor];\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        return _getCompoundedStakeFromSnapshots(initialDeposit, depositSnapshots[_depositor]);\n    }\n\n    /**\n     * @notice Returns the specific collateral gain for a specific depositor.\n     * @param _depositor The depositor address.\n     * @param _asset The address of collateral asset.\n     */\n    function S(address _depositor, address _asset) external view returns (uint256) {\n        return depositSnapshots[_depositor].S[_asset];\n    }\n\n    // --- External Depositor Functions ---\n\n    /// @inheritdoc IStabilityPool\n    function addCollateralType(address _collateral) external onlyAdminContract {\n        lastAssetError_Offset.push(0);\n        totalColl.tokens.push(_collateral);\n        totalColl.amounts.push(0);\n    }\n\n    /// @inheritdoc IStabilityPool\n    function provideToSP(\n        uint256 _amount,\n        address[] calldata _assets\n    )\n        external\n        override\n        nonReentrant\n    {\n        _requireNonZeroAmount(_amount);\n\n        uint256 initialDeposit = deposits[msg.sender];\n\n        _triggerTRENIssuance();\n\n        (address[] memory gainAssets, uint256[] memory gainAmounts) =\n            getDepositorGains(msg.sender, _assets);\n        uint256 compoundedDeposit = getCompoundedDebtTokenDeposits(msg.sender);\n        uint256 loss = initialDeposit - compoundedDeposit; // Needed only for event log\n\n        // First pay out any TREN gains\n        _payOutTRENGains(msg.sender);\n\n        // just pulls debtTokens into the pool, updates totalDeposits variable for the stability\n        // pool and throws an event\n        _sendToStabilityPool(msg.sender, _amount);\n\n        uint256 newDeposit = compoundedDeposit + _amount;\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        // loss required for event log\n        emit GainsWithdrawn(msg.sender, gainAssets, gainAmounts, loss);\n\n        // send any collateral gains accrued to the depositor\n        _sendGainsToDepositor(msg.sender, gainAssets, gainAmounts);\n    }\n\n    /// @inheritdoc IStabilityPool\n    function withdrawFromSP(uint256 _amount, address[] calldata _assets) external nonReentrant {\n        (address[] memory assets, uint256[] memory amounts) = _withdrawFromSP(_amount, _assets);\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n\n    // --- Liquidation functions ---\n\n    /// @inheritdoc IStabilityPool\n    function offset(\n        uint256 _debtToOffset,\n        address _asset,\n        uint256 _amountAdded\n    )\n        external\n        onlyTrenBoxManager\n    {\n        // cached to save an SLOAD\n        uint256 cachedTotalDebtTokenDeposits = totalDebtTokenDeposits;\n        if (cachedTotalDebtTokenDeposits == 0 || _debtToOffset == 0) {\n            return;\n        }\n        _triggerTRENIssuance();\n        (uint256 collGainPerUnitStaked, uint256 debtLossPerUnitStaked) =\n        _computeRewardsPerUnitStaked(\n            _asset, _amountAdded, _debtToOffset, cachedTotalDebtTokenDeposits\n        );\n\n        // updates S and P\n        _updateRewardSumAndProduct(_asset, collGainPerUnitStaked, debtLossPerUnitStaked);\n        _moveOffsetCollAndDebt(_asset, _amountAdded, _debtToOffset);\n    }\n\n    /**\n     * @dev Withdraws debt tokens from the stability pool.\n     * @param _amount The amount of debt tokens to withdraw\n     * @param _assets The array of collateral assets to be claimed.\n     */\n    function _withdrawFromSP(\n        uint256 _amount,\n        address[] calldata _assets\n    )\n        internal\n        returns (address[] memory assets, uint256[] memory amounts)\n    {\n        uint256 initialDeposit = deposits[msg.sender];\n        _requireUserHasDeposit(initialDeposit);\n\n        _triggerTRENIssuance();\n\n        (assets, amounts) = getDepositorGains(msg.sender, _assets);\n\n        uint256 compoundedDeposit = getCompoundedDebtTokenDeposits(msg.sender);\n\n        uint256 debtTokensToWithdraw = TrenMath._min(_amount, compoundedDeposit);\n        uint256 loss = initialDeposit - compoundedDeposit; // Needed only for event log\n\n        // First pay out any TREN gains\n        _payOutTRENGains(msg.sender);\n        _sendToDepositor(msg.sender, debtTokensToWithdraw);\n\n        // Update deposit\n        uint256 newDeposit = compoundedDeposit - debtTokensToWithdraw;\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit GainsWithdrawn(msg.sender, assets, amounts, loss); // loss required for event log\n    }\n\n    // --- TREN issuance functions ---\n\n    /**\n     * @dev Triggers a TREN issuance shared between all depositors.\n     */\n    function _triggerTRENIssuance() internal {\n        if (communityIssuance != address(0)) {\n            uint256 TRENIssuance = ICommunityIssuance(communityIssuance).issueTREN();\n            _updateG(TRENIssuance);\n        }\n    }\n\n    /**\n     * @dev Updates the sum of TREN gains.\n     * @param _TRENIssuance The TREN issuance.\n     */\n    function _updateG(uint256 _TRENIssuance) internal {\n        uint256 cachedTotalDebtTokenDeposits = totalDebtTokenDeposits; // cached to save an SLOAD\n        /*\n        * When total deposits is 0, G is not updated. In this case, the TREN issued can not be\n        obtained by later\n        * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance\n        contract.\n         *\n         */\n        if (cachedTotalDebtTokenDeposits == 0 || _TRENIssuance == 0) {\n            return;\n        }\n        uint256 TRENPerUnitStaked =\n            _computeTRENPerUnitStaked(_TRENIssuance, cachedTotalDebtTokenDeposits);\n        uint256 marginalTRENGain = TRENPerUnitStaked * P;\n        uint256 newEpochToScaleToG = epochToScaleToG[currentEpoch][currentScale];\n        newEpochToScaleToG += marginalTRENGain;\n        epochToScaleToG[currentEpoch][currentScale] = newEpochToScaleToG;\n        emit GainsUpdated(newEpochToScaleToG, currentEpoch, currentScale);\n    }\n\n    /**\n     * @dev Calculates the TREN-per-unit staked. Division uses a \"feedback\" error correction,\n     * to keep the cumulative error low in the running total G:\n     *\n     * 1) Form a numerator which compensates for the floor division error that occurred the last\n     * time this function was called.\n     * 2) Calculate \"per-unit-staked\" ratio.\n     * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n     * 4) Store this error for use in the next correction when this function is called.\n     * 5) Note: static analysis tools complain about this \"division before multiplication\",\n     * however, it is intended.\n     * @param _TRENIssuance The TREN issuance.\n     * @param _totalDeposits The total depositors.\n     */\n    function _computeTRENPerUnitStaked(\n        uint256 _TRENIssuance,\n        uint256 _totalDeposits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 TRENNumerator = (_TRENIssuance * DECIMAL_PRECISION) + lastTRENError;\n        uint256 TRENPerUnitStaked = TRENNumerator / _totalDeposits;\n        lastTRENError = TRENNumerator - (TRENPerUnitStaked * _totalDeposits);\n        return TRENPerUnitStaked;\n    }\n\n    // --- Offset helper functions ---\n\n    /**\n     * @dev Computes the debtToken and Collateral amount rewards. Uses a \"feedback\" error\n     * correction, to keep\n     * the cumulative error in the P and S state variables low:\n     *\n     * 1) Form numerators which compensate for the floor division errors that occurred the last\n     * time this function was called.\n     * 2) Calculate \"per-unit-staked\" ratios.\n     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n     * 4) Store these errors for use in the next correction when this function is called.\n     * 5) Note: static analysis tools complain about this \"division before multiplication\", however,\n     * it is intended.\n     * @param _asset The address of collateral asset.\n     * @param _amountAdded The amount of collateral asset to be added.\n     * @param _debtToOffset The amount of debt tokens to offset.\n     * @param _totalDeposits The total depositors.\n     */\n    function _computeRewardsPerUnitStaked(\n        address _asset,\n        uint256 _amountAdded,\n        uint256 _debtToOffset,\n        uint256 _totalDeposits\n    )\n        internal\n        returns (uint256 collGainPerUnitStaked, uint256 debtLossPerUnitStaked)\n    {\n        uint256 assetIndex = IAdminContract(adminContract).getIndex(_asset);\n        uint256 collateralNumerator =\n            (_amountAdded * DECIMAL_PRECISION) + lastAssetError_Offset[assetIndex];\n        if (_debtToOffset > _totalDeposits) {\n            revert StabilityPool__DebtLargerThanTotalDeposits();\n        }\n\n        if (_debtToOffset == _totalDeposits) {\n            debtLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each\n                // deposit\n            lastDebtTokenLossError_Offset = 0;\n        } else {\n            uint256 lossNumerator =\n                (_debtToOffset * DECIMAL_PRECISION) - lastDebtTokenLossError_Offset;\n            /*\n            * Add 1 to make error in quotient positive. We want \"slightly too much\" loss,\n            * which ensures the error in any given compoundedDeposit favors the Stability Pool.\n             */\n            debtLossPerUnitStaked = (lossNumerator / _totalDeposits) + 1;\n            lastDebtTokenLossError_Offset = (debtLossPerUnitStaked * _totalDeposits) - lossNumerator;\n        }\n        collGainPerUnitStaked = collateralNumerator / _totalDeposits;\n        lastAssetError_Offset[assetIndex] =\n            collateralNumerator - (collGainPerUnitStaked * _totalDeposits);\n    }\n\n    /**\n     * @dev Updates S and P.\n     * @param _asset The address of collateral asset.\n     * @param _collGainPerUnitStaked The collateral gain per unit staked.\n     * @param _debtLossPerUnitStaked The debt loss per unit staked.\n     */\n    function _updateRewardSumAndProduct(\n        address _asset,\n        uint256 _collGainPerUnitStaked,\n        uint256 _debtLossPerUnitStaked\n    )\n        internal\n    {\n        if (_debtLossPerUnitStaked > DECIMAL_PRECISION) {\n            revert StabilityPool__DebtLossBelowOne(_debtLossPerUnitStaked);\n        }\n\n        uint256 currentP = P;\n        uint256 newP;\n\n        /*\n        * The newProductFactor is the factor by which to change all deposits, due to the depletion\n        of Stability Pool debt tokens in the liquidation.\n        * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 -\n        _debtLossPerUnitStaked)\n         */\n        uint256 newProductFactor = DECIMAL_PRECISION - _debtLossPerUnitStaked;\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentS = epochToScaleToSum[_asset][currentEpochCached][currentScaleCached];\n\n        /*\n         * Calculate the new S first, before we update P.\n        * The asset gain for any given depositor from a liquidation depends on the value of their\n        deposit\n        * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the\n        liquidation.\n         *\n         * Since S corresponds to asset gain, and P to deposit loss, we update S first.\n         */\n        uint256 marginalAssetGain = _collGainPerUnitStaked * currentP;\n        uint256 newS = currentS + marginalAssetGain;\n        epochToScaleToSum[_asset][currentEpochCached][currentScaleCached] = newS;\n        emit SumUpdated(_asset, newS, currentEpochCached, currentScaleCached);\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpochCached += 1;\n            currentEpoch = currentEpochCached;\n            emit EpochUpdated(currentEpochCached);\n            currentScale = 0;\n            emit ScaleUpdated(0);\n            newP = DECIMAL_PRECISION;\n\n            // If multiplying P by a non-zero product factor would reduce P below the scale\n            // boundary, increment the scale\n        } else {\n            uint256 mulCached = currentP * newProductFactor;\n            uint256 mulDivCached = mulCached / DECIMAL_PRECISION;\n\n            if (mulDivCached < SCALE_FACTOR) {\n                newP = (mulCached * SCALE_FACTOR) / DECIMAL_PRECISION;\n                currentScaleCached += 1;\n                currentScale = currentScaleCached;\n                emit ScaleUpdated(currentScaleCached);\n            } else {\n                newP = mulDivCached;\n            }\n        }\n\n        if (newP == 0) {\n            revert StabilityPool__ProductZero();\n        }\n\n        P = newP;\n        emit ProductUpdated(newP);\n    }\n\n    /**\n     * @dev Moves offset collateral and debt between pools.\n     * Cancels the liquidated debt with the debt tokens in the stability pool,\n     * Burns the debt that was successfully offset. Collateral is moved from\n     * the TrenBoxStorage to this contract.\n     * @param _asset The address of collateral asset.\n     * @param _amount The amount of collateral asset.\n     * @param _debtToOffset The amount of debt tokens to offset.\n     */\n    function _moveOffsetCollAndDebt(\n        address _asset,\n        uint256 _amount,\n        uint256 _debtToOffset\n    )\n        internal\n    {\n        ITrenBoxStorage(trenBoxStorage).decreaseActiveDebt(_asset, _debtToOffset);\n        _decreaseDebtTokens(_debtToOffset);\n        IDebtToken(debtToken).burn(address(this), _debtToOffset);\n        ITrenBoxStorage(trenBoxStorage).sendCollateral(_asset, address(this), _amount);\n    }\n\n    function _decreaseDebtTokens(uint256 _amount) internal {\n        uint256 newTotalDeposits = totalDebtTokenDeposits - _amount;\n        totalDebtTokenDeposits = newTotalDeposits;\n        emit StabilityPoolDebtTokenBalanceUpdated(newTotalDeposits);\n    }\n\n    // --- Reward calculator functions for depositor ---\n\n    /**\n     * @dev Gets gains on each possible asset by looping through assets with\n     * _getGainFromSnapshots function.\n     * @param _initialDeposit The amount of initial deposit.\n     * @param _snapshots The snapshot storage.\n     * @param _assets The ascending ordered array of assets to calculate and claim gains.\n     */\n    function _calculateNewGains(\n        uint256 _initialDeposit,\n        Snapshots storage _snapshots,\n        address[] memory _assets\n    )\n        internal\n        view\n        returns (uint256[] memory amounts)\n    {\n        uint256 assetsLen = _assets.length;\n        _uniqueAddresses(_assets);\n        amounts = new uint256[](assetsLen);\n        for (uint256 i = 0; i < assetsLen;) {\n            amounts[i] = _getGainFromSnapshots(_initialDeposit, _snapshots, _assets[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Checks if the asset list is in ascending order.\n     */\n    function _uniqueAddresses(address[] memory _assets) private pure {\n        for (uint256 i = 0; i < _assets.length;) {\n            for (uint256 j = i + 1; j < _assets.length;) {\n                if (_assets[i] == _assets[j]) {\n                    revert StabilityPool__ArrayNotInAscendingOrder();\n                }\n                unchecked {\n                    ++j;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Gets the gain in S for a given asset for a user who made initial deposit.\n     * Grabs the sum 'S' from the epoch at which the stake was made. The Collateral amount gain\n     * may span up to one scale change.\n     * If it does, the second portion of the Collateral amount gain is scaled by 1e9.\n     * If the gain spans no scale change, the second portion will be 0.\n     * @param _initialDeposit The amount of initial deposit.\n     * @param _snapshots The snapshot storage.\n     * @param _asset The collateral asset to gain snapshot.\n     */\n    function _getGainFromSnapshots(\n        uint256 _initialDeposit,\n        Snapshots storage _snapshots,\n        address _asset\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 S_Snapshot = _snapshots.S[_asset];\n        uint256 P_Snapshot = _snapshots.P;\n\n        mapping(uint128 => uint256) storage scaleToSum = epochToScaleToSum[_asset][_snapshots.epoch];\n        uint256 firstPortion = scaleToSum[_snapshots.scale] - S_Snapshot;\n        uint256 secondPortion = scaleToSum[_snapshots.scale + 1] / SCALE_FACTOR;\n\n        uint256 assetGain =\n            (_initialDeposit * (firstPortion + secondPortion)) / P_Snapshot / DECIMAL_PRECISION;\n\n        return assetGain;\n    }\n\n    /**\n     * @dev Gets the TREN gain for initial stake.\n     * Grabs the sum 'G' from the epoch at which the stake was made. The TREN gain may span up to\n     * one scale change.\n     * If it does, the second portion of the TREN gain is scaled by 1e9.\n     * If the gain spans no scale change, the second portion will be 0.\n     * @param _initialStake The amount of initial stake.\n     * @param _snapshots The snapshot storage.\n     */\n    function _getTRENGainFromSnapshots(\n        uint256 _initialStake,\n        Snapshots storage _snapshots\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint128 epochSnapshot = _snapshots.epoch;\n        uint128 scaleSnapshot = _snapshots.scale;\n        uint256 G_Snapshot = _snapshots.G;\n        uint256 P_Snapshot = _snapshots.P;\n\n        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot] - G_Snapshot;\n        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot + 1] / SCALE_FACTOR;\n\n        uint256 TRENGain =\n            (_initialStake * (firstPortion + secondPortion)) / P_Snapshot / DECIMAL_PRECISION;\n\n        return TRENGain;\n    }\n\n    // --- Compounded deposit and compounded System stake ---\n\n    /**\n     * @dev Calculates the compounded deposits and compounded stakes.\n     * @param _initialStake The amount of initial stake.\n     * @param _snapshots The snapshot storage.\n     */\n    function _getCompoundedStakeFromSnapshots(\n        uint256 _initialStake,\n        Snapshots storage _snapshots\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshot_P = _snapshots.P;\n        uint128 scaleSnapshot = _snapshots.scale;\n        uint128 epochSnapshot = _snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with\n        // debt -- so, return 0\n        if (epochSnapshot < currentEpoch) {\n            return 0;\n        }\n\n        uint256 compoundedStake;\n        uint128 scaleDiff = currentScale - scaleSnapshot;\n\n        /* Compute the compounded stake. If a scale change in P was made during the stake's\n        lifetime,\n        * account for it. If more than one scale change was made, then the stake has decreased by a\n        factor of\n         * at least 1e-9 -- so return 0.\n         */\n        if (scaleDiff == 0) {\n            compoundedStake = (_initialStake * P) / snapshot_P;\n        } else if (scaleDiff == 1) {\n            compoundedStake = (_initialStake * P) / snapshot_P / SCALE_FACTOR;\n        } else {\n            compoundedStake = 0;\n        }\n\n        /*\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\n         *\n        * NOTE: originally, this line was in place to stop rounding errors making the deposit too\n        large. However, the error\n        * corrections should ensure the error in P \"favors the Pool\", i.e. any given compounded\n        deposit should slightly less\n         * than it's theoretical value.\n         *\n         * Thus it's unclear whether this line is still really needed.\n         */\n        if (compoundedStake < _initialStake / 1e9) {\n            return 0;\n        }\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for debtToken deposits\n\n    /**\n     * @dev Transfers the tokens from the user to the Stability Pool, and update its\n     * recorded deposits.\n     * @param _address The depositor address.\n     * @param _amount The deposit amount.\n     */\n    function _sendToStabilityPool(address _address, uint256 _amount) internal {\n        IDebtToken(debtToken).sendToPool(_address, address(this), _amount);\n        uint256 newTotalDeposits = totalDebtTokenDeposits + _amount;\n        totalDebtTokenDeposits = newTotalDeposits;\n        emit StabilityPoolDebtTokenBalanceUpdated(newTotalDeposits);\n    }\n\n    /**\n     * @dev Transfers collateral gains to the depositor. This function also unwraps wrapped assets\n     * before sending to depositor.\n     * @param _to The depositor address to receive gains.\n     * @param _assets The address array of collateral assets.\n     * @param _amounts The amount array of collateral assets.\n     */\n    function _sendGainsToDepositor(\n        address _to,\n        address[] memory _assets,\n        uint256[] memory _amounts\n    )\n        internal\n    {\n        uint256 assetsLen = _assets.length;\n\n        if (assetsLen != _amounts.length) {\n            revert StabilityPool__AssetsAndAmountsLengthMismatch();\n        }\n\n        for (uint256 i = 0; i < assetsLen;) {\n            uint256 amount = _amounts[i];\n            if (amount == 0) {\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n            address asset = _assets[i];\n            // Assumes we're internally working only with the wrapped version of ERC20 tokens\n            IERC20(asset).safeTransfer(_to, amount);\n            unchecked {\n                ++i;\n            }\n        }\n        totalColl.amounts = _leftSubColls(totalColl, _assets, _amounts);\n    }\n\n    /**\n     * @dev Sends debt tokens to user and decrease deposits in Pool.\n     * @param _depositor The depositor address.\n     * @param _debtTokenWithdrawal The amount of debt tokens to withdraw.\n     */\n    function _sendToDepositor(address _depositor, uint256 _debtTokenWithdrawal) internal {\n        if (_debtTokenWithdrawal == 0) {\n            return;\n        }\n        IDebtToken(debtToken).returnFromPool(address(this), _depositor, _debtTokenWithdrawal);\n        _decreaseDebtTokens(_debtTokenWithdrawal);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    /**\n     * @dev Updates deposit and snapshots internally.\n     * if _newValue is zero, delete snapshot for given _depositor and emit event\n     * otherwise, add an entry or update existing entry for _depositor in the depositSnapshots\n     * with current values for P, S, G, scale and epoch and then emit event.\n     * @param _depositor The depositor address\n     * @param _newValue The new deposit amount.\n     */\n    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {\n        deposits[_depositor] = _newValue;\n        address[] memory colls = IAdminContract(adminContract).getValidCollateral();\n        uint256 collsLen = colls.length;\n\n        Snapshots storage depositorSnapshots = depositSnapshots[_depositor];\n        if (_newValue == 0) {\n            for (uint256 i = 0; i < collsLen;) {\n                depositSnapshots[_depositor].S[colls[i]] = 0;\n                unchecked {\n                    i++;\n                }\n            }\n            depositorSnapshots.P = 0;\n            depositorSnapshots.G = 0;\n            depositorSnapshots.epoch = 0;\n            depositorSnapshots.scale = 0;\n            emit DepositSnapshotUpdated(_depositor, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        for (uint256 i = 0; i < collsLen;) {\n            address asset = colls[i];\n            uint256 currentS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];\n            depositSnapshots[_depositor].S[asset] = currentS;\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n        depositorSnapshots.P = currentP;\n        depositorSnapshots.G = currentG;\n        depositorSnapshots.scale = currentScaleCached;\n        depositorSnapshots.epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentG);\n    }\n\n    /**\n     * @dev Pays out the TREN gains to the specific depositor.\n     * @param _depositor The depositor address.\n     */\n    function _payOutTRENGains(address _depositor) internal {\n        if (address(communityIssuance) != address(0)) {\n            uint256 depositorTRENGain = getDepositorTRENGain(_depositor);\n            ICommunityIssuance(communityIssuance).sendTREN(_depositor, depositorTRENGain);\n            emit TRENPaidToDepositor(_depositor, depositorTRENGain);\n        }\n    }\n\n    /**\n     * @dev Returns the collateral balances left after sending gains to the depositors.\n     * @param _coll1 The total collateral before sending.\n     * @param _tokens The address array of collateral assets to send.\n     * @param _amounts The amount array of collateral assets to send.\n     */\n    function _leftSubColls(\n        Colls memory _coll1,\n        address[] memory _tokens,\n        uint256[] memory _amounts\n    )\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        uint256 coll1Len = _coll1.amounts.length;\n        uint256 tokensLen = _tokens.length;\n\n        for (uint256 i = 0; i < coll1Len;) {\n            for (uint256 j = 0; j < tokensLen;) {\n                if (_coll1.tokens[i] == _tokens[j]) {\n                    _coll1.amounts[i] -= _amounts[j];\n                }\n                unchecked {\n                    ++j;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return _coll1.amounts;\n    }\n\n    /**\n     * @dev Requires that a user has an initial deposit.\n     * @param _initialDeposit The amount of initial deposit.\n     */\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        if (_initialDeposit == 0) {\n            revert StabilityPool__UserHasNoDeposit();\n        }\n    }\n\n    /**\n     * @dev Requires that the amount is not zero.\n     * @param _amount The amount.\n     */\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        if (_amount == 0) {\n            revert StabilityPool__AmountMustBeNonZero();\n        }\n    }\n\n    // --- Fallback function ---\n\n    /**\n     * @notice Receives the specific collateral amount from TrenBoxStorage contract.\n     * @param _asset The address of collateral asset.\n     * @param _amount The amount of collateral asset.\n     */\n    function receivedERC20(address _asset, uint256 _amount) external override onlyTrenBoxStorage {\n        uint256 collateralIndex = IAdminContract(adminContract).getIndex(_asset);\n        uint256 newAssetBalance = totalColl.amounts[collateralIndex] + _amount;\n        totalColl.amounts[collateralIndex] = newAssetBalance;\n        emit StabilityPoolAssetBalanceUpdated(_asset, newAssetBalance);\n    }\n\n    function authorizeUpgrade(address newImplementation) public {\n        _authorizeUpgrade(newImplementation);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner { }\n}\n"
    },
    "contracts/TestContracts/ERC20Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.23;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\ncontract ERC20Test is ERC20Permit {\n    constructor() ERC20(\"ERC Test\", \"TST\") ERC20Permit(\"ERC Test\") { }\n\n    uint8 private DECIMALS = 18;\n\n    function mint(address _addr, uint256 _amount) public {\n        _mint(_addr, _amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        public\n        override\n        returns (bool)\n    {\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return DECIMALS;\n    }\n\n    function setDecimals(uint8 _decimals) public {\n        DECIMALS = _decimals;\n    }\n}\n"
    },
    "contracts/TestContracts/FlashLoanTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IFlashLoan } from \"../Interfaces/IFlashLoan.sol\";\nimport { IFlashLoanReceiver } from \"../Interfaces/IFlashLoanReceiver.sol\";\n\ncontract FlashLoanTester is IFlashLoanReceiver {\n    address public flashLoan;\n\n    function setFlashLoanAddress(address _flashLoan) external {\n        flashLoan = _flashLoan;\n    }\n\n    function executeFlashLoan(uint256 _amount) external {\n        IFlashLoan(flashLoan).flashLoan(_amount);\n    }\n\n    function executeOperation(uint256 _amount, uint256 _fee, address _tokenAddress) external {\n        // Here you can do anything what you want\n\n        IERC20(_tokenAddress).transfer(msg.sender, _amount + _fee);\n    }\n\n    function withdrawTokens(address _tokenAddress, address _receiver) external {\n        uint256 _amount = IERC20(_tokenAddress).balanceOf(address(this));\n        IERC20(_tokenAddress).transfer(_receiver, _amount);\n    }\n}\n"
    },
    "contracts/TestContracts/MockAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { AggregatorV3Interface } from\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract MockAggregator is AggregatorV3Interface {\n    uint8 private decimalsVal = 8;\n    int256 private answer = 190_000_000_000;\n    int256 private prevAnswer = 190_000_000_000;\n    uint256 private startedAt;\n    uint256 private updatedAt;\n\n    uint80 private latestRoundId = 2;\n    uint80 private prevRoundId = 1;\n\n    bool private priceIsAlwaysUpToDate = true;\n\n    // --- Functions ---\n\n    function setDecimals(uint8 _decimals) external {\n        decimalsVal = _decimals;\n    }\n\n    function setPrice(int256 _price) external {\n        answer = _price;\n    }\n\n    function setPrevPrice(int256 _prevPrice) external {\n        prevAnswer = _prevPrice;\n    }\n\n    function setStartedAt(uint256 _startedAt) external {\n        startedAt = _startedAt;\n    }\n\n    function setUpdatedAt(uint256 _updatedAt) external {\n        updatedAt = _updatedAt;\n    }\n\n    function setLatestRoundId(uint80 _latestRoundId) external {\n        latestRoundId = _latestRoundId;\n    }\n\n    function setPrevRoundId(uint80 _prevRoundId) external {\n        prevRoundId = _prevRoundId;\n    }\n\n    function setPriceIsAlwaysUpToDate(bool _priceIsAlwaysUpToDate) external {\n        priceIsAlwaysUpToDate = _priceIsAlwaysUpToDate;\n    }\n\n    // --- Getters that adhere to the AggregatorV3 interface ---\n\n    function decimals() external view override returns (uint8) {\n        return decimalsVal;\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (uint80, int256, uint256, uint256, uint80)\n    {\n        uint256 timestamp = priceIsAlwaysUpToDate ? block.timestamp - 2 minutes : updatedAt;\n        return (latestRoundId, answer, startedAt, timestamp, 0);\n    }\n\n    function getRoundData(uint80)\n        external\n        view\n        override\n        returns (uint80, int256, uint256, uint256, uint80)\n    {\n        uint256 timestamp = priceIsAlwaysUpToDate ? block.timestamp - 5 minutes : updatedAt;\n        return (prevRoundId, prevAnswer, startedAt, timestamp, 0);\n    }\n\n    function description() external pure override returns (string memory) {\n        return \"\";\n    }\n\n    function version() external pure override returns (uint256) {\n        return 1;\n    }\n}\n"
    },
    "contracts/TestContracts/MockApi3Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { API3ProxyInterface } from \"../Pricing/API3ProxyInterface.sol\";\n\ncontract MockApi3Proxy is API3ProxyInterface {\n    int224 public value = 1_012_695_777_067_725_000;\n\n    function setValue(int224 _newValue) external {\n        value = _newValue;\n    }\n\n    function read() external view override returns (int224, uint32) {\n        return (value, uint32(block.timestamp));\n    }\n}\n"
    },
    "contracts/TestContracts/MockBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// This contract is for temporary replacement main BorrowerOpearations in testing\n// flashLoanForRepay() in FlashLoan.sol\ncontract MockBorrowerOperations {\n    function repayDebtTokens(\n        address _asset,\n        uint256 _netDebt,\n        address _upperHint,\n        address _lowerHint\n    )\n        external\n    {\n        IERC20(_asset).transfer(msg.sender, IERC20(_asset).balanceOf(address(this)));\n    }\n}\n"
    },
    "contracts/TestContracts/MockPythPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.23;\n\nimport { MockPyth } from \"@pythnetwork/pyth-sdk-solidity/MockPyth.sol\";\nimport { PythStructs } from \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\n\ncontract MockPythPriceFeed is MockPyth {\n    constructor() MockPyth(0, 0) { }\n\n    function updatePriceFeed(bytes calldata updateData) external {\n        PythStructs.PriceFeed memory priceFeed = abi.decode(updateData, (PythStructs.PriceFeed));\n\n        priceFeeds[priceFeed.id] = priceFeed;\n        emit PriceFeedUpdate(\n            priceFeed.id,\n            uint64(priceFeed.price.publishTime),\n            priceFeed.price.price,\n            priceFeed.price.conf\n        );\n    }\n}\n"
    },
    "contracts/TestContracts/MockUniswapRouterV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { IUniswapRouterV3 } from \"../Interfaces/IUniswapRouterV3.sol\";\n\ncontract MockUniswapRouterV3 is IUniswapRouterV3 {\n    using BytesLib for bytes;\n\n    uint256 private constant FEE_DENOMINATOR = 1_000_000;\n    uint256 private constant ADDR_SIZE = 20;\n    uint256 private constant FEE_SIZE = 3;\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n\n    uint256 public ratioAssetToStable = 3000;\n    uint256 public ratioStableToDebt = 1;\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    function setRatio(uint256 _ratioAssetToStable, uint256 _ratioStableToDebt) external {\n        ratioAssetToStable = _ratioAssetToStable;\n        ratioStableToDebt = _ratioStableToDebt;\n    }\n\n    function exactOutput(ExactOutputParams memory params) external returns (uint256 amountIn) {\n        (address debtToken, address stableCoin, address assetToken, uint24 fee1, uint24 fee2) =\n            decodePath(params.path);\n\n        uint256 stableCoinsNeeded = params.amountOut * ratioStableToDebt;\n        uint256 fee_1 = (stableCoinsNeeded * fee1) / FEE_DENOMINATOR;\n        uint256 assetTokensNeeded = (stableCoinsNeeded + fee_1) / ratioAssetToStable;\n        uint256 fee_2 = (assetTokensNeeded * fee2) / FEE_DENOMINATOR;\n        uint256 assetTokensNeededPlusFee = assetTokensNeeded + fee_2;\n\n        IERC20(assetToken).transferFrom(params.recipient, address(this), assetTokensNeededPlusFee);\n        IERC20(debtToken).transfer(params.recipient, params.amountOut);\n\n        return assetTokensNeededPlusFee;\n    }\n\n    function decodePath(bytes memory path)\n        internal\n        pure\n        returns (address tokenA, address tokenB, address tokenC, uint24 fee1, uint24 fee2)\n    {\n        tokenA = path.toAddress(0);\n        fee1 = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n        fee2 = path.toUint24(NEXT_OFFSET + ADDR_SIZE);\n        tokenC = path.toAddress(NEXT_OFFSET + ADDR_SIZE + FEE_SIZE);\n    }\n}\n\nlibrary BytesLib {\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, \"toAddress_overflow\");\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, \"toUint24_overflow\");\n        require(_bytes.length >= _start + 3, \"toUint24_outOfBounds\");\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}\n"
    },
    "contracts/TestContracts/PriceFeedTestnet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.23;\n\nimport { IPriceFeed } from \"../Interfaces/IPriceFeed.sol\";\n\n/*\n* PriceFeed placeholder for testnet and development. The price is simply set manually and saved in a\nstate\n * variable. The contract does not connect to a live Chainlink price feed.\n */\ncontract PriceFeedTestnet is IPriceFeed {\n    string public constant NAME = \"PriceFeedTestnet\";\n\n    mapping(address asset => uint256 price) public prices;\n\n    function getPrice(address _asset) external view returns (uint256) {\n        return prices[_asset];\n    }\n\n    function setPrice(address _asset, uint256 _price) external {\n        prices[_asset] = _price;\n    }\n\n    function setOracle(\n        address _token,\n        address _oracle,\n        ProviderType _type,\n        uint256 _timeoutMinutes,\n        bool _isEthIndexed,\n        bool _isFallback,\n        bytes32 _additionalData\n    )\n        external\n        override\n    { }\n\n    function fetchPrice(address _asset) external view override returns (uint256) {\n        return this.getPrice(_asset);\n    }\n}\n"
    },
    "contracts/TestContracts/TrenMathTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { TrenMath } from \"../Dependencies/TrenMath.sol\";\n\ncontract TrenMathTester {\n    function min(uint256 _a, uint256 _b) external pure returns (uint256) {\n        return TrenMath._min(_a, _b);\n    }\n\n    function max(uint256 _a, uint256 _b) external pure returns (uint256) {\n        return TrenMath._max(_a, _b);\n    }\n\n    /**\n     * @dev Multiply two decimal numbers and use normal rounding rules:\n     * -round product up if 19'th mantissa digit >= 5\n     * -round product down if 19'th mantissa digit < 5\n     *\n     * Used only inside the exponentiation, _decPow().\n     */\n    function decMul(uint256 x, uint256 y) external pure returns (uint256) {\n        return TrenMath.decMul(x, y);\n    }\n\n    /**\n     * @dev Exponentiation function for 18-digit decimal base, and integer exponent n.\n     * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\n     */\n    function decPow(uint256 _base, uint256 _minutes) external pure returns (uint256) {\n        return TrenMath._decPow(_base, _minutes);\n    }\n\n    function getAbsoluteDifference(uint256 _a, uint256 _b) external pure returns (uint256) {\n        return TrenMath._getAbsoluteDifference(_a, _b);\n    }\n\n    function computeNominalCR(uint256 _coll, uint256 _debt) external pure returns (uint256) {\n        return TrenMath._computeNominalCR(_coll, _debt);\n    }\n\n    function computeCR(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _price\n    )\n        external\n        pure\n        returns (uint256)\n    {\n        return TrenMath._computeCR(_coll, _debt, _price);\n    }\n}\n"
    },
    "contracts/Timelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nerror Timelock__DelayMustExceedMininumDelay();\nerror Timelock__DelayMustNotExceedMaximumDelay();\nerror Timelock__OnlyTimelock();\nerror Timelock__OnlyPendingAdmin();\nerror Timelock__OnlyAdmin();\nerror Timelock__ETAMustSatisfyDelay();\nerror Timelock__TxNoQueued();\nerror Timelock__TxAlreadyQueued();\nerror Timelock__TxStillLocked();\nerror Timelock__TxExpired();\nerror Timelock__TxReverted();\nerror Timelock__AdminZeroAddress();\nerror Timelock__TargetZeroAddress();\n\ncontract Timelock {\n    // ------------------------------------------- State ------------------------------------------\n    string public constant NAME = \"Timelock\";\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 15 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n\n    mapping(bytes32 txHash => bool isQueued) public queuedTransactions;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    // ------------------------------------------ Modifiers ---------------------------------------\n\n    modifier isValidDelay(uint256 _delay) virtual {\n        if (_delay < MINIMUM_DELAY) {\n            revert Timelock__DelayMustExceedMininumDelay();\n        }\n        if (_delay > MAXIMUM_DELAY) {\n            revert Timelock__DelayMustNotExceedMaximumDelay();\n        }\n        _;\n    }\n\n    modifier OnlyAdmin() {\n        if (msg.sender != admin) {\n            revert Timelock__OnlyAdmin();\n        }\n        _;\n    }\n\n    // ------------------------------------------ Constructor -------------------------------------\n\n    constructor(uint256 _delay, address _adminAddress) isValidDelay(_delay) {\n        if (_adminAddress == address(0)) {\n            revert Timelock__AdminZeroAddress();\n        }\n\n        admin = _adminAddress;\n        delay = _delay;\n    }\n\n    // ------------------------------------------ External Functions ------------------------------\n\n    function setDelay(uint256 _delay) external isValidDelay(_delay) {\n        if (msg.sender != address(this)) {\n            revert Timelock__OnlyTimelock();\n        }\n        delay = _delay;\n\n        emit NewDelay(_delay);\n    }\n\n    function acceptAdmin() external {\n        if (msg.sender != pendingAdmin) {\n            revert Timelock__OnlyPendingAdmin();\n        }\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(msg.sender);\n    }\n\n    function setPendingAdmin(address _pendingAdmin) external {\n        if (msg.sender != address(this)) {\n            revert Timelock__OnlyTimelock();\n        }\n        if (_pendingAdmin == address(0)) {\n            revert Timelock__AdminZeroAddress();\n        }\n        pendingAdmin = _pendingAdmin;\n\n        emit NewPendingAdmin(_pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    )\n        external\n        OnlyAdmin\n        returns (bytes32)\n    {\n        if (eta < block.timestamp + delay || eta > block.timestamp + delay + GRACE_PERIOD) {\n            revert Timelock__ETAMustSatisfyDelay();\n        }\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        if (queuedTransactions[txHash]) {\n            revert Timelock__TxAlreadyQueued();\n        }\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    )\n        external\n        OnlyAdmin\n    {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        if (!queuedTransactions[txHash]) {\n            revert Timelock__TxNoQueued();\n        }\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    )\n        external\n        payable\n        OnlyAdmin\n        returns (bytes memory)\n    {\n        if (target == address(0)) {\n            revert Timelock__TargetZeroAddress();\n        }\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        if (!queuedTransactions[txHash]) {\n            revert Timelock__TxNoQueued();\n        }\n        if (block.timestamp < eta) {\n            revert Timelock__TxStillLocked();\n        }\n        if (block.timestamp > eta + GRACE_PERIOD) {\n            revert Timelock__TxExpired();\n        }\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n        if (!success) {\n            revert Timelock__TxReverted();\n        }\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    // ------------------------------------------- Receive function -------------------------------\n\n    receive() external payable { }\n}\n"
    },
    "contracts/TREN/CommunityIssuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { OwnableUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport { ICommunityIssuance } from \"../Interfaces/ICommunityIssuance.sol\";\nimport { IStabilityPool } from \"../Interfaces/IStabilityPool.sol\";\n\ncontract CommunityIssuance is ICommunityIssuance, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = \"CommunityIssuance\";\n\n    uint256 public constant DISTRIBUTION_DURATION = 7 days / 60;\n    uint256 public constant SECONDS_IN_ONE_MINUTE = 60;\n\n    uint256 public totalTRENIssued;\n    uint256 public lastUpdateTime;\n    uint256 public TRENSupplyCap;\n    uint256 public trenDistribution;\n\n    IERC20 public trenToken;\n    IStabilityPool public stabilityPool;\n\n    address public adminContract;\n    bool public isSetupInitialized;\n\n    modifier isController() {\n        if (msg.sender != owner() && msg.sender != adminContract) {\n            revert CommunityIssuance__InvalidPermission();\n        }\n        _;\n    }\n\n    modifier onlyStabilityPool() {\n        if (msg.sender != address(stabilityPool)) {\n            revert CommunityIssuance__NotStabilityPool();\n        }\n        _;\n    }\n\n    // --- Initializer ---\n\n    function initialize() public initializer {\n        address initialOwner = _msgSender();\n        __Ownable_init(initialOwner);\n    }\n\n    // --- Functions ---\n    function setAddresses(\n        address _trenToken,\n        address _stabilityPool,\n        address _adminContract\n    )\n        external\n        onlyOwner\n    {\n        if (isSetupInitialized) {\n            revert CommunityIssuance__SetupAlreadyInitialized();\n        }\n        if (\n            _trenToken == address(0) || _stabilityPool == address(0) || _adminContract == address(0)\n        ) {\n            revert CommunityIssuance__InvalidAddresses();\n        }\n        adminContract = _adminContract;\n        trenToken = IERC20(_trenToken);\n        stabilityPool = IStabilityPool(_stabilityPool);\n        isSetupInitialized = true;\n    }\n\n    function setAdminContract(address _adminContract) external onlyOwner {\n        if (_adminContract == address(0)) {\n            revert CommunityIssuance__InvalidAdminContract();\n        }\n        adminContract = _adminContract;\n    }\n\n    function addFundToStabilityPool(uint256 _assignedSupply) external override isController {\n        _addFundToStabilityPoolFrom(_assignedSupply, msg.sender);\n    }\n\n    function removeFundFromStabilityPool(uint256 _fundToRemove) external onlyOwner {\n        uint256 newCap = TRENSupplyCap - _fundToRemove;\n        if (totalTRENIssued > newCap) {\n            revert CommunityIssuance__SPHaveInsufficientSupply();\n        }\n\n        TRENSupplyCap -= _fundToRemove;\n\n        trenToken.safeTransfer(msg.sender, _fundToRemove);\n    }\n\n    function addFundToStabilityPoolFrom(\n        uint256 _assignedSupply,\n        address _spender\n    )\n        external\n        override\n        isController\n    {\n        _addFundToStabilityPoolFrom(_assignedSupply, _spender);\n    }\n\n    function _addFundToStabilityPoolFrom(uint256 _assignedSupply, address _spender) internal {\n        if (lastUpdateTime == 0) {\n            lastUpdateTime = block.timestamp;\n        }\n\n        TRENSupplyCap += _assignedSupply;\n        trenToken.safeTransferFrom(_spender, address(this), _assignedSupply);\n    }\n\n    function issueTREN() public override onlyStabilityPool returns (uint256) {\n        uint256 maxPoolSupply = TRENSupplyCap;\n\n        if (totalTRENIssued >= maxPoolSupply) return 0;\n\n        uint256 issuance = _getLastUpdateTokenDistribution();\n        uint256 totalIssuance = issuance + totalTRENIssued;\n\n        if (totalIssuance > maxPoolSupply) {\n            issuance = maxPoolSupply - totalTRENIssued;\n            totalIssuance = maxPoolSupply;\n        }\n\n        lastUpdateTime = block.timestamp;\n        totalTRENIssued = totalIssuance;\n        emit TotalTRENIssuedUpdated(totalIssuance);\n\n        return issuance;\n    }\n\n    function _getLastUpdateTokenDistribution() internal view returns (uint256) {\n        if (lastUpdateTime == 0) {\n            revert CommunityIssuance__SPNotAssigned();\n        }\n        uint256 timePassed = (block.timestamp - lastUpdateTime) / SECONDS_IN_ONE_MINUTE;\n        uint256 totalDistribuedSinceBeginning = trenDistribution * timePassed;\n\n        return totalDistribuedSinceBeginning;\n    }\n\n    function sendTREN(address _account, uint256 _TRENamount) external override onlyStabilityPool {\n        uint256 balanceTREN = trenToken.balanceOf(address(this));\n        uint256 safeAmount = balanceTREN >= _TRENamount ? _TRENamount : balanceTREN;\n\n        if (safeAmount == 0) {\n            return;\n        }\n\n        IERC20(address(trenToken)).safeTransfer(_account, safeAmount);\n    }\n\n    function setWeeklyTrenDistribution(uint256 _weeklyReward) external isController {\n        trenDistribution = _weeklyReward / DISTRIBUTION_DURATION;\n    }\n}\n"
    },
    "contracts/TREN/LockedTREN.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { OwnableUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { ILockedTREN } from \"../Interfaces/ILockedTREN.sol\";\n\n/**\n * @notice This contract is reserved for Linear Vesting to the Team members and the Advisors team.\n */\ncontract LockedTREN is ILockedTREN, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = \"LockedTREN\";\n    uint256 public constant SIX_MONTHS = 26 weeks;\n    uint256 public constant TWO_YEARS = 730 days;\n\n    IERC20 private trenToken;\n    uint256 private assignedTRENTokens;\n\n    mapping(address entity => Rule rule) public entitiesVesting;\n\n    modifier entityRuleExists(address _entity) {\n        if (entitiesVesting[_entity].createdDate == 0) {\n            revert LockedTREN__NotHaveVestingRule();\n        }\n        _;\n    }\n\n    function initialize() public initializer {\n        address initialOwner = _msgSender();\n\n        __Ownable_init(initialOwner);\n    }\n\n    function setAddresses(address _trenAddress) public initializer onlyOwner {\n        trenToken = IERC20(_trenAddress);\n    }\n\n    function addEntityVesting(address _entity, uint256 _totalSupply) public onlyOwner {\n        if (_entity == address(0)) {\n            revert LockedTREN__InvalidAddress();\n        }\n\n        if (entitiesVesting[_entity].createdDate != 0) {\n            revert LockedTREN__AlreadyHaveVestingRule();\n        }\n\n        assignedTRENTokens += _totalSupply;\n\n        entitiesVesting[_entity] = Rule(\n            block.timestamp,\n            _totalSupply,\n            block.timestamp + SIX_MONTHS,\n            block.timestamp + TWO_YEARS,\n            0\n        );\n\n        trenToken.safeTransferFrom(msg.sender, address(this), _totalSupply);\n\n        emit AddEntityVesting(\n            _entity,\n            _totalSupply,\n            entitiesVesting[_entity].startVestingDate,\n            entitiesVesting[_entity].endVestingDate\n        );\n    }\n\n    function lowerEntityVesting(\n        address _entity,\n        uint256 newTotalSupply\n    )\n        public\n        onlyOwner\n        entityRuleExists(_entity)\n    {\n        sendTRENTokenToEntity(_entity);\n        Rule storage vestingRule = entitiesVesting[_entity];\n\n        if (newTotalSupply <= vestingRule.claimed) {\n            revert LockedTREN__TotalSupplyLessThanClaimed();\n        }\n\n        vestingRule.totalSupply = newTotalSupply;\n    }\n\n    function removeEntityVesting(address _entity) public onlyOwner entityRuleExists(_entity) {\n        sendTRENTokenToEntity(_entity);\n        Rule memory vestingRule = entitiesVesting[_entity];\n\n        assignedTRENTokens = assignedTRENTokens - (vestingRule.totalSupply - vestingRule.claimed);\n\n        delete entitiesVesting[_entity];\n    }\n\n    function claimTRENToken() public entityRuleExists(msg.sender) {\n        sendTRENTokenToEntity(msg.sender);\n    }\n\n    function sendTRENTokenToEntity(address _entity) private {\n        uint256 unclaimedAmount = getClaimableTREN(_entity);\n        if (unclaimedAmount == 0) return;\n\n        Rule storage entityRule = entitiesVesting[_entity];\n        entityRule.claimed += unclaimedAmount;\n\n        assignedTRENTokens = assignedTRENTokens - unclaimedAmount;\n        trenToken.safeTransfer(_entity, unclaimedAmount);\n    }\n\n    function transferUnassignedTREN() external onlyOwner {\n        uint256 unassignedTokens = getUnassignTRENTokensAmount();\n\n        if (unassignedTokens == 0) return;\n\n        trenToken.safeTransfer(msg.sender, unassignedTokens);\n    }\n\n    function getClaimableTREN(address _entity) public view returns (uint256 claimable) {\n        Rule memory entityRule = entitiesVesting[_entity];\n        claimable = 0;\n\n        if (entityRule.startVestingDate > block.timestamp) return claimable;\n\n        if (block.timestamp >= entityRule.endVestingDate) {\n            claimable = entityRule.totalSupply - entityRule.claimed;\n        } else {\n            claimable = (\n                (entityRule.totalSupply * (block.timestamp - entityRule.createdDate)) / TWO_YEARS\n            ) - entityRule.claimed;\n        }\n\n        return claimable;\n    }\n\n    function getUnassignTRENTokensAmount() public view returns (uint256) {\n        return trenToken.balanceOf(address(this)) - assignedTRENTokens;\n    }\n\n    function isEntityExits(address _entity) public view returns (bool) {\n        return entitiesVesting[_entity].createdDate != 0;\n    }\n}\n"
    },
    "contracts/TREN/TRENStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { OwnableUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { PausableUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport { TrenMath, DECIMAL_PRECISION } from \"../Dependencies/TrenMath.sol\";\nimport { SafetyTransfer } from \"../Dependencies/SafetyTransfer.sol\";\n\nimport { ITRENStaking } from \"../Interfaces/ITRENStaking.sol\";\n\ncontract TRENStaking is\n    ITRENStaking,\n    PausableUpgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n    // ------------------------------------------- State ------------------------------------------\n\n    string public constant NAME = \"TRENStaking\";\n\n    address public debtToken;\n    address public feeCollector;\n    address public treasury;\n    IERC20 public trenToken;\n\n    address[] private assetsList;\n\n    uint256 public totalTRENStaked;\n    uint256 public totalDebtTokenFee;\n\n    mapping(address user => Snapshot snapshot) private snapshots;\n    mapping(address user => uint256 amount) private stakes;\n    mapping(address asset => bool tracked) private isAssetTracked;\n    mapping(address user => uint256 assetFeeAmount) private assetsFee;\n    mapping(address asset => uint256 sentToTreasury) private sentAssetFeeToTreasury;\n\n    bool public isSetupInitialized;\n\n    // ------------------------------------------ Modifiers ---------------------------------------\n\n    modifier onlyFeeCollector() {\n        if (msg.sender != feeCollector) {\n            revert TRENStaking__OnlyFeeCollector(msg.sender, feeCollector);\n        }\n        _;\n    }\n\n    modifier isPaused(address _token, uint256 _amount) {\n        if (paused()) {\n            sendToTreasury(_token, _amount);\n            revert TRENStaking__StakingOnPause();\n        }\n        _;\n    }\n\n    // ------------------------------------------ Initializer -------------------------------------\n\n    function initialize() public initializer {\n        address initialOwner = _msgSender();\n\n        __Ownable_init(initialOwner);\n        __ReentrancyGuard_init();\n        __Pausable_init();\n        _pause();\n    }\n\n    // ------------------------------------------ External Functions ------------------------------\n\n    function setAddresses(\n        address _debtToken,\n        address _feeCollector,\n        address _trenToken,\n        address _treasury\n    )\n        external\n        onlyOwner\n    {\n        if (isSetupInitialized) revert TRENStaking__SetupAlreadyInitialized();\n        if (\n            _debtToken == address(0) || _feeCollector == address(0) || _trenToken == address(0)\n                || _treasury == address(0)\n        ) revert TRENStaking__InvalidAddresses();\n\n        debtToken = _debtToken;\n        feeCollector = _feeCollector;\n        trenToken = IERC20(_trenToken);\n        treasury = _treasury;\n\n        isSetupInitialized = true;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function stake(uint256 _TRENamount) external nonReentrant whenNotPaused {\n        if (_TRENamount == 0) revert TRENStaking__InvalidAmount(0);\n\n        uint256 currentStake = stakes[msg.sender];\n        uint256 assetLength = assetsList.length;\n        address asset;\n\n        for (uint256 i = 0; i < assetLength;) {\n            asset = assetsList[i];\n\n            if (currentStake != 0) {\n                if (i == 0) {\n                    checkDebtTokenGain();\n                }\n\n                checkAssetGain(asset);\n            }\n\n            _updateUserSnapshots(asset, msg.sender);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256 newStake = currentStake + _TRENamount;\n        stakes[msg.sender] = newStake;\n        totalTRENStaked += _TRENamount;\n\n        emit TotalTRENStakedUpdated(totalTRENStaked);\n\n        trenToken.safeTransferFrom(msg.sender, address(this), _TRENamount);\n\n        emit StakeUpdated(msg.sender, newStake);\n    }\n\n    function unstake(uint256 _TRENamount) external nonReentrant {\n        uint256 currentStake = stakes[msg.sender];\n        if (currentStake == 0) revert TRENStaking__InvalidStakeAmount(0);\n\n        uint256 assetLength = assetsList.length;\n        address asset;\n\n        for (uint256 i = 0; i < assetLength;) {\n            asset = assetsList[i];\n\n            if (i == 0) {\n                checkDebtTokenGain();\n            }\n\n            checkAssetGain(asset);\n\n            _updateUserSnapshots(asset, msg.sender);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (_TRENamount > 0) {\n            uint256 trenToWithdraw = TrenMath._min(_TRENamount, currentStake);\n            uint256 newStake = currentStake - trenToWithdraw;\n\n            stakes[msg.sender] = newStake;\n            totalTRENStaked -= trenToWithdraw;\n\n            emit TotalTRENStakedUpdated(totalTRENStaked);\n\n            trenToken.safeTransfer(msg.sender, trenToWithdraw);\n\n            emit StakeUpdated(msg.sender, newStake);\n        }\n    }\n\n    function increaseFeeAsset(\n        address _asset,\n        uint256 _assetFee\n    )\n        external\n        onlyFeeCollector\n        isPaused(_asset, _assetFee)\n    {\n        if (!isAssetTracked[_asset]) {\n            isAssetTracked[_asset] = true;\n            assetsList.push(_asset);\n        }\n\n        uint256 assetFeePerTRENStaked = 0;\n        if (totalTRENStaked > 0) assetFeePerTRENStaked = calculateFeePerTRENStaked(_assetFee);\n        assetsFee[_asset] += assetFeePerTRENStaked;\n\n        emit AssetFeeUpdated(_asset, assetsFee[_asset]);\n    }\n\n    function increaseFeeDebtToken(uint256 _debtTokenFee)\n        external\n        onlyFeeCollector\n        isPaused(debtToken, _debtTokenFee)\n    {\n        uint256 debtTokenFeePerTRENStaked = 0;\n        if (totalTRENStaked > 0) {\n            debtTokenFeePerTRENStaked = calculateFeePerTRENStaked(_debtTokenFee);\n        }\n        totalDebtTokenFee += debtTokenFeePerTRENStaked;\n\n        emit TotalDebtTokenFeeUpdated(totalDebtTokenFee);\n    }\n\n    function getPendingAssetGain(address _asset, address _user) external view returns (uint256) {\n        return _getPendingAssetGain(_asset, _user);\n    }\n\n    function getPendingDebtTokenGain(address _user) external view returns (uint256) {\n        return _getPendingDebtTokenGain(_user);\n    }\n\n    function getAssetsList() external view returns (address[] memory) {\n        return assetsList;\n    }\n\n    // ------------------------------------------ Private functions ------------------------------\n\n    function _updateUserSnapshots(address _asset, address _user) private {\n        snapshots[_user].assetsFeeSnapshot[_asset] = assetsFee[_asset];\n        snapshots[_user].debtTokenFeeSnapshot = totalDebtTokenFee;\n\n        emit StakerSnapshotsUpdated(_user, assetsFee[_asset], totalDebtTokenFee);\n    }\n\n    function _sendAssetGainToUser(address _asset, uint256 _assetGain) private {\n        _assetGain = SafetyTransfer.decimalsCorrection(_asset, _assetGain);\n        _sendAsset(msg.sender, _asset, _assetGain);\n\n        emit SentAsset(_asset, msg.sender, _assetGain);\n    }\n\n    function sendToTreasury(address _asset, uint256 _amount) private {\n        _sendAsset(treasury, _asset, _amount);\n        sentAssetFeeToTreasury[_asset] += _amount;\n\n        emit SentAssetFeeToTreasury(_asset, _amount);\n    }\n\n    function checkDebtTokenGain() private {\n        uint256 debtTokenGain = _getPendingDebtTokenGain(msg.sender);\n        if (debtTokenGain != 0) {\n            _sendAsset(msg.sender, debtToken, debtTokenGain);\n            emit StakingDebtTokenGainWithdrawn(msg.sender, debtTokenGain);\n        }\n    }\n\n    function _sendAsset(address _receiver, address _asset, uint256 _amount) private {\n        IERC20(_asset).safeTransfer(_receiver, _amount);\n    }\n\n    function checkAssetGain(address _asset) private {\n        uint256 assetGain = _getPendingDebtTokenGain(msg.sender);\n        if (assetGain != 0) {\n            _sendAssetGainToUser(_asset, assetGain);\n            emit StakingAssetGainWithdrawn(msg.sender, _asset, assetGain);\n        }\n    }\n\n    function calculateFeePerTRENStaked(uint256 _feeAmount) private view returns (uint256) {\n        return (_feeAmount * DECIMAL_PRECISION) / totalTRENStaked;\n    }\n\n    function _getPendingAssetGain(address _asset, address _user) private view returns (uint256) {\n        uint256 assetFeeSnapshot = snapshots[_user].assetsFeeSnapshot[_asset];\n        return (stakes[_user] * (assetsFee[_asset] - assetFeeSnapshot)) / DECIMAL_PRECISION;\n    }\n\n    function _getPendingDebtTokenGain(address _user) private view returns (uint256) {\n        uint256 debtTokenFeeSnapshot = snapshots[_user].debtTokenFeeSnapshot;\n        return (stakes[_user] * (totalDebtTokenFee - debtTokenFeeSnapshot)) / DECIMAL_PRECISION;\n    }\n}\n"
    },
    "contracts/TREN/TRENToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\ncontract TRENToken is ERC20Permit {\n    error TRENToken__InvalidTreasurySig();\n\n    string public constant NAME = \"TREN\";\n    string public constant SYMBOL = \"TREN\";\n\n    uint256 internal constant _1_MILLION = 1e24; // 1e6 * 1e18 = 1e24\n\n    address public immutable TREASURY;\n\n    constructor(address _treasurySig) ERC20(NAME, SYMBOL) ERC20Permit(NAME) {\n        if (_treasurySig == address(0)) {\n            revert TRENToken__InvalidTreasurySig();\n        }\n\n        TREASURY = _treasurySig;\n\n        // Lazy Mint to setup protocol.\n        // After the deployment scripts, deployer addr automatically send the fund to the treasury.\n        _mint(msg.sender, _1_MILLION * 50);\n        _mint(_treasurySig, _1_MILLION * 50);\n    }\n}\n"
    },
    "contracts/TrenBoxManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { ReentrancyGuardUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { UUPSUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport { TrenBase } from \"./Dependencies/TrenBase.sol\";\nimport { TrenMath, DECIMAL_PRECISION } from \"./Dependencies/TrenMath.sol\";\n\nimport { IAdminContract } from \"./Interfaces/IAdminContract.sol\";\nimport { IDebtToken } from \"./Interfaces/IDebtToken.sol\";\nimport { IStabilityPool } from \"./Interfaces/IStabilityPool.sol\";\nimport { ISortedTrenBoxes } from \"./Interfaces/ISortedTrenBoxes.sol\";\nimport { ITrenBoxManager } from \"./Interfaces/ITrenBoxManager.sol\";\nimport { IFeeCollector } from \"./Interfaces/IFeeCollector.sol\";\nimport { ITrenBoxStorage } from \"./Interfaces/ITrenBoxStorage.sol\";\n\n/**\n * @title TrenBoxManager\n * @notice Contains functionality for liquidations, redistributions, redemptions, and the state\n * of each TrenBox.\n */\ncontract TrenBoxManager is\n    ITrenBoxManager,\n    UUPSUpgradeable,\n    ReentrancyGuardUpgradeable,\n    TrenBase\n{\n    // Constants\n    // ------------------------------------------------------------------------------------------------\n\n    /// @notice The contract name.\n    string public constant NAME = \"TrenBoxManager\";\n    /// @notice The number of seconds in one minute.\n    uint256 public constant SECONDS_IN_ONE_MINUTE = 60;\n    /// @dev Half-life of 12h. 12h = 720 min, (1/2) = d^720 => d = (1/2)^(1/720)\n    uint256 public constant MINUTE_DECAY_FACTOR = 999_037_758_833_783_000;\n    /// @notice BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, to\n    /// calc the new base rate from a redemption. Corresponds to (1 / ALPHA) in the white paper.\n    uint256 public constant BETA = 2;\n\n    // State\n    // -------------------------------------------------------------------------------------------------\n\n    /// @notice The mapping from collateral asset to redemption base rate.\n    mapping(address collateral => uint256 rate) public baseRate;\n    /// @notice The mapping from collateral asset to the timestamp of the latest fee operation\n    /// (redemption or new debt token issuance)\n    mapping(address collateral => uint256 feeOpeartionTimestamp) public lastFeeOperationTime;\n    /// @notice The mapping from borrower address to the TrenBox for a specific collateral asset.\n    mapping(address borrower => mapping(address collateral => TrenBox)) public TrenBoxes;\n    /// @notice The mapping from collateral asset to the total debt tokens staked.\n    mapping(address collateral => uint256 totalStake) public totalStakes;\n    /// @notice The snapshot of total staked amount, taken immediately after the latest liquidation.\n    mapping(address collateral => uint256 totalStake) public totalStakesSnapshot;\n    /// @notice The snapshot of the total collateral in TrenBoxStorage, immediately after the\n    /// latest liquidation.\n    mapping(address collateral => uint256 totalCollateral) public totalCollateralSnapshot;\n\n    /// @notice The collateral sums of accumulated liquidation rewards per unit staked.\n    mapping(address collateral => uint256 accumulatedRewards) public L_Colls;\n    /// @notice The debt sums of accumulated liquidation rewards per unit staked.\n    mapping(address collateral => uint256 accumulatedRewards) public L_Debts;\n\n    /**\n     * @dev L_Colls and L_Debts track the sums of accumulated liquidation rewards per unit staked.\n     * During its lifetime, each stake earns:\n     *\n     * An asset gain of ( stake * [L_Colls - L_Colls(0)] )\n     * A debt increase of ( stake * [L_Debts - L_Debts(0)] )\n     *\n     * Where L_Colls(0) and L_Debts(0) are snapshots of L_Colls and L_Debts for the active TrenBox\n     * taken at the instant the stake was made.\n     */\n\n    /// @notice The mapping from borrowers with active TrenBoxes to their reward snapshots.\n    mapping(address borrower => mapping(address collateral => RewardSnapshot)) public\n        rewardSnapshots;\n\n    /// @notice The array of all active TrenBox addresses.\n    /// @dev Used to compute an approximate hint off-chain for the sorted list insertion.\n    mapping(address collateral => address[] owners) public trenBoxOwners;\n\n    /// @notice The mapping to track the error in collateral redistribution calculation.\n    mapping(address collateral => uint256 collateralError) public lastCollError_Redistribution;\n    /// @notice The mapping to track the error in debt redistribution calculation.\n    mapping(address collateral => uint256 debtError) public lastDebtError_Redistribution;\n\n    // Modifiers\n    // ------------------------------------------------------------------------------------------------------\n\n    modifier onlyTrenBoxManagerOperations() {\n        if (msg.sender != trenBoxManagerOperations) {\n            revert TrenBoxManager__OnlyTrenBoxManagerOperations();\n        }\n        _;\n    }\n\n    modifier onlyBorrowerOperations() {\n        if (msg.sender != borrowerOperations) {\n            revert TrenBoxManager__OnlyBorrowerOperations();\n        }\n        _;\n    }\n\n    modifier onlyTrenBoxManagerOperationsOrBorrowerOperations() {\n        if (msg.sender != borrowerOperations && msg.sender != trenBoxManagerOperations) {\n            revert TrenBoxManager__OnlyTrenBoxManagerOperationsOrBorrowerOperations();\n        }\n        _;\n    }\n\n    // Initializer\n    // ------------------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Runs all the setup logic only once.\n     * @param initialOwner The address of initial owner.\n     */\n    function initialize(address initialOwner) external initializer {\n        __Ownable_init(initialOwner);\n\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n    }\n\n    // External/public functions\n    // --------------------------------------------------------------------------------------\n\n    /// @inheritdoc ITrenBoxManager\n    function isValidFirstRedemptionHint(\n        address _asset,\n        address _firstRedemptionHint,\n        uint256 _price\n    )\n        external\n        view\n        returns (bool)\n    {\n        if (\n            _firstRedemptionHint == address(0)\n                || !ISortedTrenBoxes(sortedTrenBoxes).contains(_asset, _firstRedemptionHint)\n                || getCurrentICR(_asset, _firstRedemptionHint, _price)\n                    < IAdminContract(adminContract).getMcr(_asset)\n        ) {\n            return false;\n        }\n        address nextTrenBox =\n            ISortedTrenBoxes(sortedTrenBoxes).getNext(_asset, _firstRedemptionHint);\n        return nextTrenBox == address(0)\n            || getCurrentICR(_asset, nextTrenBox, _price) < IAdminContract(adminContract).getMcr(_asset);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getNominalICR(\n        address _asset,\n        address _borrower\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        (uint256 currentAsset, uint256 currentDebt) = _getCurrentTrenBoxAmounts(_asset, _borrower);\n\n        uint256 NICR = TrenMath._computeNominalCR(currentAsset, currentDebt);\n        return NICR;\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getCurrentICR(\n        address _asset,\n        address _borrower,\n        uint256 _price\n    )\n        public\n        view\n        override\n        returns (uint256)\n    {\n        (uint256 currentAsset, uint256 currentDebt) = _getCurrentTrenBoxAmounts(_asset, _borrower);\n        uint256 ICR = TrenMath._computeCR(currentAsset, currentDebt, _price);\n        return ICR;\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getPendingAssetReward(\n        address _asset,\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 snapshotAsset = rewardSnapshots[_borrower][_asset].asset;\n        uint256 rewardPerUnitStaked = L_Colls[_asset] - snapshotAsset;\n        if (rewardPerUnitStaked == 0 || !isTrenBoxActive(_asset, _borrower)) {\n            return 0;\n        }\n        uint256 stake = TrenBoxes[_borrower][_asset].stake;\n        uint256 pendingAssetReward = (stake * rewardPerUnitStaked) / DECIMAL_PRECISION;\n        return pendingAssetReward;\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getPendingDebtTokenReward(\n        address _asset,\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 snapshotDebt = rewardSnapshots[_borrower][_asset].debt;\n        uint256 rewardPerUnitStaked = L_Debts[_asset] - snapshotDebt;\n        if (rewardPerUnitStaked == 0 || !isTrenBoxActive(_asset, _borrower)) {\n            return 0;\n        }\n        uint256 stake = TrenBoxes[_borrower][_asset].stake;\n        return (stake * rewardPerUnitStaked) / DECIMAL_PRECISION;\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function hasPendingRewards(\n        address _asset,\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        if (!isTrenBoxActive(_asset, _borrower)) {\n            return false;\n        }\n        return (rewardSnapshots[_borrower][_asset].asset < L_Colls[_asset]);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getEntireDebtAndColl(\n        address _asset,\n        address _borrower\n    )\n        external\n        view\n        override\n        returns (uint256 debt, uint256 coll, uint256 pendingDebtReward, uint256 pendingCollReward)\n    {\n        pendingDebtReward = getPendingDebtTokenReward(_asset, _borrower);\n        pendingCollReward = getPendingAssetReward(_asset, _borrower);\n        TrenBox storage trenBox = TrenBoxes[_borrower][_asset];\n        debt = trenBox.debt + pendingDebtReward;\n        coll = trenBox.coll + pendingCollReward;\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function isTrenBoxActive(\n        address _asset,\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return getTrenBoxStatus(_asset, _borrower) == uint256(Status.active);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getTCR(address _asset, uint256 _price) external view override returns (uint256) {\n        return _getTCR(_asset, _price);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function checkRecoveryMode(\n        address _asset,\n        uint256 _price\n    )\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _checkRecoveryMode(_asset, _price);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getBorrowingRate(address _asset) external view override returns (uint256) {\n        return IAdminContract(adminContract).getBorrowingFee(_asset);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getBorrowingFee(\n        address _asset,\n        uint256 _debt\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return (IAdminContract(adminContract).getBorrowingFee(_asset) * _debt) / DECIMAL_PRECISION;\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getRedemptionFee(address _asset, uint256 _assetDraw) public view returns (uint256) {\n        return _calcRedemptionFee(getRedemptionRate(_asset), _assetDraw);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getRedemptionFeeWithDecay(\n        address _asset,\n        uint256 _assetDraw\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(_asset), _assetDraw);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getRedemptionRate(address _asset) public view override returns (uint256) {\n        return _calcRedemptionRate(_asset, baseRate[_asset]);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getRedemptionRateWithDecay(address _asset) public view override returns (uint256) {\n        return _calcRedemptionRate(_asset, _calcDecayedBaseRate(_asset));\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getTrenBoxFromTrenBoxOwnersArray(\n        address _asset,\n        uint256 _index\n    )\n        external\n        view\n        override\n        returns (address)\n    {\n        return trenBoxOwners[_asset][_index];\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getNetDebt(address _asset, uint256 _debt) external view returns (uint256) {\n        return _getNetDebt(_asset, _debt);\n    }\n\n    // --- TrenBox property getters\n    // --------------------------------------------------------------------------------------\n\n    /// @inheritdoc ITrenBoxManager\n    function getTrenBoxOwnersCount(address _asset) external view override returns (uint256) {\n        return trenBoxOwners[_asset].length;\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getTrenBoxStatus(\n        address _asset,\n        address _borrower\n    )\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(TrenBoxes[_borrower][_asset].status);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getTrenBoxStake(\n        address _asset,\n        address _borrower\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return TrenBoxes[_borrower][_asset].stake;\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getTrenBoxDebt(\n        address _asset,\n        address _borrower\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return TrenBoxes[_borrower][_asset].debt;\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function getTrenBoxColl(\n        address _asset,\n        address _borrower\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return TrenBoxes[_borrower][_asset].coll;\n    }\n\n    // Called by Tren contracts\n    // ------------------------------------------------------------------------------------\n\n    /// @inheritdoc ITrenBoxManager\n    function addTrenBoxOwnerToArray(\n        address _asset,\n        address _borrower\n    )\n        external\n        override\n        onlyBorrowerOperations\n        returns (uint256 index)\n    {\n        address[] storage assetOwners = trenBoxOwners[_asset];\n        assetOwners.push(_borrower);\n        index = assetOwners.length - 1;\n        TrenBoxes[_borrower][_asset].arrayIndex = uint128(index);\n        return index;\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function executeFullRedemption(\n        address _asset,\n        address _borrower,\n        uint256 _newColl\n    )\n        external\n        override\n        nonReentrant\n        onlyTrenBoxManagerOperations\n    {\n        _removeStake(_asset, _borrower);\n        _closeTrenBox(_asset, _borrower, Status.closedByRedemption);\n        _redeemCloseTrenBox(\n            _asset,\n            _borrower,\n            IAdminContract(adminContract).getDebtTokenGasCompensation(_asset),\n            _newColl\n        );\n        IFeeCollector(feeCollector).closeDebt(_borrower, _asset);\n        emit TrenBoxUpdated(_asset, _borrower, 0, 0, 0, TrenBoxManagerOperation.redeemCollateral);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function executePartialRedemption(\n        address _asset,\n        address _borrower,\n        uint256 _newDebt,\n        uint256 _newColl,\n        uint256 _newNICR,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint\n    )\n        external\n        override\n        onlyTrenBoxManagerOperations\n    {\n        ISortedTrenBoxes(sortedTrenBoxes).reInsert(\n            _asset, _borrower, _newNICR, _upperPartialRedemptionHint, _lowerPartialRedemptionHint\n        );\n\n        TrenBox storage trenBox = TrenBoxes[_borrower][_asset];\n        uint256 paybackFraction = ((trenBox.debt - _newDebt) * 1 ether) / trenBox.debt;\n        if (paybackFraction != 0) {\n            IFeeCollector(feeCollector).decreaseDebt(_borrower, _asset, paybackFraction);\n        }\n\n        trenBox.debt = _newDebt;\n        trenBox.coll = _newColl;\n        _updateStakeAndTotalStakes(_asset, _borrower);\n\n        emit TrenBoxUpdated(\n            _asset,\n            _borrower,\n            _newDebt,\n            _newColl,\n            trenBox.stake,\n            TrenBoxManagerOperation.redeemCollateral\n        );\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function finalizeRedemption(\n        address _asset,\n        address _receiver,\n        uint256 _debtToRedeem,\n        uint256 _assetFeeAmount,\n        uint256 _assetRedeemedAmount\n    )\n        external\n        override\n        onlyTrenBoxManagerOperations\n    {\n        // Send the asset fee\n        if (_assetFeeAmount != 0) {\n            address destination = IFeeCollector(feeCollector).getProtocolRevenueDestination();\n            ITrenBoxStorage(trenBoxStorage).sendCollateral(_asset, destination, _assetFeeAmount);\n            IFeeCollector(feeCollector).handleRedemptionFee(_asset, _assetFeeAmount);\n        }\n        // Burn the total debt tokens that is cancelled with debt, and send the redeemed asset to\n        // msg.sender\n        IDebtToken(debtToken).burn(_receiver, _debtToRedeem);\n        // Update Active Pool, and send asset to account\n        uint256 collToSendToRedeemer = _assetRedeemedAmount - _assetFeeAmount;\n        ITrenBoxStorage(trenBoxStorage).decreaseActiveDebt(_asset, _debtToRedeem);\n        ITrenBoxStorage(trenBoxStorage).sendCollateral(_asset, _receiver, collToSendToRedeemer);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function updateBaseRateFromRedemption(\n        address _asset,\n        uint256 _assetDrawn,\n        uint256 _price,\n        uint256 _totalDebtTokenSupply\n    )\n        external\n        onlyTrenBoxManagerOperations\n    {\n        uint256 decayedBaseRate = _calcDecayedBaseRate(_asset);\n        uint256 redeemedDebtFraction = (_assetDrawn * _price) / _totalDebtTokenSupply;\n        uint256 newBaseRate = decayedBaseRate + (redeemedDebtFraction / BETA);\n        newBaseRate = TrenMath._min(newBaseRate, DECIMAL_PRECISION);\n        assert(newBaseRate > 0);\n\n        baseRate[_asset] = newBaseRate;\n        emit BaseRateUpdated(_asset, newBaseRate);\n        _updateLastFeeOpTime(_asset);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function applyPendingRewards(\n        address _asset,\n        address _borrower\n    )\n        external\n        override\n        nonReentrant\n        onlyTrenBoxManagerOperationsOrBorrowerOperations\n    {\n        return _applyPendingRewards(_asset, _borrower);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function movePendingTrenBoxRewardsFromLiquidatedToActive(\n        address _asset,\n        uint256 _debt,\n        uint256 _assetAmount\n    )\n        external\n        override\n        onlyTrenBoxManagerOperations\n    {\n        _movePendingTrenBoxRewardsFromLiquidatedToActive(_asset, _debt, _assetAmount);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function updateTrenBoxRewardSnapshots(\n        address _asset,\n        address _borrower\n    )\n        external\n        override\n        onlyBorrowerOperations\n    {\n        return _updateTrenBoxRewardSnapshots(_asset, _borrower);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function updateStakeAndTotalStakes(\n        address _asset,\n        address _borrower\n    )\n        external\n        override\n        onlyBorrowerOperations\n        returns (uint256)\n    {\n        return _updateStakeAndTotalStakes(_asset, _borrower);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function removeStake(\n        address _asset,\n        address _borrower\n    )\n        external\n        override\n        onlyTrenBoxManagerOperationsOrBorrowerOperations\n    {\n        return _removeStake(_asset, _borrower);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function redistributeDebtAndColl(\n        address _asset,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _debtToOffset,\n        uint256 _collToSendToStabilityPool\n    )\n        external\n        override\n        nonReentrant\n        onlyTrenBoxManagerOperations\n    {\n        IStabilityPool(stabilityPool).offset(_debtToOffset, _asset, _collToSendToStabilityPool);\n\n        if (_debt == 0) {\n            return;\n        }\n        /*\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses\n        a \"feedback\"\n        * error correction, to keep the cumulative error low in the running totals L_Colls and\n        L_Debts:\n         *\n        * 1) Form numerators which compensate for the floor division errors that occurred the last\n        time this\n         * function was called.\n         * 2) Calculate \"per-unit-staked\" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division\n        error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this \"division before multiplication\",\n        however, it is intended.\n         */\n        uint256 collNumerator = (_coll * DECIMAL_PRECISION) + lastCollError_Redistribution[_asset];\n        uint256 debtNumerator = (_debt * DECIMAL_PRECISION) + lastDebtError_Redistribution[_asset];\n\n        // Get the per-unit-staked terms\n        uint256 assetStakes = totalStakes[_asset];\n        uint256 collRewardPerUnitStaked = collNumerator / assetStakes;\n        uint256 debtRewardPerUnitStaked = debtNumerator / assetStakes;\n\n        lastCollError_Redistribution[_asset] =\n            collNumerator - (collRewardPerUnitStaked * assetStakes);\n        lastDebtError_Redistribution[_asset] =\n            debtNumerator - (debtRewardPerUnitStaked * assetStakes);\n\n        // Add per-unit-staked terms to the running totals\n        uint256 liquidatedColl = L_Colls[_asset] + collRewardPerUnitStaked;\n        uint256 liquidatedDebt = L_Debts[_asset] + debtRewardPerUnitStaked;\n        L_Colls[_asset] = liquidatedColl;\n        L_Debts[_asset] = liquidatedDebt;\n        emit LTermsUpdated(_asset, liquidatedColl, liquidatedDebt);\n\n        ITrenBoxStorage(trenBoxStorage).updateDebtAndCollateralBalances(_asset, _debt, _coll, false);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function updateSystemSnapshots_excludeCollRemainder(\n        address _asset,\n        uint256 _collRemainder\n    )\n        external\n        onlyTrenBoxManagerOperations\n    {\n        uint256 totalStakesCached = totalStakes[_asset];\n        totalStakesSnapshot[_asset] = totalStakesCached;\n        uint256 totalColl = ITrenBoxStorage(trenBoxStorage).getTotalCollateralBalance(_asset);\n        uint256 _totalCollateralSnapshot = totalColl - _collRemainder;\n        totalCollateralSnapshot[_asset] = _totalCollateralSnapshot;\n        emit SystemSnapshotsUpdated(_asset, totalStakesCached, _totalCollateralSnapshot);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function closeTrenBox(\n        address _asset,\n        address _borrower\n    )\n        external\n        override\n        onlyTrenBoxManagerOperationsOrBorrowerOperations\n    {\n        return _closeTrenBox(_asset, _borrower, Status.closedByOwner);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function closeTrenBoxLiquidation(\n        address _asset,\n        address _borrower\n    )\n        external\n        override\n        onlyTrenBoxManagerOperations\n    {\n        _closeTrenBox(_asset, _borrower, Status.closedByLiquidation);\n        IFeeCollector(feeCollector).liquidateDebt(_borrower, _asset);\n        emit TrenBoxUpdated(\n            _asset, _borrower, 0, 0, 0, TrenBoxManagerOperation.liquidateInNormalMode\n        );\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function closeTrenBoxRedistribution(\n        address _asset,\n        address _borrower,\n        uint256 _debtTokenGasCompensation\n    )\n        external\n        onlyTrenBoxManagerOperations\n    {\n        _closeTrenBox(_asset, _borrower, Status.closedByRedistribution);\n        IFeeCollector(feeCollector).liquidateDebt(_borrower, _asset);\n        emit TrenBoxUpdated(\n            _asset, _borrower, 0, 0, 0, TrenBoxManagerOperation.redistributeCollateral\n        );\n        IDebtToken(debtToken).burn(trenBoxStorage, _debtTokenGasCompensation);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function sendGasCompensation(\n        address _asset,\n        address _liquidator,\n        uint256 _debtTokenAmount,\n        uint256 _assetAmount\n    )\n        external\n        nonReentrant\n        onlyTrenBoxManagerOperations\n    {\n        if (_debtTokenAmount != 0) {\n            IDebtToken(debtToken).returnFromPool(trenBoxStorage, _liquidator, _debtTokenAmount);\n        }\n        if (_assetAmount != 0) {\n            ITrenBoxStorage(trenBoxStorage).sendCollateral(_asset, _liquidator, _assetAmount);\n        }\n    }\n\n    // --- TrenBox property setters, called by Tren's\n    // BorrowerOperations/VMRedemptions/VMLiquidations ---------------\n\n    /// @inheritdoc ITrenBoxManager\n    function setTrenBoxStatus(\n        address _asset,\n        address _borrower,\n        uint256 _num\n    )\n        external\n        override\n        onlyBorrowerOperations\n    {\n        TrenBoxes[_borrower][_asset].status = Status(_num);\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function increaseTrenBoxColl(\n        address _asset,\n        address _borrower,\n        uint256 _collIncrease\n    )\n        external\n        override\n        onlyBorrowerOperations\n        returns (uint256 newColl)\n    {\n        TrenBox storage trenBox = TrenBoxes[_borrower][_asset];\n        newColl = trenBox.coll + _collIncrease;\n        trenBox.coll = newColl;\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function decreaseTrenBoxColl(\n        address _asset,\n        address _borrower,\n        uint256 _collDecrease\n    )\n        external\n        override\n        onlyBorrowerOperations\n        returns (uint256 newColl)\n    {\n        TrenBox storage trenBox = TrenBoxes[_borrower][_asset];\n        newColl = trenBox.coll - _collDecrease;\n        trenBox.coll = newColl;\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function increaseTrenBoxDebt(\n        address _asset,\n        address _borrower,\n        uint256 _debtIncrease\n    )\n        external\n        override\n        onlyBorrowerOperations\n        returns (uint256 newDebt)\n    {\n        TrenBox storage trenBox = TrenBoxes[_borrower][_asset];\n        newDebt = trenBox.debt + _debtIncrease;\n        trenBox.debt = newDebt;\n    }\n\n    /// @inheritdoc ITrenBoxManager\n    function decreaseTrenBoxDebt(\n        address _asset,\n        address _borrower,\n        uint256 _debtDecrease\n    )\n        external\n        override\n        onlyBorrowerOperations\n        returns (uint256)\n    {\n        TrenBox storage trenBox = TrenBoxes[_borrower][_asset];\n        uint256 oldDebt = trenBox.debt;\n        if (_debtDecrease == 0) {\n            return oldDebt; // no changes\n        }\n        uint256 paybackFraction = (_debtDecrease * 1 ether) / oldDebt;\n        uint256 newDebt = oldDebt - _debtDecrease;\n        trenBox.debt = newDebt;\n        if (paybackFraction != 0) {\n            IFeeCollector(feeCollector).decreaseDebt(_borrower, _asset, paybackFraction);\n        }\n        return newDebt;\n    }\n\n    // Internal functions\n    // ---------------------------------------------------------------------------------------------\n\n    /**\n     * @dev Burns redeemed debt tokens, sends collateral to redeemer and moves collateral from\n     * active collateral pool to claimable collateral pool.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _debtTokenAmount The amount of debt tokens redeemed.\n     * @param _assetAmount The amount of collateral asset to draw.\n     */\n    function _redeemCloseTrenBox(\n        address _asset,\n        address _borrower,\n        uint256 _debtTokenAmount,\n        uint256 _assetAmount\n    )\n        internal\n    {\n        IDebtToken(debtToken).burn(trenBoxStorage, _debtTokenAmount);\n\n        ITrenBoxStorage(trenBoxStorage).decreaseActiveBalancesAfterRedemption(\n            _asset, _debtTokenAmount, _assetAmount\n        );\n        ITrenBoxStorage(trenBoxStorage).updateUserAndEntireClaimableBalance(\n            _asset, _borrower, _assetAmount\n        );\n    }\n\n    /**\n     * @dev Moves a TrenBox's pending debt and collateral rewards from liquidations\n     * to TrenBoxStorage contract.\n     * @param _asset The address of collateral asset.\n     * @param _debtTokenAmount The pending rewards of debt tokens.\n     * @param _assetAmount The pending rewards of collateral asset.\n     */\n    function _movePendingTrenBoxRewardsFromLiquidatedToActive(\n        address _asset,\n        uint256 _debtTokenAmount,\n        uint256 _assetAmount\n    )\n        internal\n    {\n        ITrenBoxStorage(trenBoxStorage).updateDebtAndCollateralBalances(\n            _asset, _debtTokenAmount, _assetAmount, true\n        );\n    }\n\n    /**\n     * @dev Gets current collateral and debt balances of a specific TrenBox.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function _getCurrentTrenBoxAmounts(\n        address _asset,\n        address _borrower\n    )\n        internal\n        view\n        returns (uint256 coll, uint256 debt)\n    {\n        uint256 pendingCollReward = getPendingAssetReward(_asset, _borrower);\n        uint256 pendingDebtReward = getPendingDebtTokenReward(_asset, _borrower);\n        TrenBox memory trenBox = TrenBoxes[_borrower][_asset];\n        coll = trenBox.coll + pendingCollReward;\n        debt = trenBox.debt + pendingDebtReward;\n    }\n\n    /**\n     * @dev Adds the borrowers's collateral and debt rewards earned from redistributions &\n     * liquidations to their TrenBoxes.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function _applyPendingRewards(address _asset, address _borrower) internal {\n        if (!hasPendingRewards(_asset, _borrower)) {\n            return;\n        }\n\n        // Compute pending rewards\n        uint256 pendingCollReward = getPendingAssetReward(_asset, _borrower);\n        uint256 pendingDebtReward = getPendingDebtTokenReward(_asset, _borrower);\n\n        // Apply pending rewards to trenBox's state\n        TrenBox storage trenBox = TrenBoxes[_borrower][_asset];\n        trenBox.coll = trenBox.coll + pendingCollReward;\n        trenBox.debt = trenBox.debt + pendingDebtReward;\n\n        _updateTrenBoxRewardSnapshots(_asset, _borrower);\n\n        // Move liquidated rewards to active in TrenBoxStorage\n        _movePendingTrenBoxRewardsFromLiquidatedToActive(\n            _asset, pendingDebtReward, pendingCollReward\n        );\n\n        emit TrenBoxUpdated(\n            _asset,\n            _borrower,\n            trenBox.debt,\n            trenBox.coll,\n            trenBox.stake,\n            TrenBoxManagerOperation.applyPendingRewards\n        );\n    }\n\n    /**\n     * @dev Updates the borrower's snapshots of L_Colls and L_Debts to reflect the current values\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function _updateTrenBoxRewardSnapshots(address _asset, address _borrower) internal {\n        uint256 liquidatedColl = L_Colls[_asset];\n        uint256 liquidatedDebt = L_Debts[_asset];\n        RewardSnapshot storage snapshot = rewardSnapshots[_borrower][_asset];\n        snapshot.asset = liquidatedColl;\n        snapshot.debt = liquidatedDebt;\n        emit TrenBoxSnapshotsUpdated(_asset, liquidatedColl, liquidatedDebt);\n    }\n\n    /**\n     * @dev Removes the borrower's stake amount from total staked amount.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function _removeStake(address _asset, address _borrower) internal {\n        TrenBox storage trenBox = TrenBoxes[_borrower][_asset];\n        totalStakes[_asset] -= trenBox.stake;\n        trenBox.stake = 0;\n    }\n\n    /**\n     * @dev Updates the borrower's stake based on their latest collateral value.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     */\n    function _updateStakeAndTotalStakes(\n        address _asset,\n        address _borrower\n    )\n        internal\n        returns (uint256)\n    {\n        TrenBox storage trenBox = TrenBoxes[_borrower][_asset];\n        uint256 newStake = _computeNewStake(_asset, trenBox.coll);\n        uint256 oldStake = trenBox.stake;\n        trenBox.stake = newStake;\n        uint256 newTotal = totalStakes[_asset] - oldStake + newStake;\n        totalStakes[_asset] = newTotal;\n        emit TotalStakesUpdated(_asset, newTotal);\n        return newStake;\n    }\n\n    /**\n     * @dev Calculates a new stake based on the snapshots of the totalStakes and totalCollateral\n     * taken at the last liquidation.\n     * @param _asset The address of collateral asset.\n     * @param _coll The balance of collateral asset.\n     */\n    function _computeNewStake(\n        address _asset,\n        uint256 _coll\n    )\n        internal\n        view\n        returns (uint256 stake)\n    {\n        uint256 assetColl = totalCollateralSnapshot[_asset];\n        if (assetColl == 0) {\n            stake = _coll;\n        } else {\n            uint256 assetStakes = totalStakesSnapshot[_asset];\n            /*\n             * The following assert() holds true because:\n             * - The system always contains >= 1 trenBox\n            * - When we close or liquidate a trenBox, we redistribute the pending rewards, so if all\n            trenBoxes were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n             */\n            assert(assetStakes != 0);\n            stake = (_coll * assetStakes) / assetColl;\n        }\n    }\n\n    /**\n     * @dev Closes a TrenBox.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _closedStatus The closed status.\n     */\n    function _closeTrenBox(address _asset, address _borrower, Status _closedStatus) internal {\n        assert(_closedStatus != Status.nonExistent && _closedStatus != Status.active);\n\n        uint256 TrenBoxOwnersArrayLength = trenBoxOwners[_asset].length;\n        if (TrenBoxOwnersArrayLength <= 1 || ISortedTrenBoxes(sortedTrenBoxes).getSize(_asset) <= 1)\n        {\n            revert TrenBoxManager__OnlyOneTrenBox();\n        }\n\n        TrenBox storage trenBox = TrenBoxes[_borrower][_asset];\n        trenBox.status = _closedStatus;\n        trenBox.coll = 0;\n        trenBox.debt = 0;\n\n        RewardSnapshot storage rewardSnapshot = rewardSnapshots[_borrower][_asset];\n        rewardSnapshot.asset = 0;\n        rewardSnapshot.debt = 0;\n\n        _removeTrenBoxOwner(_asset, _borrower, TrenBoxOwnersArrayLength);\n        ISortedTrenBoxes(sortedTrenBoxes).remove(_asset, _borrower);\n    }\n\n    /**\n     * @dev Removes a specific TrenBox's owner.\n     * @param _asset The address of collateral asset.\n     * @param _borrower The borrower address.\n     * @param _TrenBoxOwnersArrayLength The number of owners.\n     */\n    function _removeTrenBoxOwner(\n        address _asset,\n        address _borrower,\n        uint256 _TrenBoxOwnersArrayLength\n    )\n        internal\n    {\n        TrenBox memory trenBox = TrenBoxes[_borrower][_asset];\n        assert(trenBox.status != Status.nonExistent && trenBox.status != Status.active);\n\n        uint128 index = trenBox.arrayIndex;\n        uint256 length = _TrenBoxOwnersArrayLength;\n        uint256 idxLast = length - 1;\n\n        assert(index <= idxLast);\n\n        address[] storage trenBoxAssetOwners = trenBoxOwners[_asset];\n        address addressToMove = trenBoxAssetOwners[idxLast];\n\n        trenBoxAssetOwners[index] = addressToMove;\n        TrenBoxes[addressToMove][_asset].arrayIndex = index;\n        emit TrenBoxIndexUpdated(_asset, addressToMove, index);\n\n        trenBoxAssetOwners.pop();\n    }\n\n    /**\n     * @dev Calculates the redemption rate.\n     * @param _asset The address of collateral asset.\n     * @param _baseRate The base redemption rate.\n     */\n    function _calcRedemptionRate(\n        address _asset,\n        uint256 _baseRate\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return TrenMath._min(\n            IAdminContract(adminContract).getRedemptionFeeFloor(_asset) + _baseRate,\n            DECIMAL_PRECISION\n        );\n    }\n\n    /**\n     * @dev Calculates the redemption fee on the amount to draw.\n     * @param _redemptionRate The redemption rate.\n     * @param _assetDraw The collateral amount to draw.\n     */\n    function _calcRedemptionFee(\n        uint256 _redemptionRate,\n        uint256 _assetDraw\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 redemptionFee = (_redemptionRate * _assetDraw) / DECIMAL_PRECISION;\n        if (redemptionFee >= _assetDraw) {\n            revert TrenBoxManager__FeeBiggerThanAssetDraw();\n        }\n        return redemptionFee;\n    }\n\n    /**\n     * @dev Updates the last fee operation time only if time passed >= decay interval. This\n     * prevents base rate griefing.\n     * @param _asset The address of collateral asset.\n     */\n    function _updateLastFeeOpTime(address _asset) internal {\n        uint256 timePassed = block.timestamp - lastFeeOperationTime[_asset];\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime[_asset] = block.timestamp;\n            emit LastFeeOpTimeUpdated(_asset, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Calculates the decayed base rate for a specific collateral asset.\n     * @param _asset The address of collateral asset.\n     */\n    function _calcDecayedBaseRate(address _asset) internal view returns (uint256) {\n        uint256 minutesPassed = _minutesPassedSinceLastFeeOp(_asset);\n        uint256 decayFactor = TrenMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n        return (baseRate[_asset] * decayFactor) / DECIMAL_PRECISION;\n    }\n\n    /**\n     * @dev Calculates the minutes passed from last fee operation.\n     * @param _asset The address of collateral asset.\n     */\n    function _minutesPassedSinceLastFeeOp(address _asset) internal view returns (uint256) {\n        return (block.timestamp - lastFeeOperationTime[_asset]) / SECONDS_IN_ONE_MINUTE;\n    }\n\n    function authorizeUpgrade(address newImplementation) public {\n        _authorizeUpgrade(newImplementation);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner { }\n}\n"
    },
    "contracts/TrenBoxManagerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { UUPSUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport { TrenBase } from \"./Dependencies/TrenBase.sol\";\nimport { TrenMath, DECIMAL_PRECISION } from \"./Dependencies/TrenMath.sol\";\n\nimport { IAdminContract } from \"./Interfaces/IAdminContract.sol\";\nimport { IDebtToken } from \"./Interfaces/IDebtToken.sol\";\nimport { IPriceFeed } from \"./Interfaces/IPriceFeed.sol\";\nimport { ISortedTrenBoxes } from \"./Interfaces/ISortedTrenBoxes.sol\";\nimport { IStabilityPool } from \"./Interfaces/IStabilityPool.sol\";\nimport { ITrenBoxManager } from \"./Interfaces/ITrenBoxManager.sol\";\nimport { ITrenBoxManagerOperations } from \"./Interfaces/ITrenBoxManagerOperations.sol\";\nimport { ITrenBoxStorage } from \"./Interfaces/ITrenBoxStorage.sol\";\n\n/// @title TrenBoxManagerOperations\n/// @notice A contract with main operation functionality such as redemption, redistribution and\n/// liquidation.\ncontract TrenBoxManagerOperations is\n    ITrenBoxManagerOperations,\n    UUPSUpgradeable,\n    ReentrancyGuardUpgradeable,\n    TrenBase\n{\n    /// @notice The contract name.\n    string public constant NAME = \"TrenBoxManagerOperations\";\n\n    /// @notice The percentage divider.\n    uint256 public constant PERCENTAGE_PRECISION = 10_000;\n    /// @notice The array limit.\n    uint256 public constant BATCH_SIZE_LIMIT = 25;\n    /// @notice The redemption softening peram.\n    uint256 public redemptionSofteningParam;\n\n    // ------------------------------------- Initializer ------------------------------------------\n\n    /**\n     * @dev Runs all the setup logic only once.\n     * @param initialOwner The address of initial owner.\n     */\n    function initialize(address initialOwner) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n    }\n\n    // -------------------------------- Liquidation external functions ----------------------------\n\n    /// @inheritdoc ITrenBoxManagerOperations\n    function liquidate(address _asset, address _borrower) external override {\n        if (!ITrenBoxManager(trenBoxManager).isTrenBoxActive(_asset, _borrower)) {\n            revert TrenBoxManagerOperations__TrenBoxNotActive();\n        }\n        address[] memory borrowers = new address[](1);\n        borrowers[0] = _borrower;\n        batchLiquidateTrenBoxes(_asset, borrowers);\n    }\n\n    /// @inheritdoc ITrenBoxManagerOperations\n    function liquidateTrenBoxes(address _asset, uint256 _n) external override nonReentrant {\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n        vars.price = IPriceFeed(priceFeed).fetchPrice(_asset);\n        vars.debtTokenInStabPool = IStabilityPool(stabilityPool).getTotalDebtTokenDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode(_asset, vars.price);\n\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalsFromLiquidateTrenBoxesSequence_RecoveryMode(\n                _asset, vars.price, vars.debtTokenInStabPool, _n, false\n            );\n        } else {\n            totals = _getTotalsFromLiquidateTrenBoxesSequence_NormalMode(\n                _asset, vars.price, vars.debtTokenInStabPool, _n, false\n            );\n        }\n\n        if (totals.totalDebtInSequence == 0) {\n            revert TrenBoxManagerOperations__NothingToLiquidate();\n        }\n\n        ITrenBoxManager(trenBoxManager).redistributeDebtAndColl(\n            _asset,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute,\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP\n        );\n        if (totals.totalCollToClaim != 0) {\n            ITrenBoxStorage(trenBoxStorage).decreaseActiveCollateral(\n                _asset, totals.totalCollToClaim\n            );\n            ITrenBoxStorage(trenBoxStorage).increaseClaimableCollateral(\n                _asset, totals.totalCollToClaim\n            );\n        }\n\n        ITrenBoxManager(trenBoxManager).updateSystemSnapshots_excludeCollRemainder(\n            _asset, totals.totalCollGasCompensation\n        );\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl =\n            totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollToClaim;\n        emit Liquidation(\n            _asset,\n            vars.liquidatedDebt,\n            vars.liquidatedColl,\n            totals.totalCollGasCompensation,\n            totals.totalDebtTokenGasCompensation\n        );\n        ITrenBoxManager(trenBoxManager).sendGasCompensation(\n            _asset,\n            msg.sender,\n            totals.totalDebtTokenGasCompensation,\n            totals.totalCollGasCompensation\n        );\n    }\n\n    /// @inheritdoc ITrenBoxManagerOperations\n    function batchLiquidateTrenBoxes(\n        address _asset,\n        address[] memory _trenBoxArray\n    )\n        public\n        override\n        nonReentrant\n    {\n        if (_trenBoxArray.length == 0 || _trenBoxArray.length > BATCH_SIZE_LIMIT) {\n            revert TrenBoxManagerOperations__InvalidArraySize();\n        }\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.debtTokenInStabPool = IStabilityPool(stabilityPool).getTotalDebtTokenDeposits();\n        vars.price = IPriceFeed(priceFeed).fetchPrice(_asset);\n        vars.recoveryModeAtStart = _checkRecoveryMode(_asset, vars.price);\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                _asset, vars.price, vars.debtTokenInStabPool, _trenBoxArray\n            );\n        } else {\n            totals = _getTotalsFromBatchLiquidate_NormalMode(\n                _asset, vars.price, vars.debtTokenInStabPool, _trenBoxArray\n            );\n        }\n\n        if (totals.totalDebtInSequence == 0) {\n            revert TrenBoxManagerOperations__NothingToLiquidate();\n        }\n\n        ITrenBoxManager(trenBoxManager).redistributeDebtAndColl(\n            _asset,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute,\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP\n        );\n        if (totals.totalCollToClaim != 0) {\n            ITrenBoxStorage(trenBoxStorage).decreaseActiveCollateral(\n                _asset, totals.totalCollToClaim\n            );\n            ITrenBoxStorage(trenBoxStorage).increaseClaimableCollateral(\n                _asset, totals.totalCollToClaim\n            );\n        }\n\n        // Update system snapshots\n        ITrenBoxManager(trenBoxManager).updateSystemSnapshots_excludeCollRemainder(\n            _asset, totals.totalCollGasCompensation\n        );\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        vars.liquidatedColl =\n            totals.totalCollInSequence - totals.totalCollGasCompensation - totals.totalCollToClaim;\n        emit Liquidation(\n            _asset,\n            vars.liquidatedDebt,\n            vars.liquidatedColl,\n            totals.totalCollGasCompensation,\n            totals.totalDebtTokenGasCompensation\n        );\n        ITrenBoxManager(trenBoxManager).sendGasCompensation(\n            _asset,\n            msg.sender,\n            totals.totalDebtTokenGasCompensation,\n            totals.totalCollGasCompensation\n        );\n    }\n\n    /**\n     * @notice Redistribute (liquidate by protocol) a sequence of low-value trenBoxes.\n     * Closes a maximum number of _trenBoxes under-collateralized TrenBoxes,\n     * starting from the one with the lowest collateral ratio in the system, and moving upwards.\n     * @param _asset The address of collateral asset.\n     * @param _trenBoxes The list of TrenBoxes that should be redistributed.\n     */\n    function redistributeTrenBoxes(\n        address _asset,\n        uint256 _trenBoxes\n    )\n        external\n        nonReentrant\n        onlyOwner\n    {\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.debtTokenInStabPool = IStabilityPool(stabilityPool).getTotalDebtTokenDeposits();\n        vars.price = IPriceFeed(priceFeed).fetchPrice(_asset);\n        vars.recoveryModeAtStart = _checkRecoveryMode(_asset, vars.price);\n\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalsFromLiquidateTrenBoxesSequence_RecoveryMode(\n                _asset, vars.price, vars.debtTokenInStabPool, _trenBoxes, true\n            );\n        } else {\n            totals = _getTotalsFromLiquidateTrenBoxesSequence_NormalMode(\n                _asset, vars.price, vars.debtTokenInStabPool, _trenBoxes, true\n            );\n        }\n\n        if (totals.totalDebtInSequence == 0) {\n            revert TrenBoxManagerOperations__NothingToLiquidate();\n        }\n\n        ITrenBoxManager(trenBoxManager).redistributeDebtAndColl(\n            _asset,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute,\n            totals.totalDebtToOffset,\n            0\n        );\n\n        emit Redistribution(\n            _asset,\n            totals.totalDebtInSequence,\n            totals.totalCollInSequence - totals.totalCollToClaim,\n            totals.totalDebtTokenGasCompensation\n        );\n    }\n\n    // -------------------------------- Redemption external functions -----------------------------\n\n    /// @inheritdoc ITrenBoxManagerOperations\n    function redeemCollateral(\n        address _asset,\n        uint256 _debtTokenAmount,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        address _firstRedemptionHint,\n        uint256 _partialRedemptionHintNICR,\n        uint256 _maxIterations,\n        uint256 _maxFeePercentage\n    )\n        external\n        override\n        nonReentrant\n    {\n        RedemptionTotals memory totals;\n        totals.price = IPriceFeed(priceFeed).fetchPrice(_asset);\n        _validateRedemptionRequirements(_asset, _maxFeePercentage, _debtTokenAmount, totals.price);\n        totals.totalDebtTokenSupplyAtStart = getEntireSystemDebt(_asset);\n        totals.remainingDebt = _debtTokenAmount;\n        address currentBorrower;\n        if (\n            ITrenBoxManager(trenBoxManager).isValidFirstRedemptionHint(\n                _asset, _firstRedemptionHint, totals.price\n            )\n        ) {\n            currentBorrower = _firstRedemptionHint;\n        } else {\n            currentBorrower = ISortedTrenBoxes(sortedTrenBoxes).getLast(_asset);\n            while (\n                currentBorrower != address(0)\n                    && ITrenBoxManager(trenBoxManager).getCurrentICR(\n                        _asset, currentBorrower, totals.price\n                    ) < IAdminContract(adminContract).getMcr(_asset)\n            ) {\n                currentBorrower = ISortedTrenBoxes(sortedTrenBoxes).getPrev(_asset, currentBorrower);\n            }\n        }\n\n        // Loop through the trenBoxes starting from the one with lowest collateral ratio until\n        // _debtTokenAmount is exchanged for collateral\n        if (_maxIterations == 0) {\n            _maxIterations = type(uint256).max;\n        }\n        while (currentBorrower != address(0) && totals.remainingDebt != 0 && _maxIterations != 0) {\n            _maxIterations--;\n            // Save the address of the trenBox preceding the current one, before potentially\n            // modifying the list\n            address nextUserToCheck =\n                ISortedTrenBoxes(sortedTrenBoxes).getPrev(_asset, currentBorrower);\n\n            ITrenBoxManager(trenBoxManager).applyPendingRewards(_asset, currentBorrower);\n\n            SingleRedemptionValues memory singleRedemption = _redeemCollateralFromTrenBox(\n                _asset,\n                currentBorrower,\n                totals.remainingDebt,\n                totals.price,\n                _upperPartialRedemptionHint,\n                _lowerPartialRedemptionHint,\n                _partialRedemptionHintNICR\n            );\n\n            if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled\n                // (out-of-date hint, or new net debt < minimum), therefore we could not redeem from\n                // the last TrenBox\n\n            totals.totalDebtToRedeem = totals.totalDebtToRedeem + singleRedemption.debtLot;\n            totals.totalCollDrawn = totals.totalCollDrawn + singleRedemption.collLot;\n\n            totals.remainingDebt = totals.remainingDebt - singleRedemption.debtLot;\n            currentBorrower = nextUserToCheck;\n        }\n        if (totals.totalCollDrawn == 0) {\n            revert TrenBoxManagerOperations__UnableToRedeemAnyAmount();\n        }\n\n        ITrenBoxManager(trenBoxManager).updateBaseRateFromRedemption(\n            _asset, totals.totalCollDrawn, totals.price, totals.totalDebtTokenSupplyAtStart\n        );\n\n        totals.collFee =\n            ITrenBoxManager(trenBoxManager).getRedemptionFee(_asset, totals.totalCollDrawn);\n\n        _requireUserAcceptsFee(totals.collFee, totals.totalCollDrawn, _maxFeePercentage);\n\n        ITrenBoxManager(trenBoxManager).finalizeRedemption(\n            _asset, msg.sender, totals.totalDebtToRedeem, totals.collFee, totals.totalCollDrawn\n        );\n\n        emit Redemption(\n            _asset,\n            _debtTokenAmount,\n            totals.totalDebtToRedeem,\n            totals.totalCollDrawn,\n            totals.collFee\n        );\n    }\n\n    // ------------------------------------- Hint helper functions --------------------------------\n\n    /// @inheritdoc ITrenBoxManagerOperations\n    function getRedemptionHints(\n        address _asset,\n        uint256 _debtTokenAmount,\n        uint256 _price,\n        uint256 _maxIterations\n    )\n        external\n        view\n        override\n        returns (\n            address firstRedemptionHint,\n            uint256 partialRedemptionHintNewICR,\n            uint256 truncatedDebtTokenAmount\n        )\n    {\n        LocalVariables_HintHelper memory vars = LocalVariables_HintHelper({\n            asset: _asset,\n            debtTokenAmount: _debtTokenAmount,\n            price: _price,\n            maxIterations: _maxIterations\n        });\n\n        uint256 remainingDebt = _debtTokenAmount;\n        address currentTrenBoxBorrower = ISortedTrenBoxes(sortedTrenBoxes).getLast(vars.asset);\n\n        while (\n            currentTrenBoxBorrower != address(0)\n                && ITrenBoxManager(trenBoxManager).getCurrentICR(\n                    vars.asset, currentTrenBoxBorrower, vars.price\n                ) < IAdminContract(adminContract).getMcr(vars.asset)\n        ) {\n            currentTrenBoxBorrower =\n                ISortedTrenBoxes(sortedTrenBoxes).getPrev(vars.asset, currentTrenBoxBorrower);\n        }\n\n        firstRedemptionHint = currentTrenBoxBorrower;\n\n        if (vars.maxIterations == 0) {\n            vars.maxIterations = type(uint256).max;\n        }\n\n        while (\n            currentTrenBoxBorrower != address(0) && remainingDebt != 0 && vars.maxIterations-- != 0\n        ) {\n            uint256 currentTrenBoxNetDebt = _getNetDebt(\n                vars.asset,\n                ITrenBoxManager(trenBoxManager).getTrenBoxDebt(vars.asset, currentTrenBoxBorrower)\n                    + ITrenBoxManager(trenBoxManager).getPendingDebtTokenReward(\n                        vars.asset, currentTrenBoxBorrower\n                    )\n            );\n\n            if (currentTrenBoxNetDebt <= remainingDebt) {\n                remainingDebt = remainingDebt - currentTrenBoxNetDebt;\n            } else {\n                if (currentTrenBoxNetDebt > IAdminContract(adminContract).getMinNetDebt(vars.asset))\n                {\n                    uint256 maxRedeemableDebt = TrenMath._min(\n                        remainingDebt,\n                        currentTrenBoxNetDebt\n                            - IAdminContract(adminContract).getMinNetDebt(vars.asset)\n                    );\n                    uint256 currentTrenBoxColl = ITrenBoxManager(trenBoxManager).getTrenBoxColl(\n                        vars.asset, currentTrenBoxBorrower\n                    )\n                        + ITrenBoxManager(trenBoxManager).getPendingAssetReward(\n                            vars.asset, currentTrenBoxBorrower\n                        );\n\n                    uint256 collLot = (maxRedeemableDebt * DECIMAL_PRECISION) / vars.price;\n                    // Apply redemption softening\n                    collLot = (collLot * redemptionSofteningParam) / PERCENTAGE_PRECISION;\n                    uint256 newColl = currentTrenBoxColl - collLot;\n                    uint256 newDebt = currentTrenBoxNetDebt - maxRedeemableDebt;\n                    uint256 compositeDebt = _getCompositeDebt(vars.asset, newDebt);\n\n                    partialRedemptionHintNewICR = TrenMath._computeNominalCR(newColl, compositeDebt);\n                    remainingDebt = remainingDebt - maxRedeemableDebt;\n                }\n\n                break;\n            }\n\n            currentTrenBoxBorrower =\n                ISortedTrenBoxes(sortedTrenBoxes).getPrev(vars.asset, currentTrenBoxBorrower);\n        }\n\n        truncatedDebtTokenAmount = _debtTokenAmount - remainingDebt;\n    }\n\n    /// @inheritdoc ITrenBoxManagerOperations\n    function getApproxHint(\n        address _asset,\n        uint256 _CR,\n        uint256 _numTrials,\n        uint256 _inputRandomSeed\n    )\n        external\n        view\n        override\n        returns (address hintAddress, uint256 diff, uint256 latestRandomSeed)\n    {\n        uint256 arrayLength = ITrenBoxManager(trenBoxManager).getTrenBoxOwnersCount(_asset);\n\n        if (arrayLength == 0) {\n            return (address(0), 0, _inputRandomSeed);\n        }\n\n        hintAddress = ISortedTrenBoxes(sortedTrenBoxes).getLast(_asset);\n        diff = TrenMath._getAbsoluteDifference(\n            _CR, ITrenBoxManager(trenBoxManager).getNominalICR(_asset, hintAddress)\n        );\n        latestRandomSeed = _inputRandomSeed;\n\n        uint256 i = 1;\n\n        while (i < _numTrials) {\n            latestRandomSeed = uint256(keccak256(abi.encodePacked(latestRandomSeed)));\n\n            uint256 arrayIndex = latestRandomSeed % arrayLength;\n            address currentAddress =\n                ITrenBoxManager(trenBoxManager).getTrenBoxFromTrenBoxOwnersArray(_asset, arrayIndex);\n            uint256 currentNICR =\n                ITrenBoxManager(trenBoxManager).getNominalICR(_asset, currentAddress);\n\n            // check if abs(current - CR) > abs(closest - CR), and update closest if current is\n            // closer\n            uint256 currentDiff = TrenMath._getAbsoluteDifference(currentNICR, _CR);\n\n            if (currentDiff < diff) {\n                diff = currentDiff;\n                hintAddress = currentAddress;\n            }\n            i++;\n        }\n    }\n\n    /// @inheritdoc ITrenBoxManagerOperations\n    function computeNominalCR(\n        uint256 _coll,\n        uint256 _debt\n    )\n        external\n        pure\n        override\n        returns (uint256)\n    {\n        return TrenMath._computeNominalCR(_coll, _debt);\n    }\n\n    // ------------------------------------- Internal functions -----------------------------------\n\n    /**\n     * @dev This function is used when the batch liquidation sequence starts during Recovery\n     * Mode.\n     * However, it handles the case where the system *leaves* Recovery Mode, part way\n     * through the liquidation sequence.\n     */\n    function _getTotalFromBatchLiquidate_RecoveryMode(\n        address _asset,\n        uint256 _price,\n        uint256 _debtTokenInStabPool,\n        address[] memory _trenBoxArray\n    )\n        internal\n        returns (LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        vars.remainingDebtTokenInStabPool = _debtTokenInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt(_asset);\n        vars.entireSystemColl = getEntireSystemColl(_asset);\n\n        for (uint256 i = 0; i < _trenBoxArray.length;) {\n            vars.user = _trenBoxArray[i];\n            // Skip non-active trenBoxes\n            if (\n                ITrenBoxManager(trenBoxManager).getTrenBoxStatus(_asset, vars.user)\n                    != uint256(ITrenBoxManager.Status.active)\n            ) {\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n            vars.ICR = ITrenBoxManager(trenBoxManager).getCurrentICR(_asset, vars.user, _price);\n\n            if (!vars.backToNormalMode) {\n                // Skip this TrenBox if ICR is greater than MCR and Stability Pool is empty\n                if (\n                    vars.ICR >= IAdminContract(adminContract).getMcr(_asset)\n                        && vars.remainingDebtTokenInStabPool == 0\n                ) {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n                uint256 TCR =\n                    TrenMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, _price);\n\n                singleLiquidation = _liquidateRecoveryMode(\n                    _asset,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingDebtTokenInStabPool,\n                    TCR,\n                    _price,\n                    false\n                );\n\n                // Update aggregate trackers\n                vars.remainingDebtTokenInStabPool =\n                    vars.remainingDebtTokenInStabPool - singleLiquidation.debtToOffset;\n                vars.entireSystemDebt = vars.entireSystemDebt - singleLiquidation.debtToOffset;\n                vars.entireSystemColl = vars.entireSystemColl - singleLiquidation.collToSendToSP\n                    - singleLiquidation.collGasCompensation - singleLiquidation.collToClaim;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    _asset, vars.entireSystemColl, vars.entireSystemDebt, _price\n                );\n            } else if (\n                vars.backToNormalMode && vars.ICR < IAdminContract(adminContract).getMcr(_asset)\n            ) {\n                singleLiquidation = _liquidateNormalMode(\n                    _asset, vars.user, vars.remainingDebtTokenInStabPool, false\n                );\n\n                vars.remainingDebtTokenInStabPool =\n                    vars.remainingDebtTokenInStabPool - singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev This function is used when the batch liquidation sequence starts during Normal\n     * Mode.\n     */\n    function _getTotalsFromBatchLiquidate_NormalMode(\n        address _asset,\n        uint256 _price,\n        uint256 _debtTokenInStabPool,\n        address[] memory _trenBoxArray\n    )\n        internal\n        returns (LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingDebtTokenInStabPool = _debtTokenInStabPool;\n\n        for (uint256 i = 0; i < _trenBoxArray.length;) {\n            vars.user = _trenBoxArray[i];\n            vars.ICR = ITrenBoxManager(trenBoxManager).getCurrentICR(_asset, vars.user, _price);\n\n            if (vars.ICR < IAdminContract(adminContract).getMcr(_asset)) {\n                singleLiquidation = _liquidateNormalMode(\n                    _asset, vars.user, vars.remainingDebtTokenInStabPool, false\n                );\n\n                vars.remainingDebtTokenInStabPool =\n                    vars.remainingDebtTokenInStabPool - singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Adds liquidation values to total value of all TrenBoxes.\n     */\n    function _addLiquidationValuesToTotals(\n        LiquidationTotals memory oldTotals,\n        LiquidationValues memory singleLiquidation\n    )\n        internal\n        pure\n        returns (LiquidationTotals memory newTotals)\n    {\n        // Tally all the values with their respective running totals\n        newTotals.totalCollGasCompensation =\n            oldTotals.totalCollGasCompensation + singleLiquidation.collGasCompensation;\n        newTotals.totalDebtTokenGasCompensation =\n            oldTotals.totalDebtTokenGasCompensation + singleLiquidation.debtTokenGasCompensation;\n        newTotals.totalDebtInSequence =\n            oldTotals.totalDebtInSequence + singleLiquidation.entireTrenBoxDebt;\n        newTotals.totalCollInSequence =\n            oldTotals.totalCollInSequence + singleLiquidation.entireTrenBoxColl;\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset + singleLiquidation.debtToOffset;\n        newTotals.totalCollToSendToSP =\n            oldTotals.totalCollToSendToSP + singleLiquidation.collToSendToSP;\n        newTotals.totalDebtToRedistribute =\n            oldTotals.totalDebtToRedistribute + singleLiquidation.debtToRedistribute;\n        newTotals.totalCollToRedistribute =\n            oldTotals.totalCollToRedistribute + singleLiquidation.collToRedistribute;\n        newTotals.totalCollToClaim = oldTotals.totalCollToClaim + singleLiquidation.collToClaim;\n        return newTotals;\n    }\n\n    function _getTotalsFromLiquidateTrenBoxesSequence_NormalMode(\n        address _asset,\n        uint256 _price,\n        uint256 _debtTokenInStabPool,\n        uint256 _n,\n        bool _fullRedistribution\n    )\n        internal\n        returns (LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingDebtTokenInStabPool = _debtTokenInStabPool;\n\n        for (uint256 i = 0; i < _n;) {\n            vars.user = ISortedTrenBoxes(sortedTrenBoxes).getLast(_asset);\n            vars.ICR = ITrenBoxManager(trenBoxManager).getCurrentICR(_asset, vars.user, _price);\n\n            if (vars.ICR < IAdminContract(adminContract).getMcr(_asset)) {\n                if (_fullRedistribution) {\n                    singleLiquidation = _liquidateNormalMode(\n                        _asset, vars.user, vars.remainingDebtTokenInStabPool, true\n                    );\n                } else {\n                    singleLiquidation = _liquidateNormalMode(\n                        _asset, vars.user, vars.remainingDebtTokenInStabPool, false\n                    );\n                }\n\n                vars.remainingDebtTokenInStabPool =\n                    vars.remainingDebtTokenInStabPool - singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            } else {\n                break;\n            } // break if the loop reaches a TrenBox with ICR >= MCR\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Attempt to liquidated single TrenBox during Normal Mode.\n     */\n    function _liquidateNormalMode(\n        address _asset,\n        address _borrower,\n        uint256 _debtTokenInStabPool,\n        bool _fullRedistribution\n    )\n        internal\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n        (\n            singleLiquidation.entireTrenBoxDebt,\n            singleLiquidation.entireTrenBoxColl,\n            vars.pendingDebtReward,\n            vars.pendingCollReward\n        ) = ITrenBoxManager(trenBoxManager).getEntireDebtAndColl(_asset, _borrower);\n\n        ITrenBoxManager(trenBoxManager).movePendingTrenBoxRewardsFromLiquidatedToActive(\n            _asset, vars.pendingDebtReward, vars.pendingCollReward\n        );\n        ITrenBoxManager(trenBoxManager).removeStake(_asset, _borrower);\n\n        singleLiquidation.debtTokenGasCompensation =\n            IAdminContract(adminContract).getDebtTokenGasCompensation(_asset);\n\n        uint256 collToLiquidate;\n        if (_fullRedistribution) {\n            collToLiquidate = singleLiquidation.entireTrenBoxColl;\n        } else {\n            singleLiquidation.collGasCompensation =\n                _getCollGasCompensation(_asset, singleLiquidation.entireTrenBoxColl);\n            collToLiquidate =\n                singleLiquidation.entireTrenBoxColl - singleLiquidation.collGasCompensation;\n        }\n\n        (\n            singleLiquidation.debtToOffset,\n            singleLiquidation.collToSendToSP,\n            singleLiquidation.debtToRedistribute,\n            singleLiquidation.collToRedistribute\n        ) = _getOffsetAndRedistributionVals(\n            singleLiquidation.entireTrenBoxDebt, collToLiquidate, _debtTokenInStabPool\n        );\n\n        if (_fullRedistribution) {\n            ITrenBoxManager(trenBoxManager).closeTrenBoxRedistribution(\n                _asset, _borrower, singleLiquidation.debtTokenGasCompensation\n            );\n        } else {\n            ITrenBoxManager(trenBoxManager).closeTrenBoxLiquidation(_asset, _borrower);\n        }\n        emit TrenBoxLiquidated(\n            _asset,\n            _borrower,\n            singleLiquidation.entireTrenBoxDebt,\n            singleLiquidation.entireTrenBoxColl,\n            ITrenBoxManager.TrenBoxManagerOperation.liquidateInNormalMode\n        );\n        return singleLiquidation;\n    }\n\n    /**\n     * @dev Attempt to liquidated single TrenBox during Recovery Mode.\n     */\n    function _liquidateRecoveryMode(\n        address _asset,\n        address _borrower,\n        uint256 _ICR,\n        uint256 _debtTokenInStabPool,\n        uint256 _TCR,\n        uint256 _price,\n        bool _fullRedistribution\n    )\n        internal\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n        if (ITrenBoxManager(trenBoxManager).getTrenBoxOwnersCount(_asset) <= 1) {\n            return singleLiquidation;\n        } // don't liquidate if last TrenBox\n        (\n            singleLiquidation.entireTrenBoxDebt,\n            singleLiquidation.entireTrenBoxColl,\n            vars.pendingDebtReward,\n            vars.pendingCollReward\n        ) = ITrenBoxManager(trenBoxManager).getEntireDebtAndColl(_asset, _borrower);\n\n        singleLiquidation.debtTokenGasCompensation =\n            IAdminContract(adminContract).getDebtTokenGasCompensation(_asset);\n\n        if (_fullRedistribution) {\n            vars.collToLiquidate = singleLiquidation.entireTrenBoxColl;\n        } else {\n            singleLiquidation.collGasCompensation =\n                _getCollGasCompensation(_asset, singleLiquidation.entireTrenBoxColl);\n            vars.collToLiquidate =\n                singleLiquidation.entireTrenBoxColl - singleLiquidation.collGasCompensation;\n        }\n\n        // If ICR <= 100%, purely redistribute the TrenBox across all active TrenBoxes\n        if (_ICR <= IAdminContract(adminContract)._100pct() || _fullRedistribution) {\n            ITrenBoxManager(trenBoxManager).movePendingTrenBoxRewardsFromLiquidatedToActive(\n                _asset, vars.pendingDebtReward, vars.pendingCollReward\n            );\n            ITrenBoxManager(trenBoxManager).removeStake(_asset, _borrower);\n\n            singleLiquidation.debtToOffset = 0;\n            singleLiquidation.collToSendToSP = 0;\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTrenBoxDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n\n            if (_fullRedistribution) {\n                ITrenBoxManager(trenBoxManager).closeTrenBoxRedistribution(\n                    _asset, _borrower, singleLiquidation.debtTokenGasCompensation\n                );\n                emit TrenBoxLiquidated(\n                    _asset,\n                    _borrower,\n                    singleLiquidation.entireTrenBoxDebt,\n                    singleLiquidation.entireTrenBoxColl,\n                    ITrenBoxManager.TrenBoxManagerOperation.redistributeCollateral\n                );\n            } else {\n                ITrenBoxManager(trenBoxManager).closeTrenBoxLiquidation(_asset, _borrower);\n                emit TrenBoxLiquidated(\n                    _asset,\n                    _borrower,\n                    singleLiquidation.entireTrenBoxDebt,\n                    singleLiquidation.entireTrenBoxColl,\n                    ITrenBoxManager.TrenBoxManagerOperation.liquidateInRecoveryMode\n                );\n            }\n\n            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder\n        } else if (\n            (_ICR > IAdminContract(adminContract)._100pct())\n                && (_ICR < IAdminContract(adminContract).getMcr(_asset))\n        ) {\n            ITrenBoxManager(trenBoxManager).movePendingTrenBoxRewardsFromLiquidatedToActive(\n                _asset, vars.pendingDebtReward, vars.pendingCollReward\n            );\n            ITrenBoxManager(trenBoxManager).removeStake(_asset, _borrower);\n\n            (\n                singleLiquidation.debtToOffset,\n                singleLiquidation.collToSendToSP,\n                singleLiquidation.debtToRedistribute,\n                singleLiquidation.collToRedistribute\n            ) = _getOffsetAndRedistributionVals(\n                singleLiquidation.entireTrenBoxDebt, vars.collToLiquidate, _debtTokenInStabPool\n            );\n\n            ITrenBoxManager(trenBoxManager).closeTrenBoxLiquidation(_asset, _borrower);\n            emit TrenBoxLiquidated(\n                _asset,\n                _borrower,\n                singleLiquidation.entireTrenBoxDebt,\n                singleLiquidation.entireTrenBoxColl,\n                ITrenBoxManager.TrenBoxManagerOperation.liquidateInRecoveryMode\n            );\n\n            /**\n             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the\n             * current sequence) and\n             * there are debt tokens in the Stability Pool, only offset, with no redistribution,\n             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n             * The remainder due to the capped rate will be claimable as collateral surplus.\n             */\n        } else if (\n            (_ICR >= IAdminContract(adminContract).getMcr(_asset)) && (_ICR < _TCR)\n                && (singleLiquidation.entireTrenBoxDebt <= _debtTokenInStabPool)\n        ) {\n            ITrenBoxManager(trenBoxManager).movePendingTrenBoxRewardsFromLiquidatedToActive(\n                _asset, vars.pendingDebtReward, vars.pendingCollReward\n            );\n            assert(_debtTokenInStabPool != 0);\n\n            ITrenBoxManager(trenBoxManager).removeStake(_asset, _borrower);\n            singleLiquidation = _getCappedOffsetVals(\n                _asset,\n                singleLiquidation.entireTrenBoxDebt,\n                singleLiquidation.entireTrenBoxColl,\n                _price\n            );\n\n            ITrenBoxManager(trenBoxManager).closeTrenBoxLiquidation(_asset, _borrower);\n            if (singleLiquidation.collToClaim != 0) {\n                ITrenBoxStorage(trenBoxStorage).updateUserClaimableBalance(\n                    _asset, _borrower, singleLiquidation.collToClaim\n                );\n            }\n            emit TrenBoxLiquidated(\n                _asset,\n                _borrower,\n                singleLiquidation.entireTrenBoxDebt,\n                singleLiquidation.collToSendToSP,\n                ITrenBoxManager.TrenBoxManagerOperation.liquidateInRecoveryMode\n            );\n        } else {\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        return singleLiquidation;\n    }\n\n    /**\n     * @dev This function is used when the liquidateTrenBoxes sequence starts during Recovery\n     * Mode.\n     * However, it handles the case where the system *leaves* Recovery Mode, part way\n     * through the liquidation sequence\n     */\n    function _getTotalsFromLiquidateTrenBoxesSequence_RecoveryMode(\n        address _asset,\n        uint256 _price,\n        uint256 _debtTokenInStabPool,\n        uint256 _n,\n        bool _fullRedistribution\n    )\n        internal\n        returns (LiquidationTotals memory totals)\n    {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingDebtTokenInStabPool = _debtTokenInStabPool;\n        vars.backToNormalMode = false;\n        vars.price = _price;\n        vars.entireSystemDebt = getEntireSystemDebt(_asset);\n        vars.entireSystemColl = getEntireSystemColl(_asset);\n\n        vars.user = ISortedTrenBoxes(sortedTrenBoxes).getLast(_asset);\n        address firstUser = ISortedTrenBoxes(sortedTrenBoxes).getFirst(_asset);\n        for (uint256 i = 0; i < _n && vars.user != firstUser;) {\n            // we need to cache it, because current user is likely going to be deleted\n            address nextUser = ISortedTrenBoxes(sortedTrenBoxes).getPrev(_asset, vars.user);\n\n            vars.ICR = ITrenBoxManager(trenBoxManager).getCurrentICR(_asset, vars.user, vars.price);\n\n            if (!vars.backToNormalMode) {\n                // Break the loop if ICR is greater than MCR and Stability Pool is empty\n                if (\n                    vars.ICR >= IAdminContract(adminContract).getMcr(_asset)\n                        && vars.remainingDebtTokenInStabPool == 0\n                ) {\n                    break;\n                }\n\n                uint256 TCR =\n                    TrenMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt, vars.price);\n\n                if (_fullRedistribution) {\n                    singleLiquidation = _liquidateRecoveryMode(\n                        _asset,\n                        vars.user,\n                        vars.ICR,\n                        vars.remainingDebtTokenInStabPool,\n                        TCR,\n                        vars.price,\n                        true\n                    );\n                } else {\n                    singleLiquidation = _liquidateRecoveryMode(\n                        _asset,\n                        vars.user,\n                        vars.ICR,\n                        vars.remainingDebtTokenInStabPool,\n                        TCR,\n                        vars.price,\n                        false\n                    );\n                }\n\n                // Update aggregate trackers\n                vars.remainingDebtTokenInStabPool =\n                    vars.remainingDebtTokenInStabPool - singleLiquidation.debtToOffset;\n                vars.entireSystemDebt = vars.entireSystemDebt - singleLiquidation.debtToOffset;\n                vars.entireSystemColl = vars.entireSystemColl - singleLiquidation.collToSendToSP\n                    - singleLiquidation.collGasCompensation - singleLiquidation.collToClaim;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    _asset, vars.entireSystemColl, vars.entireSystemDebt, vars.price\n                );\n            } else if (\n                vars.backToNormalMode && vars.ICR < IAdminContract(adminContract).getMcr(_asset)\n            ) {\n                if (_fullRedistribution) {\n                    singleLiquidation = _liquidateNormalMode(\n                        _asset, vars.user, vars.remainingDebtTokenInStabPool, true\n                    );\n                } else {\n                    singleLiquidation = _liquidateNormalMode(\n                        _asset, vars.user, vars.remainingDebtTokenInStabPool, false\n                    );\n                }\n\n                vars.remainingDebtTokenInStabPool =\n                    vars.remainingDebtTokenInStabPool - singleLiquidation.debtToOffset;\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            } else {\n                break;\n            } // break if the loop reaches a TrenBox with ICR >= MCR\n\n            vars.user = nextUser;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev In a full liquidation, returns the values for a TrenBox's coll and debt to be offset,\n     * and coll and debt to be redistributed to active trenBoxes.\n     */\n    function _getOffsetAndRedistributionVals(\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _debtTokenInStabPool\n    )\n        internal\n        pure\n        returns (\n            uint256 debtToOffset,\n            uint256 collToSendToSP,\n            uint256 debtToRedistribute,\n            uint256 collToRedistribute\n        )\n    {\n        if (_debtTokenInStabPool != 0) {\n            /**\n             * Offset as much debt & collateral as possible against the Stability Pool, and\n             * redistribute the remainder between all active trenBoxes.\n             *\n             * If the TrenBox's debt is larger than the deposited debt token in the Stability Pool:\n             *\n             * - Offset an amount of the TrenBox's debt equal to the debt token in the\n             * Stability Pool\n             * - Send a fraction of the TrenBox's collateral to the Stability Pool, equal to the\n             * fraction of its offset debt\n             */\n            debtToOffset = TrenMath._min(_debt, _debtTokenInStabPool);\n            collToSendToSP = (_coll * debtToOffset) / _debt;\n            debtToRedistribute = _debt - debtToOffset;\n            collToRedistribute = _coll - collToSendToSP;\n        } else {\n            debtToOffset = 0;\n            collToSendToSP = 0;\n            debtToRedistribute = _debt;\n            collToRedistribute = _coll;\n        }\n    }\n\n    /**\n     * @dev Get its offset coll/debt and coll gas comp, and close the TrenBox.\n     */\n    function _getCappedOffsetVals(\n        address _asset,\n        uint256 _entireTrenBoxDebt,\n        uint256 _entireTrenBoxColl,\n        uint256 _price\n    )\n        internal\n        view\n        returns (LiquidationValues memory singleLiquidation)\n    {\n        singleLiquidation.entireTrenBoxDebt = _entireTrenBoxDebt;\n        singleLiquidation.entireTrenBoxColl = _entireTrenBoxColl;\n        uint256 cappedCollPortion =\n            (_entireTrenBoxDebt * IAdminContract(adminContract).getMcr(_asset)) / _price;\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(_asset, cappedCollPortion);\n        singleLiquidation.debtTokenGasCompensation =\n            IAdminContract(adminContract).getDebtTokenGasCompensation(_asset);\n\n        singleLiquidation.debtToOffset = _entireTrenBoxDebt;\n        singleLiquidation.collToSendToSP = cappedCollPortion - singleLiquidation.collGasCompensation;\n        singleLiquidation.collToClaim = _entireTrenBoxColl - cappedCollPortion;\n        singleLiquidation.debtToRedistribute = 0;\n        singleLiquidation.collToRedistribute = 0;\n    }\n\n    /**\n     *  @dev Checks if its Recovery mode or no by comparing current TCR to CCR.\n     */\n    function _checkPotentialRecoveryMode(\n        address _asset,\n        uint256 _entireSystemColl,\n        uint256 _entireSystemDebt,\n        uint256 _price\n    )\n        internal\n        view\n        returns (bool)\n    {\n        uint256 TCR = TrenMath._computeCR(_entireSystemColl, _entireSystemDebt, _price);\n        return TCR < IAdminContract(adminContract).getCcr(_asset);\n    }\n\n    // -------------------------------- Redemption internal/helper functions ----------------------\n\n    /**\n     * @dev Checks that all redemption requirements are met.\n     */\n    function _validateRedemptionRequirements(\n        address _asset,\n        uint256 _maxFeePercentage,\n        uint256 _debtTokenAmount,\n        uint256 _price\n    )\n        internal\n        view\n    {\n        uint256 redemptionBlockTimestamp =\n            IAdminContract(adminContract).getRedemptionBlockTimestamp(_asset);\n        if (redemptionBlockTimestamp > block.timestamp) {\n            revert TrenBoxManagerOperations__RedemptionIsBlocked();\n        }\n        uint256 redemptionFeeFloor = IAdminContract(adminContract).getRedemptionFeeFloor(_asset);\n        if (_maxFeePercentage < redemptionFeeFloor || _maxFeePercentage > DECIMAL_PRECISION) {\n            revert TrenBoxManagerOperations__FeePercentOutOfBounds(\n                redemptionFeeFloor, DECIMAL_PRECISION\n            );\n        }\n        if (_debtTokenAmount == 0) {\n            revert TrenBoxManagerOperations__EmptyAmount();\n        }\n        uint256 redeemerBalance = IDebtToken(debtToken).balanceOf(msg.sender);\n        if (redeemerBalance < _debtTokenAmount) {\n            revert TrenBoxManagerOperations__InsufficientDebtTokenBalance(redeemerBalance);\n        }\n        uint256 tcr = _getTCR(_asset, _price);\n        uint256 mcr = IAdminContract(adminContract).getMcr(_asset);\n        if (tcr < mcr) {\n            revert TrenBoxManagerOperations__TCRMustBeAboveMCR(tcr, mcr);\n        }\n    }\n\n    /**\n     * @dev Redeem as much collateral as possible from _borrower's TrenBox in exchange for trenUSD\n     * up to _maxDebtTokenAmount.\n     */\n    function _redeemCollateralFromTrenBox(\n        address _asset,\n        address _borrower,\n        uint256 _maxDebtTokenAmount,\n        uint256 _price,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint256 _partialRedemptionHintNICR\n    )\n        internal\n        returns (SingleRedemptionValues memory singleRedemption)\n    {\n        uint256 trenBoxDebt = ITrenBoxManager(trenBoxManager).getTrenBoxDebt(_asset, _borrower);\n        uint256 trenBoxColl = ITrenBoxManager(trenBoxManager).getTrenBoxColl(_asset, _borrower);\n\n        // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the\n        // TrenBox minus the liquidation reserve\n        singleRedemption.debtLot = TrenMath._min(\n            _maxDebtTokenAmount,\n            trenBoxDebt - IAdminContract(adminContract).getDebtTokenGasCompensation(_asset)\n        );\n\n        // Get the debtToken lot of equivalent value in USD\n        singleRedemption.collLot = (singleRedemption.debtLot * DECIMAL_PRECISION) / _price;\n\n        // Apply redemption softening\n        singleRedemption.collLot =\n            (singleRedemption.collLot * redemptionSofteningParam) / PERCENTAGE_PRECISION;\n\n        // Decrease the debt and collateral of the current TrenBox according to the debt token lot\n        // and corresponding coll to send\n\n        uint256 newDebt = trenBoxDebt - singleRedemption.debtLot;\n        uint256 newColl = trenBoxColl - singleRedemption.collLot;\n\n        if (newDebt == IAdminContract(adminContract).getDebtTokenGasCompensation(_asset)) {\n            ITrenBoxManager(trenBoxManager).executeFullRedemption(_asset, _borrower, newColl);\n        } else {\n            uint256 newNICR = TrenMath._computeNominalCR(newColl, newDebt);\n\n            /**\n             * If the provided hint is out of date, we bail since trying to reinsert without a good\n             * hint will almost certainly result in running out of gas.\n             *\n             * If the resultant net debt of the partial is less than the minimum, net debt we bail.\n             */\n            if (\n                newNICR != _partialRedemptionHintNICR\n                    || _getNetDebt(_asset, newDebt)\n                        < IAdminContract(adminContract).getMinNetDebt(_asset)\n            ) {\n                singleRedemption.cancelledPartial = true;\n                return singleRedemption;\n            }\n\n            ITrenBoxManager(trenBoxManager).executePartialRedemption(\n                _asset,\n                _borrower,\n                newDebt,\n                newColl,\n                newNICR,\n                _upperPartialRedemptionHint,\n                _lowerPartialRedemptionHint\n            );\n        }\n\n        return singleRedemption;\n    }\n\n    /**\n     * @notice Set a new redemption softening parameter\n     * @param _redemptionSofteningParam The new number of redemption softening parameter.\n     */\n    function setRedemptionSofteningParam(uint256 _redemptionSofteningParam) public {\n        if (msg.sender != timelockAddress) {\n            revert TrenBoxManagerOperations__NotTimelock();\n        }\n        if (_redemptionSofteningParam < 9700 || _redemptionSofteningParam > PERCENTAGE_PRECISION) {\n            revert TrenBoxManagerOperations__InvalidParam();\n        }\n        redemptionSofteningParam = _redemptionSofteningParam;\n        emit RedemptionSoftenParamChanged(_redemptionSofteningParam);\n    }\n\n    function authorizeUpgrade(address newImplementation) public {\n        _authorizeUpgrade(newImplementation);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner { }\n}\n"
    },
    "contracts/TrenBoxStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { OwnableUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { UUPSUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from\n    \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport { SafetyTransfer } from \"./Dependencies/SafetyTransfer.sol\";\nimport { ConfigurableAddresses } from \"./Dependencies/ConfigurableAddresses.sol\";\n\nimport { ITrenBoxStorage } from \"./Interfaces/ITrenBoxStorage.sol\";\nimport { IDeposit } from \"./Interfaces/IDeposit.sol\";\n\n/// @title TrenboxStorage\n/// @notice A contract storage of the collateral amount, debt and gas compensation for each\n/// TrenBox.\ncontract TrenBoxStorage is\n    OwnableUpgradeable,\n    UUPSUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ITrenBoxStorage,\n    ConfigurableAddresses\n{\n    using SafeERC20 for IERC20;\n\n    /// @notice The contract name.\n    string public constant NAME = \"TrenBoxStorage\";\n\n    /// @notice The balances of each collateral asset in the storage.\n    mapping(address collateral => CollBalances) internal collateralBalances;\n\n    /// @notice The balances of each debt in the storage.\n    mapping(address collateral => DebtBalances) internal debtBalances;\n\n    /// @notice The balances of each collateral asset that the user can claim from storage.\n    mapping(address user => mapping(address collateral => uint256 balance)) internal\n        userClaimableCollateralBalances;\n\n    // ------------------------------------------ Modifiers ---------------------------------------\n\n    modifier onlyTrenBoxManager() {\n        if (msg.sender != trenBoxManager) {\n            revert TrenBoxStorage__TrenBoxManagerOnly();\n        }\n        _;\n    }\n\n    modifier onlyBorrowerOperations() {\n        if (msg.sender != borrowerOperations) {\n            revert TrenBoxStorage__BorrowerOperationsOnly();\n        }\n        _;\n    }\n\n    modifier onlyTrenBoxManagerOperations() {\n        if (msg.sender != trenBoxManagerOperations) {\n            revert TrenBoxStorage__TrenBoxManagerOperationsOnly();\n        }\n        _;\n    }\n\n    modifier onlyBorrowerOperationsOrTrenBoxManager() {\n        if (msg.sender != borrowerOperations && msg.sender != trenBoxManager) {\n            revert TrenBoxStorage__BorrowerOperationsOrTrenBoxManagerOnly();\n        }\n        _;\n    }\n\n    modifier onlyAuthorizedProtocolContracts() {\n        if (\n            msg.sender != borrowerOperations && msg.sender != stabilityPool\n                && msg.sender != trenBoxManager\n        ) {\n            revert TrenBoxStorage__NotAuthorizedContract();\n        }\n        _;\n    }\n\n    // ------------------------------------------ Initializer -------------------------------------\n\n    /// @dev Sets an intiial owner for the contract.\n    /// @param initialOwner The address of initial owner.\n    function initialize(address initialOwner) external initializer {\n        __Ownable_init(initialOwner);\n        __ReentrancyGuard_init();\n        __UUPSUpgradeable_init();\n    }\n\n    // ------------------------------------------ Getters -----------------------------------------\n\n    /// @inheritdoc ITrenBoxStorage\n    function getActiveCollateralBalance(address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return collateralBalances[_collateral].active;\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    function getActiveDebtBalance(address _collateral) external view override returns (uint256) {\n        return debtBalances[_collateral].active;\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    function getLiquidatedCollateralBalance(address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return collateralBalances[_collateral].liquidated;\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    function getLiquidatedDebtBalance(address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return debtBalances[_collateral].liquidated;\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    function getTotalDebtBalance(address _collateral) external view override returns (uint256) {\n        return debtBalances[_collateral].active + debtBalances[_collateral].liquidated;\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    function getTotalCollateralBalance(address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return collateralBalances[_collateral].active + collateralBalances[_collateral].liquidated;\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    function getClaimableCollateralBalance(address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return collateralBalances[_collateral].claimable;\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    function getUserClaimableCollateralBalance(\n        address _collateral,\n        address _account\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return userClaimableCollateralBalances[_account][_collateral];\n    }\n\n    // ------------------------------------------ External functions ------------------------------\n\n    /// @inheritdoc ITrenBoxStorage\n    /// @dev Can only be called by BorrowerOperations contract\n    function increaseActiveDebt(\n        address _collateral,\n        uint256 _amount\n    )\n        external\n        override\n        onlyBorrowerOperations\n    {\n        _updateActiveDebt(_collateral, _amount, true);\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    /// @dev Can only be called by BorrowerOperations or TrenBoxManager or StabilityPool contracts\n    function decreaseActiveDebt(\n        address _collateral,\n        uint256 _amount\n    )\n        external\n        override\n        onlyAuthorizedProtocolContracts\n    {\n        _updateActiveDebt(_collateral, _amount, false);\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    /// @dev Can only be called by TrenBoxManager contract\n    function decreaseActiveBalancesAfterRedemption(\n        address _collateral,\n        uint256 _debtAmount,\n        uint256 _collAmount\n    )\n        external\n        override\n        onlyTrenBoxManager\n    {\n        _updateActiveDebt(_collateral, _debtAmount, false);\n        _updateActiveCollateral(_collateral, _collAmount, false);\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    /// @dev Can only be called by BorrowerOperations contract\n    function increaseActiveCollateral(\n        address _collateral,\n        uint256 _amount\n    )\n        external\n        override\n        onlyBorrowerOperations\n    {\n        _updateActiveCollateral(_collateral, _amount, true);\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    /// @dev Can only be called by TrenBoxManagerOperations contract\n    function decreaseActiveCollateral(\n        address _collateral,\n        uint256 _amount\n    )\n        external\n        override\n        onlyTrenBoxManagerOperations\n    {\n        _updateActiveCollateral(_collateral, _amount, false);\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    /// @dev Can only be called by TrenBoxManager contract\n    function updateDebtAndCollateralBalances(\n        address _collateral,\n        uint256 _debtAmount,\n        uint256 _collAmount,\n        bool _isActiveIncrease\n    )\n        external\n        override\n        onlyTrenBoxManager\n    {\n        uint256 newLiquidatedDebt;\n        uint256 newLiquidatedColl;\n        if (_isActiveIncrease) {\n            _updateActiveDebt(_collateral, _debtAmount, true);\n            newLiquidatedDebt = debtBalances[_collateral].liquidated - _debtAmount;\n            _updateActiveCollateral(_collateral, _collAmount, true);\n            newLiquidatedColl = collateralBalances[_collateral].liquidated - _collAmount;\n        } else {\n            _updateActiveDebt(_collateral, _debtAmount, false);\n            newLiquidatedDebt = debtBalances[_collateral].liquidated + _debtAmount;\n            _updateActiveCollateral(_collateral, _collAmount, false);\n            newLiquidatedColl = collateralBalances[_collateral].liquidated + _collAmount;\n        }\n\n        debtBalances[_collateral].liquidated = newLiquidatedDebt;\n        emit LiquidatedDebtBalanceUpdated(_collateral, newLiquidatedDebt);\n\n        collateralBalances[_collateral].liquidated = newLiquidatedColl;\n        emit LiquidatedCollateralBalanceUpdated(_collateral, newLiquidatedColl);\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    /// @dev Can only be called by TrenBoxManager contract\n    function updateUserAndEntireClaimableBalance(\n        address _collateral,\n        address _account,\n        uint256 _amount\n    )\n        external\n        override\n        onlyTrenBoxManager\n    {\n        _updateClaimableCollateral(_collateral, _amount, true);\n        _updateUserClaimableBalance(_collateral, _account, _amount);\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    /// @dev Can only be called by TrenBoxManagerOperations contract\n    function increaseClaimableCollateral(\n        address _collateral,\n        uint256 _amount\n    )\n        external\n        override\n        onlyTrenBoxManagerOperations\n    {\n        _updateClaimableCollateral(_collateral, _amount, true);\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    /// @dev Can only be called by TrenBoxManagerOperations contract\n    function updateUserClaimableBalance(\n        address _collateral,\n        address _account,\n        uint256 _amount\n    )\n        external\n        override\n        onlyTrenBoxManagerOperations\n    {\n        _updateUserClaimableBalance(_collateral, _account, _amount);\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    /// @dev Can only be called by BorrowerOperations or TrenBoxManager or StabilityPool contract\n    function sendCollateral(\n        address _collateral,\n        address _account,\n        uint256 _amount\n    )\n        external\n        override\n        nonReentrant\n        onlyAuthorizedProtocolContracts\n    {\n        uint256 safetyTransferAmount = SafetyTransfer.decimalsCorrection(_collateral, _amount);\n        if (safetyTransferAmount == 0) return;\n\n        _updateActiveCollateral(_collateral, _amount, false);\n\n        IERC20(_collateral).safeTransfer(_account, safetyTransferAmount);\n\n        if (isStabilityPool(_account)) {\n            IDeposit(_account).receivedERC20(_collateral, _amount);\n        }\n\n        emit CollateralSent(_account, _collateral, safetyTransferAmount);\n    }\n\n    /// @inheritdoc ITrenBoxStorage\n    /// @dev Can only be called by BorrowerOperations contract\n    function claimCollateral(\n        address _collateral,\n        address _account\n    )\n        external\n        override\n        onlyBorrowerOperations\n    {\n        mapping(address => uint256) storage userBalance = userClaimableCollateralBalances[_account];\n        uint256 claimableColl = userBalance[_collateral];\n\n        uint256 safetyTransferAmount = SafetyTransfer.decimalsCorrection(_collateral, claimableColl);\n        if (safetyTransferAmount == 0) {\n            revert TrenBoxStorage__NoClaimableCollateral();\n        }\n\n        userBalance[_collateral] = 0;\n        emit UserClaimableCollateralBalanceUpdated(_account, _collateral, 0);\n\n        _updateClaimableCollateral(_collateral, claimableColl, false);\n\n        IERC20(_collateral).safeTransfer(_account, safetyTransferAmount);\n    }\n\n    function authorizeUpgrade(address _newImplementation) public {\n        _authorizeUpgrade(_newImplementation);\n    }\n\n    // ------------------------------------------ Private/internal functions ----------------------\n\n    /**\n     * @dev Updates active debt balance for a specific collateral asset.\n     * @param _collateral The address of collateral asset.\n     * @param _amount The number of debt to update.\n     * @param _isIncrease The indicator that shows increasing or decreasing of active debt balance.\n     */\n    function _updateActiveDebt(address _collateral, uint256 _amount, bool _isIncrease) private {\n        uint256 newDebt;\n        if (_isIncrease) newDebt = debtBalances[_collateral].active + _amount;\n        else newDebt = debtBalances[_collateral].active - _amount;\n\n        debtBalances[_collateral].active = newDebt;\n        emit ActiveDebtBalanceUpdated(_collateral, newDebt);\n    }\n\n    /**\n     * @dev Updates active balance for a specific collateral asset.\n     * @param _collateral The address of collateral asset.\n     * @param _amount The number of collateral to update.\n     * @param _isIncrease The indicator that shows increasing or decreasing of active balance.\n     */\n    function _updateActiveCollateral(\n        address _collateral,\n        uint256 _amount,\n        bool _isIncrease\n    )\n        private\n    {\n        uint256 newColl;\n        if (_isIncrease) newColl = collateralBalances[_collateral].active + _amount;\n        else newColl = collateralBalances[_collateral].active - _amount;\n\n        collateralBalances[_collateral].active = newColl;\n        emit ActiveCollateralBalanceUpdated(_collateral, newColl);\n    }\n\n    /**\n     * @dev Updates entire claimable balance for a specific collateral asset.\n     * @param _collateral The address of collateral asset.\n     * @param _amount The number of collateral to update.\n     * @param _isIncrease The indicator that shows increasing or decreasing of entire claimable\n     * balance.\n     */\n    function _updateClaimableCollateral(\n        address _collateral,\n        uint256 _amount,\n        bool _isIncrease\n    )\n        private\n    {\n        uint256 newBalance;\n        if (_isIncrease) newBalance = collateralBalances[_collateral].claimable + _amount;\n        else newBalance = collateralBalances[_collateral].claimable - _amount;\n\n        collateralBalances[_collateral].claimable = newBalance;\n        emit ClaimableCollateralBalanceUpdated(_collateral, newBalance);\n    }\n\n    /**\n     * @dev Updates user claimable balance for a specific collateral asset.\n     * @param _collateral The address of collateral asset.\n     * @param _account The address of the caller.\n     * @param _amount The number of collateral to update.\n     */\n    function _updateUserClaimableBalance(\n        address _collateral,\n        address _account,\n        uint256 _amount\n    )\n        private\n    {\n        mapping(address => uint256) storage userBalance = userClaimableCollateralBalances[_account];\n        uint256 newAmount = userBalance[_collateral] + _amount;\n        userBalance[_collateral] = newAmount;\n\n        emit UserClaimableCollateralBalanceUpdated(_account, _collateral, newAmount);\n    }\n\n    /**\n     * @dev Checks if caller is a Stability Pool contract.\n     * @param _account The address of the caller.\n     * @return The boolean value indicating whether the operation succeeded.\n     */\n    function isStabilityPool(address _account) private view returns (bool) {\n        return (_account == stabilityPool);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner { }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}